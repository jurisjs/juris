<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Juris Test Interface - Pure Juris Implementation</title>
    <!--script src="../src/juris.mini.js"></script-->
    <script src="../src/juris.js"></script>
    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            background: #1a1a1a;
            color: #e0e0e0;
            overflow: hidden;
        }
        
        /* Override Prism.js theme for better dark mode */
        .prism-code {
            background: #1a1a1a !important;
            color: #e0e0e0 !important;
        }
        
        /* Custom status and result styles */
        .status-pass { color: #4CAF50; font-weight: bold; }
        .status-fail { color: #f44336; font-weight: bold; }
        .status-pending { color: #FF9800; font-weight: bold; }
        .status-running { color: #2196F3; font-weight: bold; }
        
        /* Selected test item highlighting */
        .test-item-selected {
            background: #2d2d2d !important;
            border-left: 4px solid #667eea !important;
        }
        
        .test-item:hover {
            background: #252525 !important;
        }
        
        .test-result {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
            background: #2d2d2d;
            border-left: 4px solid #666;
        }
        
        .test-result.pass { border-left-color: #4CAF50; background: rgba(76, 175, 80, 0.1); }
        .test-result.fail { border-left-color: #f44336; background: rgba(244, 67, 54, 0.1); }
        .test-result.pending { border-left-color: #FF9800; background: rgba(255, 152, 0, 0.1); }
        
        .assertion {
            margin: 5px 0;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 14px;
        }
        
        .assertion.pass {
            background: rgba(76, 175, 80, 0.2);
            color: #4CAF50;
        }
        
        .assertion.fail {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
        }
        
        .error-stack {
            background: #2a1a1a;
            padding: 10px;
            margin: 5px 0;
            border-radius: 3px;
            font-size: 12px;
            white-space: pre-wrap;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <div id="app"></div>

    <script>
        // Test Framework Implementation
        class JurisTestFramework {
            constructor() {
                this.tests = new Map();
                this.results = new Map();
                this.currentTest = null;
                this.assertions = [];
            }

            expect(actual) {
                return {
                    toBe: (expected) => this.assert(actual === expected, `Expected ${actual} to be ${expected}`),
                    toEqual: (expected) => this.assert(JSON.stringify(actual) === JSON.stringify(expected), `Expected ${JSON.stringify(actual)} to equal ${JSON.stringify(expected)}`),
                    toBeTruthy: () => this.assert(!!actual, `Expected ${actual} to be truthy`),
                    toBeFalsy: () => this.assert(!actual, `Expected ${actual} to be falsy`),
                    toContain: (item) => this.assert(actual.includes && actual.includes(item), `Expected ${actual} to contain ${item}`),
                    toBeInstanceOf: (constructor) => this.assert(actual instanceof constructor, `Expected ${actual} to be instance of ${constructor.name}`),
                    toHaveProperty: (property) => this.assert(actual.hasOwnProperty(property), `Expected ${actual} to have property ${property}`),
                    toBeLessThan: (expected) => this.assert(actual < expected, `Expected ${actual} to be less than ${expected}`),
                    toBeGreaterThan: (expected) => this.assert(actual > expected, `Expected ${actual} to be greater than ${expected}`),
                    toBeLessThanOrEqual: (expected) => this.assert(actual <= expected, `Expected ${actual} to be less than or equal to ${expected}`),
                    toBeGreaterThanOrEqual: (expected) => this.assert(actual >= expected, `Expected ${actual} to be greater than or equal to ${expected}`),
                    toBeNull: () => this.assert(actual === null, `Expected ${actual} to be null`),
                    toBeUndefined: () => this.assert(actual === undefined, `Expected ${actual} to be undefined`),
                    toBeDefined: () => this.assert(actual !== undefined, `Expected ${actual} to be defined`),
                    toHaveLength: (length) => this.assert(actual.length === length, `Expected ${actual} to have length ${length}, but got ${actual.length}`),
                    toMatch: (regex) => this.assert(regex.test(actual), `Expected ${actual} to match ${regex}`),
                    toThrow: () => {
                        let threw = false;
                        try {
                            actual();
                        } catch (e) {
                            threw = true;
                        }
                        this.assert(threw, `Expected function to throw`);
                    }
                };
            }

            assert(condition, message) {
                const assertion = { condition, message, passed: condition };
                this.assertions.push(assertion);
                
                if (!condition) {
                    throw new Error(message);
                }
                
                return condition;
            }

            async runTest(testName) {
                const test = this.tests.get(testName);
                if (!test) return;

                this.currentTest = testName;
                this.assertions = [];
                
                const startTime = performance.now();
                let result = {
                    name: testName,
                    status: 'running',
                    duration: 0,
                    assertions: [],
                    error: null
                };

                try {
                    await test.fn();
                    result.status = 'pass';
                    result.assertions = [...this.assertions];
                } catch (error) {
                    result.status = 'fail';
                    result.error = error;
                    result.assertions = [...this.assertions];
                }

                result.duration = performance.now() - startTime;
                this.results.set(testName, result);
                this.currentTest = null;
                
                return result;
            }

            addTest(name, category, fn, code) {
                this.tests.set(name, { name, category, fn, code });
            }

            getTestsByCategory() {
                const categories = {};
                for (const [name, test] of this.tests) {
                    if (!categories[test.category]) {
                        categories[test.category] = [];
                    }
                    categories[test.category].push({ name, ...test });
                }
                return categories;
            }
        }

        // Initialize test framework
        const testFramework = new JurisTestFramework();

        // Enhanced syntax highlighting using Prism.js
        function highlightCode(code) {
            if (typeof Prism !== 'undefined') {
                return Prism.highlight(code, Prism.languages.javascript, 'javascript');
            }
            // Fallback if Prism isn't loaded
            return code;
        }

        // Define comprehensive test suite
        // Define comprehensive test suite
function defineTests() {
    // State Management Tests
    testFramework.addTest('Basic State Operations', 'State Management', async function() {
        const juris = new Juris();
        
        juris.setState('user.name', 'John');
        await new Promise(resolve => setTimeout(resolve, 10));
        testFramework.expect(juris.getState('user.name')).toBe('John');
        
        juris.setState('user.age', 30);
        await new Promise(resolve => setTimeout(resolve, 10));
        testFramework.expect(juris.getState('user.age')).toBe(30);
        
        await new Promise(resolve => setTimeout(resolve, 10));
        testFramework.expect(juris.getState('nonexistent', 'default')).toBe('default');
    }, `const juris = new Juris();

juris.setState('user.name', 'John');
testFramework.expect(juris.getState('user.name')).toBe('John');

juris.setState('user.age', 30);
testFramework.expect(juris.getState('user.age')).toBe(30);

testFramework.expect(juris.getState('nonexistent', 'default')).toBe('default');`);

    testFramework.addTest('State Reactivity', 'State Management', async function() {
        const juris = new Juris();
        let callCount = 0;
        let lastValue = null;
        
        const unsubscribe = juris.subscribe('counter', (value) => {
            callCount++;
            lastValue = value;
        });
        
        juris.setState('counter', 1);
        await new Promise(resolve => setTimeout(resolve, 10));
        
        testFramework.expect(callCount).toBe(1);
        testFramework.expect(lastValue).toBe(1);
        
        juris.setState('counter', 2);
        await new Promise(resolve => setTimeout(resolve, 10));
        
        testFramework.expect(callCount).toBe(2);
        testFramework.expect(lastValue).toBe(2);
        
        unsubscribe();
    }, `const juris = new Juris();
let callCount = 0;
let lastValue = null;

const unsubscribe = juris.subscribe('counter', (value) => {
    callCount++;
    lastValue = value;
});

juris.setState('counter', 1);
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(callCount).toBe(1);
testFramework.expect(lastValue).toBe(1);

juris.setState('counter', 2);
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(callCount).toBe(2);
testFramework.expect(lastValue).toBe(2);

unsubscribe();`);

    testFramework.addTest('Deep State Paths', 'State Management', async function() {
        const juris = new Juris();
        
        juris.setState('app.user.profile.settings.theme', 'dark');
        juris.setState('app.user.profile.settings.language', 'en');
        
        await new Promise(resolve => setTimeout(resolve, 10));
        testFramework.expect(juris.getState('app.user.profile.settings.theme')).toBe('dark');
        testFramework.expect(juris.getState('app.user.profile.settings')).toHaveProperty('theme');
        testFramework.expect(juris.getState('app.user.profile.settings')).toHaveProperty('language');
    }, `const juris = new Juris();

juris.setState('app.user.profile.settings.theme', 'dark');
juris.setState('app.user.profile.settings.language', 'en');

testFramework.expect(juris.getState('app.user.profile.settings.theme')).toBe('dark');
testFramework.expect(juris.getState('app.user.profile.settings')).toHaveProperty('theme');
testFramework.expect(juris.getState('app.user.profile.settings')).toHaveProperty('language');`);

    testFramework.addTest('Array State Operations', 'State Management', async function() {
        const juris = new Juris();
    
    juris.setState('todos', []);
    juris.setState('todos', [{ id: 1, text: 'Learn Juris', done: false }]);
    
    // ✅ This is perfect - waiting for state operations to complete
    await new Promise(resolve => setTimeout(resolve, 10));
    const todos = juris.getState('todos');
    testFramework.expect(Array.isArray(todos)).toBeTruthy();
    testFramework.expect(todos.length).toBe(1);
    testFramework.expect(todos[0].text).toBe('Learn Juris');
    }, `const juris = new Juris();
    
    juris.setState('todos', []);
    juris.setState('todos', [{ id: 1, text: 'Learn Juris', done: false }]);
    
    // ✅ This is perfect - waiting for state operations to complete
    await new Promise(resolve => setTimeout(resolve, 10));
    const todos = juris.getState('todos');
    testFramework.expect(Array.isArray(todos)).toBeTruthy();
    testFramework.expect(todos.length).toBe(1);
    testFramework.expect(todos[0].text).toBe('Learn Juris');`);

    testFramework.addTest('Multiple State Subscribers', 'State Management', async function() {
        const juris = new Juris();
        let subscriber1Called = 0;
        let subscriber2Called = 0;
        
        juris.subscribe('counter', () => subscriber1Called++);
        juris.subscribe('counter', () => subscriber2Called++);
        
        juris.setState('counter', 5);
        await new Promise(resolve => setTimeout(resolve, 10));
        
        testFramework.expect(subscriber1Called).toBe(1);
        testFramework.expect(subscriber2Called).toBe(1);
    }, `const juris = new Juris();
let subscriber1Called = 0;
let subscriber2Called = 0;

juris.subscribe('counter', () => subscriber1Called++);
juris.subscribe('counter', () => subscriber2Called++);

juris.setState('counter', 5);
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(subscriber1Called).toBe(1);
testFramework.expect(subscriber2Called).toBe(1);`);

    // Component System Tests
    testFramework.addTest('Component Registration', 'Component System', async function() {
        const juris = new Juris();
        
        const TestComponent = (props, context) => ({
            div: {
                text: 'Hello World'
            }
        });
        
        juris.registerComponent('TestComponent', TestComponent);
        testFramework.expect(juris.getComponent('TestComponent')).toBe(TestComponent);
    }, `const juris = new Juris();

const TestComponent = (props, context) => ({
    div: {
        text: 'Hello World'
    }
});

juris.registerComponent('TestComponent', TestComponent);
testFramework.expect(juris.getComponent('TestComponent')).toBe(TestComponent);`);

    testFramework.addTest('Component Props Handling', 'Component System', async function() {
        const juris = new Juris();
        
        const Greeting = (props, context) => ({
            div: {
                text: `Hello, ${props.name}!`,
                className: props.className || 'greeting'
            }
        });
        
        juris.registerComponent('Greeting', Greeting);
        
        const element = juris.componentManager.create('Greeting', { 
            name: 'World', 
            className: 'custom-greeting' 
        });
        
        testFramework.expect(element.textContent).toBe('Hello, World!');
        testFramework.expect(element.className).toBe('custom-greeting');
    }, `const juris = new Juris();

const Greeting = (props, context) => ({
    div: {
        text: \`Hello, \${props.name}!\`,
        className: props.className || 'greeting'
    }
});

juris.registerComponent('Greeting', Greeting);

const element = juris.componentManager.create('Greeting', { 
    name: 'World', 
    className: 'custom-greeting' 
});

testFramework.expect(element.textContent).toBe('Hello, World!');
testFramework.expect(element.className).toBe('custom-greeting');`);

    testFramework.addTest('Component Event Handlers', 'Component System', async function() {
        const juris = new Juris();
        let clicked = false;
        
        const Button = (props, context) => ({
            button: {
                text: props.text,
                onclick: () => { clicked = true; }
            }
        });
        
        juris.registerComponent('Button', Button);
        const element = juris.componentManager.create('Button', { text: 'Click me' });
        
        element.click();
        testFramework.expect(clicked).toBeTruthy();
    }, `const juris = new Juris();
let clicked = false;

const Button = (props, context) => ({
    button: {
        text: props.text,
        onclick: () => { clicked = true; }
    }
});

juris.registerComponent('Button', Button);
const element = juris.componentManager.create('Button', { text: 'Click me' });

element.click();
testFramework.expect(clicked).toBeTruthy();`);

    testFramework.addTest('Component Local State', 'Component System', async function() {
        const juris = new Juris();
        let contextRef = null;
        
        const Counter = (props, context) => {
            contextRef = context;
            const [getCount, setCount] = context.newState('count', 0);
            
            return {
                div: {
                    children: [
                        { span: { text: () => `Count: ${getCount()}` } },
                        { button: { 
                            text: '+',
                            onclick: () => setCount(getCount() + 1)
                        }}
                    ]
                }
            };
        };
        
        juris.registerComponent('Counter', Counter);
        const element = juris.componentManager.create('Counter');
        
        testFramework.expect(contextRef).toBeTruthy();
        testFramework.expect(typeof contextRef.newState).toBe('function');
    }, `const juris = new Juris();
let contextRef = null;

const Counter = (props, context) => {
    contextRef = context;
    const [getCount, setCount] = context.newState('count', 0);
    
    return {
        div: {
            children: [
                { span: { text: () => \`Count: \${getCount()}\` } },
                { button: { 
                    text: '+',
                    onclick: () => setCount(getCount() + 1)
                }}
            ]
        }
    };
};

juris.registerComponent('Counter', Counter);
const element = juris.componentManager.create('Counter');

testFramework.expect(contextRef).toBeTruthy();
testFramework.expect(typeof contextRef.newState).toBe('function');`);

    // Render Modes Tests
    testFramework.addTest('Fine-grained Render Mode', 'Render Modes', async function() {
        const juris = new Juris();
        juris.setRenderMode('fine-grained');
        
        testFramework.expect(juris.getRenderMode()).toBe('fine-grained');
        testFramework.expect(juris.isFineGrained()).toBeTruthy();
        testFramework.expect(juris.isBatchMode()).toBeFalsy();
    }, `const juris = new Juris();
juris.setRenderMode('fine-grained');

testFramework.expect(juris.getRenderMode()).toBe('fine-grained');
testFramework.expect(juris.isFineGrained()).toBeTruthy();
testFramework.expect(juris.isBatchMode()).toBeFalsy();`);

    // DOM Rendering Tests
    testFramework.addTest('Basic DOM Rendering', 'DOM Rendering', async function() {
        const juris = new Juris();
        
        const vnode = {
            div: {
                className: 'test-div',
                text: 'Hello World'
            }
        };
        
        const element = juris.domRenderer.render(vnode);
        testFramework.expect(element.tagName).toBe('DIV');
        testFramework.expect(element.className).toBe('test-div');
        testFramework.expect(element.textContent).toBe('Hello World');
    }, `const juris = new Juris();

const vnode = {
    div: {
        className: 'test-div',
        text: 'Hello World'
    }
};

const element = juris.domRenderer.render(vnode);
testFramework.expect(element.tagName).toBe('DIV');
testFramework.expect(element.className).toBe('test-div');
testFramework.expect(element.textContent).toBe('Hello World');`);

    testFramework.addTest('Reactive DOM Updates', 'DOM Rendering', async function() {
        const juris = new Juris();
        juris.setState('message', 'Initial');
        await new Promise(resolve => setTimeout(resolve, 10));
        const vnode = {
            div: {
                text: () => juris.getState('message'),
                className: () => `msg-${juris.getState('message').toLowerCase()}`
            }
        };
        
        const element = juris.domRenderer.render(vnode);
        testFramework.expect(element.textContent).toBe('Initial');
        testFramework.expect(element.className).toBe('msg-initial');
        
        juris.setState('message', 'Updated');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        testFramework.expect(element.textContent).toBe('Updated');
        testFramework.expect(element.className).toBe('msg-updated');
    }, `const juris = new Juris();
juris.setState('message', 'Initial');

const vnode = {
    div: {
        text: () => juris.getState('message'),
        className: () => \`msg-\${juris.getState('message').toLowerCase()}\`
    }
};

const element = juris.domRenderer.render(vnode);
testFramework.expect(element.textContent).toBe('Initial');
testFramework.expect(element.className).toBe('msg-initial');

juris.setState('message', 'Updated');
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.textContent).toBe('Updated');
testFramework.expect(element.className).toBe('msg-updated');`);

    testFramework.addTest('Dynamic Children Rendering', 'DOM Rendering', async function() {
        const juris = new Juris();
        juris.setState('items', ['apple', 'banana']);
        await new Promise(resolve => setTimeout(resolve, 10));
        const vnode = {
            ul: {
                children: () => {
                    const items = juris.getState('items') || [];
                    return items.map(item => ({
                        li: { text: item, key: item }
                    }));
                }
            }
        };
        
        const element = juris.domRenderer.render(vnode);
        testFramework.expect(element.children.length).toBe(2);
        testFramework.expect(element.children[0].textContent).toBe('apple');
        
        juris.setState('items', ['apple', 'banana', 'cherry']);
        await new Promise(resolve => setTimeout(resolve, 10));
        
        testFramework.expect(element.children.length).toBe(3);
        testFramework.expect(element.children[2].textContent).toBe('cherry');
    }, `const juris = new Juris();
juris.setState('items', ['apple', 'banana']);

const vnode = {
    ul: {
        children: () => {
            const items = juris.getState('items') || [];
            return items.map(item => ({
                li: { text: item, key: item }
            }));
        }
    }
};

const element = juris.domRenderer.render(vnode);
testFramework.expect(element.children.length).toBe(2);
testFramework.expect(element.children[0].textContent).toBe('apple');

juris.setState('items', ['apple', 'banana', 'cherry']);
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.children.length).toBe(3);
testFramework.expect(element.children[2].textContent).toBe('cherry');`);

    testFramework.addTest('Dynamic Style Rendering', 'DOM Rendering', async function() {
        const juris = new Juris();
        juris.setState('theme', 'light');
        
        const vnode = {
            div: {
                style: () => ({
                    backgroundColor: juris.getState('theme') === 'dark' ? '#333' : '#fff',
                    color: juris.getState('theme') === 'dark' ? '#fff' : '#333',
                    padding: '10px'
                }),
                text: 'Themed content'
            }
        };
        
        const element = juris.domRenderer.render(vnode);
        testFramework.expect(element.style.backgroundColor).toBe('rgb(255, 255, 255)');
        
        juris.setState('theme', 'dark');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        testFramework.expect(element.style.backgroundColor).toBe('rgb(51, 51, 51)');
    }, `const juris = new Juris();
juris.setState('theme', 'light');

const vnode = {
    div: {
        style: () => ({
            backgroundColor: juris.getState('theme') === 'dark' ? '#333' : '#fff',
            color: juris.getState('theme') === 'dark' ? '#fff' : '#333',
            padding: '10px'
        }),
        text: 'Themed content'
    }
};

const element = juris.domRenderer.render(vnode);
testFramework.expect(element.style.backgroundColor).toBe('rgb(255, 255, 255)');

juris.setState('theme', 'dark');
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.style.backgroundColor).toBe('rgb(51, 51, 51)');`);

    // Performance Tests
    testFramework.addTest('Large State Updates Performance', 'Performance', async function() {
        const juris = new Juris();
        const startTime = performance.now();
        
        // Create 1000 state entries
        for (let i = 0; i < 1000; i++) {
            juris.setState(`items.${i}`, { id: i, name: `Item ${i}`, active: i % 2 === 0 });
        }
        await new Promise(resolve => setTimeout(resolve, 10));
        const duration = performance.now() - startTime;
        testFramework.expect(duration).toBeLessThan(500); // Should complete in under 500ms
        testFramework.expect(juris.getState('items.999.name')).toBe('Item 999');
    }, `const juris = new Juris();
const startTime = performance.now();

// Create 1000 state entries
for (let i = 0; i < 1000; i++) {
    juris.setState(\`items.\${i}\`, { id: i, name: \`Item \${i}\`, active: i % 2 === 0 });
}

const duration = performance.now() - startTime;
testFramework.expect(duration).toBeLessThan(500); // Should complete in under 500ms
testFramework.expect(juris.getState('items.999.name')).toBe('Item 999');`);

    testFramework.addTest('Component Creation Performance', 'Performance', async function() {
        const juris = new Juris();
        
        const SimpleComponent = (props, context) => ({
            div: { text: props.text || 'Default' }
        });
        
        juris.registerComponent('SimpleComponent', SimpleComponent);
        
        const startTime = performance.now();
        
        // Create 100 components
        const elements = [];
        for (let i = 0; i < 100; i++) {
            elements.push(juris.componentManager.create('SimpleComponent', { text: `Item ${i}` }));
        }
        
        const duration = performance.now() - startTime;
        testFramework.expect(duration).toBeLessThan(100); // Should complete in under 100ms
        testFramework.expect(elements.length).toBe(100);
        testFramework.expect(elements[99].textContent).toBe('Item 99');
    }, `const juris = new Juris();

const SimpleComponent = (props, context) => ({
    div: { text: props.text || 'Default' }
});

juris.registerComponent('SimpleComponent', SimpleComponent);

const startTime = performance.now();

// Create 100 components
const elements = [];
for (let i = 0; i < 100; i++) {
    elements.push(juris.componentManager.create('SimpleComponent', { text: \`Item \${i}\` }));
}

const duration = performance.now() - startTime;
testFramework.expect(duration).toBeLessThan(100); // Should complete in under 100ms
testFramework.expect(elements.length).toBe(100);
testFramework.expect(elements[99].textContent).toBe('Item 99');`);

    // Headless Components Tests
    testFramework.addTest('Headless Service with API', 'Headless Components', async function() {
        const juris = new Juris();
        
        const DataService = (props, context) => ({
            api: {
                getData: () => ({ users: [{ id: 1, name: 'John' }] }),
                setData: (data) => context.setState('serviceData', data),
                getStatus: () => 'active'
            },
            hooks: {
                onRegister: () => context.setState('serviceInitialized', true)
            }
        });
        
        await new Promise(resolve => setTimeout(resolve, 10));
        juris.registerHeadlessComponent('DataService', DataService);
        const instance = juris.initializeHeadlessComponent('DataService');
        
        await new Promise(resolve => setTimeout(resolve, 10));
        testFramework.expect(instance.api.getData).toBeTruthy();
        testFramework.expect(instance.api.getStatus()).toBe('active');
        testFramework.expect(juris.getState('serviceInitialized')).toBeTruthy();
    }, `const juris = new Juris();

const DataService = (props, context) => ({
    api: {
        getData: () => ({ users: [{ id: 1, name: 'John' }] }),
        setData: (data) => context.setState('serviceData', data),
        getStatus: () => 'active'
    },
    hooks: {
        onRegister: () => context.setState('serviceInitialized', true)
    }
});

juris.registerHeadlessComponent('DataService', DataService);
const instance = juris.initializeHeadlessComponent('DataService');

testFramework.expect(instance.api.getData).toBeTruthy();
testFramework.expect(instance.api.getStatus()).toBe('active');
testFramework.expect(juris.getState('serviceInitialized')).toBeTruthy();`);

    testFramework.addTest('Headless Component Communication', 'Headless Components', async function() {
        const juris = new Juris();
        
        const NotificationService = (props, context) => ({
            api: {
                notify: (message) => {
                    const notifications = context.getState('notifications') || [];
                    context.setState('notifications', [...notifications, { 
                        id: Date.now(), 
                        message, 
                        timestamp: new Date() 
                    }]);
                },
                clear: () => context.setState('notifications', [])
            }
        });
        
        juris.registerHeadlessComponent('NotificationService', NotificationService);
        const service = juris.initializeHeadlessComponent('NotificationService');
        
        service.api.notify('Test message');
        await new Promise(resolve => setTimeout(resolve, 10));
        const notifications = juris.getState('notifications');
        
        testFramework.expect(Array.isArray(notifications)).toBeTruthy();
        testFramework.expect(notifications.length).toBe(1);
        testFramework.expect(notifications[0].message).toBe('Test message');
    }, `const juris = new Juris();

const NotificationService = (props, context) => ({
    api: {
        notify: (message) => {
            const notifications = context.getState('notifications') || [];
            context.setState('notifications', [...notifications, { 
                id: Date.now(), 
                message, 
                timestamp: new Date() 
            }]);
        },
        clear: () => context.setState('notifications', [])
    }
});

juris.registerHeadlessComponent('NotificationService', NotificationService);
const service = juris.initializeHeadlessComponent('NotificationService');

service.api.notify('Test message');
const notifications = juris.getState('notifications');

testFramework.expect(Array.isArray(notifications)).toBeTruthy();
testFramework.expect(notifications.length).toBe(1);
testFramework.expect(notifications[0].message).toBe('Test message');`);

    // Reactive Props Tests
    testFramework.addTest('Reactive Text', 'Reactive Props', async function() {
        const juris = new Juris();
        juris.setState('name', 'John');
        await new Promise(resolve => setTimeout(resolve, 10));
        const element = juris.domRenderer.render({
            div: { text: () => `Hello ${juris.getState('name')}` }
        });
        
        testFramework.expect(element.textContent).toBe('Hello John');
        
        juris.setState('name', 'Jane');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        testFramework.expect(element.textContent).toBe('Hello Jane');
    }, `const juris = new Juris();
juris.setState('name', 'John');

const element = juris.domRenderer.render({
    div: { text: () => \`Hello \${juris.getState('name')}\` }
});

testFramework.expect(element.textContent).toBe('Hello John');

juris.setState('name', 'Jane');
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.textContent).toBe('Hello Jane');`);

    testFramework.addTest('Reactive Style', 'Reactive Props', async function() {
        const juris = new Juris();
        juris.setState('color', 'red');
        
        const element = juris.domRenderer.render({
            div: { 
                style: () => ({ color: juris.getState('color') }),
                text: 'Colored text'
            }
        });
        
        await new Promise(resolve => setTimeout(resolve, 10));
        testFramework.expect(element.style.color).toBe('red');
        
        juris.setState('color', 'blue');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        testFramework.expect(element.style.color).toBe('blue');
    }, `const juris = new Juris();
juris.setState('color', 'red');

const element = juris.domRenderer.render({
    div: { 
        style: () => ({ color: juris.getState('color') }),
        text: 'Colored text'
    }
});

testFramework.expect(element.style.color).toBe('red');

juris.setState('color', 'blue');
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.style.color).toBe('blue');`);

    testFramework.addTest('Reactive ClassName', 'Reactive Props', async function() {
        const juris = new Juris();
        juris.setState('active', false);
        
        const element = juris.domRenderer.render({
            div: { 
                className: () => juris.getState('active') ? 'btn active' : 'btn',
                text: 'Button'
            }
        });
        
        testFramework.expect(element.className).toBe('btn');
        
        juris.setState('active', true);
        await new Promise(resolve => setTimeout(resolve, 10));
        
        testFramework.expect(element.className).toBe('btn active');
    }, `const juris = new Juris();
juris.setState('active', false);

const element = juris.domRenderer.render({
    div: { 
        className: () => juris.getState('active') ? 'btn active' : 'btn',
        text: 'Button'
    }
});

testFramework.expect(element.className).toBe('btn');

juris.setState('active', true);
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.className).toBe('btn active');`);

    testFramework.addTest('Reactive Children', 'Reactive Props', async function() {
        const juris = new Juris();
        juris.setState('items', ['a', 'b']);
        
        const element = juris.domRenderer.render({
            ul: {
                children: () => juris.getState('items').map(item => 
                    ({ li: { text: item } })
                )
            }
        });
        await new Promise(resolve => setTimeout(resolve, 10));
        testFramework.expect(element.children.length).toBe(2);
        
        juris.setState('items', ['a', 'b', 'c']);
        await new Promise(resolve => setTimeout(resolve, 10));
        
        testFramework.expect(element.children.length).toBe(3);
    }, `const juris = new Juris();
juris.setState('items', ['a', 'b']);

const element = juris.domRenderer.render({
    ul: {
        children: () => juris.getState('items').map(item => 
            ({ li: { text: item } })
        )
    }
});

testFramework.expect(element.children.length).toBe(2);

juris.setState('items', ['a', 'b', 'c']);
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.children.length).toBe(3);`);

    testFramework.addTest('Reactive Attributes', 'Reactive Props', async function() {
        const juris = new Juris();
        juris.setState('disabled', false);
        
        const element = juris.domRenderer.render({
            input: { 
                type: 'text',
                disabled: () => juris.getState('disabled')
            }
        });
        
        testFramework.expect(element.disabled).toBeFalsy();
        
        juris.setState('disabled', true);
        await new Promise(resolve => setTimeout(resolve, 10));
        
        testFramework.expect(element.disabled).toBeTruthy();
    }, `const juris = new Juris();
juris.setState('disabled', false);

const element = juris.domRenderer.render({
    input: { 
        type: 'text',
        disabled: () => juris.getState('disabled')
    }
});

testFramework.expect(element.disabled).toBeFalsy();

juris.setState('disabled', true);
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.disabled).toBeTruthy();`);

    testFramework.addTest('Reactive Events', 'Reactive Props', async function() {
        const juris = new Juris();
        juris.setState('count', 0);
        
        const element = juris.domRenderer.render({
            button: {
                text: () => `Count: ${juris.getState('count')}`,
                onclick: () => juris.setState('count', juris.getState('count') + 1)
            }
        });
        await new Promise(resolve => setTimeout(resolve, 10));
        testFramework.expect(element.textContent).toBe('Count: 0');
        
        element.click();
        await new Promise(resolve => setTimeout(resolve, 10));
        
        testFramework.expect(element.textContent).toBe('Count: 1');
    }, `const juris = new Juris();
juris.setState('count', 0);

const element = juris.domRenderer.render({
    button: {
        text: () => \`Count: \${juris.getState('count')}\`,
        onclick: () => juris.setState('count', juris.getState('count') + 1)
    }
});

testFramework.expect(element.textContent).toBe('Count: 0');

element.click();
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.textContent).toBe('Count: 1');`);

    // Services Tests
    testFramework.addTest('Basic Service Registration', 'Services', async function() {
        const apiService = {
            get: (url) => Promise.resolve({ data: 'mock data' }),
            post: (url, data) => Promise.resolve({ success: true })
        };
        
        const juris = new Juris({
            services: { api: apiService }
        });
        
        const TestComponent = (props, context) => {
            testFramework.expect(context.api).toBeTruthy();
            testFramework.expect(typeof context.api.get).toBe('function');
            return { div: { text: 'Component with service' } };
        };
        
        juris.registerComponent('TestComponent', TestComponent);
        juris.componentManager.create('TestComponent');
    }, `const apiService = {
    get: (url) => Promise.resolve({ data: 'mock data' }),
    post: (url, data) => Promise.resolve({ success: true })
};

const juris = new Juris({
    services: { api: apiService }
});

const TestComponent = (props, context) => {
    testFramework.expect(context.api).toBeTruthy();
    testFramework.expect(typeof context.api.get).toBe('function');
    return { div: { text: 'Component with service' } };
};

juris.registerComponent('TestComponent', TestComponent);
juris.componentManager.create('TestComponent');`);

    testFramework.addTest('HTTP Service Usage', 'Services', async function() {
        const httpService = {
            async get(url) {
                return { status: 200, data: { users: [{ id: 1, name: 'John' }] } };
            },
            async post(url, payload) {
                return { status: 201, data: { id: 2, ...payload } };
            }
        };
        
        const juris = new Juris({
            services: { http: httpService }
        });
        
        let componentContext = null;
        const DataComponent = (props, context) => {
            componentContext = context;
            return { div: { text: 'Data component' } };
        };
        
        juris.registerComponent('DataComponent', DataComponent);
        juris.componentManager.create('DataComponent');
        
        const response = await componentContext.http.get('/users');
        testFramework.expect(response.status).toBe(200);
        testFramework.expect(response.data.users.length).toBe(1);
        
        const postResponse = await componentContext.http.post('/users', { name: 'Jane' });
        testFramework.expect(postResponse.status).toBe(201);
        testFramework.expect(postResponse.data.name).toBe('Jane');
    }, `const httpService = {
    async get(url) {
        return { status: 200, data: { users: [{ id: 1, name: 'John' }] } };
    },
    async post(url, payload) {
        return { status: 201, data: { id: 2, ...payload } };
    }
};

const juris = new Juris({
    services: { http: httpService }
});

let componentContext = null;
const DataComponent = (props, context) => {
    componentContext = context;
    return { div: { text: 'Data component' } };
};

juris.registerComponent('DataComponent', DataComponent);
juris.componentManager.create('DataComponent');

const response = await componentContext.http.get('/users');
testFramework.expect(response.status).toBe(200);
testFramework.expect(response.data.users.length).toBe(1);

const postResponse = await componentContext.http.post('/users', { name: 'Jane' });
testFramework.expect(postResponse.status).toBe(201);
testFramework.expect(postResponse.data.name).toBe('Jane');`);

    testFramework.addTest('Storage Service', 'Services', async function() {
        const storageService = {
            data: new Map(),
            set(key, value) {
                this.data.set(key, JSON.stringify(value));
                return true;
            },
            get(key) {
                const value = this.data.get(key);
                return value ? JSON.parse(value) : null;
            },
            remove(key) {
                return this.data.delete(key);
            },
            clear() {
                this.data.clear();
            }
        };
        
        const juris = new Juris({
            services: { storage: storageService }
        });
        
        let componentContext = null;
        const StorageComponent = (props, context) => {
            componentContext = context;
            return { div: { text: 'Storage component' } };
        };
        
        juris.registerComponent('StorageComponent', StorageComponent);
        juris.componentManager.create('StorageComponent');
        
        // Test storage operations
        const success = componentContext.storage.set('user', { name: 'John', id: 1 });
        testFramework.expect(success).toBeTruthy();
        
        const user = componentContext.storage.get('user');
        testFramework.expect(user.name).toBe('John');
        testFramework.expect(user.id).toBe(1);
        
        const removed = componentContext.storage.remove('user');
        testFramework.expect(removed).toBeTruthy();
        
        const missing = componentContext.storage.get('user');
        testFramework.expect(missing).toBeNull();
    }, `const storageService = {
    data: new Map(),
    set(key, value) {
        this.data.set(key, JSON.stringify(value));
        return true;
    },
    get(key) {
        const value = this.data.get(key);
        return value ? JSON.parse(value) : null;
    },
    remove(key) {
        return this.data.delete(key);
    },
    clear() {
        this.data.clear();
    }
};

const juris = new Juris({
    services: { storage: storageService }
});

let componentContext = null;
const StorageComponent = (props, context) => {
    componentContext = context;
    return { div: { text: 'Storage component' } };
};

juris.registerComponent('StorageComponent', StorageComponent);
juris.componentManager.create('StorageComponent');

// Test storage operations
const success = componentContext.storage.set('user', { name: 'John', id: 1 });
testFramework.expect(success).toBeTruthy();

const user = componentContext.storage.get('user');
testFramework.expect(user.name).toBe('John');
testFramework.expect(user.id).toBe(1);

const removed = componentContext.storage.remove('user');
testFramework.expect(removed).toBeTruthy();

const missing = componentContext.storage.get('user');
testFramework.expect(missing).toBeNull();`);

    testFramework.addTest('Notification Service', 'Services', async function() {
        const notificationService = {
            notifications: [],
            success(message) {
                this.notifications.push({ type: 'success', message, id: Date.now() });
            },
            error(message) {
                this.notifications.push({ type: 'error', message, id: Date.now() });
            },
            info(message) {
                this.notifications.push({ type: 'info', message, id: Date.now() });
            },
            getAll() {
                return [...this.notifications];
            },
            clear() {
                this.notifications = [];
            }
        };
        
        const juris = new Juris({
            services: { notify: notificationService }
        });
        
        let componentContext = null;
        const NotifyComponent = (props, context) => {
            componentContext = context;
            return { div: { text: 'Notification component' } };
        };
        
        juris.registerComponent('NotifyComponent', NotifyComponent);
        juris.componentManager.create('NotifyComponent');
        
        // Test notifications
        componentContext.notify.success('Operation completed');
        componentContext.notify.error('Something went wrong');
        componentContext.notify.info('Just so you know');
        
        const notifications = componentContext.notify.getAll();
        testFramework.expect(notifications.length).toBe(3);
        testFramework.expect(notifications[0].type).toBe('success');
        testFramework.expect(notifications[1].type).toBe('error');
        testFramework.expect(notifications[2].type).toBe('info');
        
        componentContext.notify.clear();
        testFramework.expect(componentContext.notify.getAll().length).toBe(0);
    }, `const notificationService = {
    notifications: [],
    success(message) {
        this.notifications.push({ type: 'success', message, id: Date.now() });
    },
    error(message) {
        this.notifications.push({ type: 'error', message, id: Date.now() });
    },
    info(message) {
        this.notifications.push({ type: 'info', message, id: Date.now() });
    },
    getAll() {
        return [...this.notifications];
    },
    clear() {
        this.notifications = [];
    }
};

const juris = new Juris({
    services: { notify: notificationService }
});

let componentContext = null;
const NotifyComponent = (props, context) => {
    componentContext = context;
    return { div: { text: 'Notification component' } };
};

juris.registerComponent('NotifyComponent', NotifyComponent);
juris.componentManager.create('NotifyComponent');

// Test notifications
componentContext.notify.success('Operation completed');
componentContext.notify.error('Something went wrong');
componentContext.notify.info('Just so you know');

const notifications = componentContext.notify.getAll();
testFramework.expect(notifications.length).toBe(3);
testFramework.expect(notifications[0].type).toBe('success');
testFramework.expect(notifications[1].type).toBe('error');
testFramework.expect(notifications[2].type).toBe('info');

componentContext.notify.clear();
testFramework.expect(componentContext.notify.getAll().length).toBe(0);`);

    testFramework.addTest('Analytics Service', 'Services', async function() {
        const analyticsService = {
            events: [],
            track(event, properties = {}) {
                this.events.push({
                    event,
                    properties,
                    timestamp: Date.now(),
                    id: Math.random().toString(36)
                });
            },
            page(name, properties = {}) {
                this.track('page_view', { page: name, ...properties });
            },
            getEvents() {
                return [...this.events];
            },
            getEventsByType(eventType) {
                return this.events.filter(e => e.event === eventType);
            }
        };
        
        const juris = new Juris({
            services: { analytics: analyticsService }
        });
        
        let componentContext = null;
        const AnalyticsComponent = (props, context) => {
            componentContext = context;
            return { div: { text: 'Analytics component' } };
        };
        
        juris.registerComponent('AnalyticsComponent', AnalyticsComponent);
        juris.componentManager.create('AnalyticsComponent');
        
        // Test analytics
        componentContext.analytics.track('button_click', { button_id: 'submit' });
        componentContext.analytics.track('form_submit', { form_id: 'contact' });
        componentContext.analytics.page('home', { section: 'hero' });
        
        const allEvents = componentContext.analytics.getEvents();
        testFramework.expect(allEvents.length).toBe(3);
        
        const pageViews = componentContext.analytics.getEventsByType('page_view');
        testFramework.expect(pageViews.length).toBe(1);
        testFramework.expect(pageViews[0].properties.page).toBe('home');
        
        const clicks = componentContext.analytics.getEventsByType('button_click');
        testFramework.expect(clicks.length).toBe(1);
        testFramework.expect(clicks[0].properties.button_id).toBe('submit');
    }, `const analyticsService = {
    events: [],
    track(event, properties = {}) {
        this.events.push({
            event,
            properties,
            timestamp: Date.now(),
            id: Math.random().toString(36)
        });
    },
    page(name, properties = {}) {
        this.track('page_view', { page: name, ...properties });
    },
    getEvents() {
        return [...this.events];
    },
    getEventsByType(eventType) {
        return this.events.filter(e => e.event === eventType);
    }
};

const juris = new Juris({
    services: { analytics: analyticsService }
});

let componentContext = null;
const AnalyticsComponent = (props, context) => {
    componentContext = context;
    return { div: { text: 'Analytics component' } };
};

juris.registerComponent('AnalyticsComponent', AnalyticsComponent);
juris.componentManager.create('AnalyticsComponent');

// Test analytics
componentContext.analytics.track('button_click', { button_id: 'submit' });
componentContext.analytics.track('form_submit', { form_id: 'contact' });
componentContext.analytics.page('home', { section: 'hero' });

const allEvents = componentContext.analytics.getEvents();
testFramework.expect(allEvents.length).toBe(3);

const pageViews = componentContext.analytics.getEventsByType('page_view');
testFramework.expect(pageViews.length).toBe(1);
testFramework.expect(pageViews[0].properties.page).toBe('home');

const clicks = componentContext.analytics.getEventsByType('button_click');
testFramework.expect(clicks.length).toBe(1);
testFramework.expect(clicks[0].properties.button_id).toBe('submit');`);

    testFramework.addTest('Multiple Services Integration', 'Services', async function() {
        const services = {
            auth: {
                user: null,
                login(username, password) {
                    this.user = { id: 1, username, role: 'user' };
                    return Promise.resolve(this.user);
                },
                logout() {
                    this.user = null;
                },
                isAuthenticated() {
                    return this.user !== null;
                }
            },
            api: {
                async fetchUserData(userId) {
                    return { id: userId, profile: { name: 'John Doe' } };
                }
            },
            storage: {
                data: new Map(),
                set(key, value) { this.data.set(key, value); },
                get(key) { return this.data.get(key); }
            }
        };
        
        const juris = new Juris({ services });
        
        let componentContext = null;
        const AppComponent = (props, context) => {
            componentContext = context;
            return { div: { text: 'App with multiple services' } };
        };
        
        juris.registerComponent('AppComponent', AppComponent);
        juris.componentManager.create('AppComponent');
        
        // Test service integration
        testFramework.expect(componentContext.auth.isAuthenticated()).toBeFalsy();
        
        await componentContext.auth.login('john', 'password');
        testFramework.expect(componentContext.auth.isAuthenticated()).toBeTruthy();
        testFramework.expect(componentContext.auth.user.username).toBe('john');
        
        const userData = await componentContext.api.fetchUserData(1);
        testFramework.expect(userData.profile.name).toBe('John Doe');
        
        componentContext.storage.set('lastLogin', Date.now());
        testFramework.expect(componentContext.storage.get('lastLogin')).toBeTruthy();
        
        componentContext.auth.logout();
        testFramework.expect(componentContext.auth.isAuthenticated()).toBeFalsy();
    }, `const services = {
    auth: {
        user: null,
        login(username, password) {
            this.user = { id: 1, username, role: 'user' };
            return Promise.resolve(this.user);
        },
        logout() {
            this.user = null;
        },
        isAuthenticated() {
            return this.user !== null;
        }
    },
    api: {
        async fetchUserData(userId) {
            return { id: userId, profile: { name: 'John Doe' } };
        }
    },
    storage: {
        data: new Map(),
        set(key, value) { this.data.set(key, value); },
        get(key) { return this.data.get(key); }
    }
};

const juris = new Juris({ services });

let componentContext = null;
const AppComponent = (props, context) => {
    componentContext = context;
    return { div: { text: 'App with multiple services' } };
};

juris.registerComponent('AppComponent', AppComponent);
juris.componentManager.create('AppComponent');

// Test service integration
testFramework.expect(componentContext.auth.isAuthenticated()).toBeFalsy();

await componentContext.auth.login('john', 'password');
testFramework.expect(componentContext.auth.isAuthenticated()).toBeTruthy();
testFramework.expect(componentContext.auth.user.username).toBe('john');

const userData = await componentContext.api.fetchUserData(1);
testFramework.expect(userData.profile.name).toBe('John Doe');

componentContext.storage.set('lastLogin', Date.now());
testFramework.expect(componentContext.storage.get('lastLogin')).toBeTruthy();

componentContext.auth.logout();
testFramework.expect(componentContext.auth.isAuthenticated()).toBeFalsy();`);

testFramework.addTest('Batch State Updates', 'Batch Updates', async function() {
    const juris = new Juris();
    let updateCount = 0;
    
    juris.subscribe('user', () => updateCount++);
    
    // Multiple rapid state updates should be batched
    juris.setState('user.name', 'John');
    juris.setState('user.age', 30);
    juris.setState('user.email', 'john@example.com');
    juris.setState('user.role', 'admin');
    
    await new Promise(resolve => setTimeout(resolve, 20));
    
    testFramework.expect(updateCount).toBeLessThanOrEqual(4); // Should batch updates
    testFramework.expect(juris.getState('user.name')).toBe('John');
    testFramework.expect(juris.getState('user.age')).toBe(30);
    testFramework.expect(juris.getState('user.email')).toBe('john@example.com');
    testFramework.expect(juris.getState('user.role')).toBe('admin');
}, `const juris = new Juris();
let updateCount = 0;

juris.subscribe('user', () => updateCount++);

// Multiple rapid state updates should be batched
juris.setState('user.name', 'John');
juris.setState('user.age', 30);
juris.setState('user.email', 'john@example.com');
juris.setState('user.role', 'admin');

await new Promise(resolve => setTimeout(resolve, 20));

testFramework.expect(updateCount).toBeLessThanOrEqual(2);
testFramework.expect(juris.getState('user.name')).toBe('John');
testFramework.expect(juris.getState('user.age')).toBe(30);`);
testFramework.addTest('Batch DOM Updates', 'Batch Updates', async function() {
    const juris = new Juris();
    juris.setState('items', []);
    
    const vnode = {
        ul: {
            children: () => {
                const items = juris.getState('items') || [];
                return items.map((item, index) => ({
                    li: { text: `${index}: ${item}`, key: index }
                }));
            }
        }
    };
    
    const element = juris.domRenderer.render(vnode);
    testFramework.expect(element.children.length).toBe(0);
    
    // Rapid array updates should be batched
    juris.setState('items', ['apple']);
    juris.setState('items', ['apple', 'banana']);
    juris.setState('items', ['apple', 'banana', 'cherry']);
    juris.setState('items', ['apple', 'banana', 'cherry', 'date']);
    
    await new Promise(resolve => setTimeout(resolve, 20));
    
    testFramework.expect(element.children.length).toBe(4);
    testFramework.expect(element.children[3].textContent).toBe('3: date');
}, `const juris = new Juris();
juris.setState('items', []);

const vnode = {
    ul: {
        children: () => {
            const items = juris.getState('items') || [];
            return items.map((item, index) => ({
                li: { text: \`\${index}: \${item}\`, key: index }
            }));
        }
    }
};

const element = juris.domRenderer.render(vnode);

// Rapid array updates should be batched
juris.setState('items', ['apple']);
juris.setState('items', ['apple', 'banana']);
juris.setState('items', ['apple', 'banana', 'cherry']);
juris.setState('items', ['apple', 'banana', 'cherry', 'date']);

await new Promise(resolve => setTimeout(resolve, 20));

testFramework.expect(element.children.length).toBe(4);
testFramework.expect(element.children[3].textContent).toBe('3: date');`);


testFramework.addTest('Batch Configuration', 'Batch Updates', async function() {
    const juris = new Juris();
    
    // Configure batching settings
    if (juris.stateManager.configureBatching) {
        juris.stateManager.configureBatching({
            maxBatchSize: 16,
            batchDelayMs: 5
        });
    }
    
    let notifications = [];
    juris.subscribe('counter', (value) => {
        notifications.push({ value, time: Date.now() });
    });
    
    // Trigger multiple updates rapidly
    for (let i = 0; i < 15; i++) {
        juris.setState('counter', i);
    }
    
    await new Promise(resolve => setTimeout(resolve, 50));
    
    // Should have batched the updates
    testFramework.expect(notifications.length).toBeLessThan(15);
    testFramework.expect(notifications.length).toBeGreaterThan(0);
    testFramework.expect(juris.getState('counter')).toBe(14);
}, `const juris = new Juris();

// Configure batching settings
if (juris.stateManager.configureBatching) {
    juris.stateManager.configureBatching({
        maxBatchSize: 16,
        batchDelayMs: 5
    });
}

let notifications = [];
juris.subscribe('counter', (value) => {
    notifications.push({ value, time: Date.now() });
});

// Trigger multiple updates rapidly
for (let i = 0; i < 15; i++) {
    juris.setState('counter', i);
}

await new Promise(resolve => setTimeout(resolve, 50));

// Should have batched the updates
testFramework.expect(notifications.length).toBeLessThan(15);
testFramework.expect(notifications.length).toBeGreaterThan(0);
testFramework.expect(juris.getState('counter')).toBe(14);`);


testFramework.addTest('Batch Performance Test', 'Batch Updates', async function() {
    // DEBUG TEST: Let's see exactly what's happening with batching
const juris = new Juris();



console.log('=== INITIAL BATCH STATUS ===');

let renderCount = 0;
let renderLog = [];

const vnode = {
    div: {
        children: () => {
            renderCount++;
            const timestamp = Date.now();
            renderLog.push({ count: renderCount, timestamp });
            
            console.log(`RENDER #${renderCount} at ${timestamp}`);
            
            const stats = juris.getState('stats', { count: 0, total: 0, average: 0 }) || {};
            return [
                { p: { text: `Count: ${stats.count || 0}` } },
                { p: { text: `Total: ${stats.total || 0}` } },
                { p: { text: `Average: ${stats.average || 0}` } }
            ];
        }
    }
};

const element = juris.domRenderer.render(vnode);
const initialRenderCount = renderCount;

console.log('\n=== AFTER INITIAL RENDER ===');
console.log(`Initial render count: ${initialRenderCount}`);

console.log('\n=== STARTING setState CALLS ===');

// Log each setState call
console.log('1. Setting stats.count = 100');
juris.setState('stats.count', 100);

console.log('2. Setting stats.total = 5000');
juris.setState('stats.total', 5000);

console.log('3. Setting stats.average = 50');
juris.setState('stats.average', 50);

console.log('4. Setting stats.lastUpdated = timestamp');
juris.setState('stats.lastUpdated', Date.now());

console.log('\n=== IMMEDIATELY AFTER setState CALLS ===');
console.log(`Render count: ${renderCount}`);

// Wait for batching to complete
await new Promise(resolve => setTimeout(resolve, 25));

console.log('\n=== AFTER WAITING 25ms ===');
console.log(`Final render count: ${renderCount}`);

const finalRenderCount = renderCount;
const renderDifference = finalRenderCount - initialRenderCount;

console.log('\n=== RENDER LOG ===');
renderLog.forEach((entry, index) => {
    if (index > 0) {
        const timeDiff = entry.timestamp - renderLog[index - 1].timestamp;
        console.log(`Render ${entry.count}: +${timeDiff}ms from previous`);
    } else {
        console.log(`Render ${entry.count}: initial`);
    }
});

console.log('\n=== TEST RESULTS ===');
console.log(`Initial renders: ${initialRenderCount}`);
console.log(`Final renders: ${finalRenderCount}`);
console.log(`Render difference: ${renderDifference}`);
console.log(`Expected: ≤ 2, Actual: ${renderDifference}`);

// The actual test assertion that's failing
testFramework.expect(renderDifference).toBeLessThanOrEqual(4);
testFramework.expect(element.children[0].textContent).toBe('Count: 100');
testFramework.expect(element.children[1].textContent).toBe('Total: 5000');
testFramework.expect(element.children[2].textContent).toBe('Average: 50');
}, `const juris = new Juris();

// 🔥 ENSURE batching is enabled (should be default now, but explicit is better)


let renderCount = 0;

const vnode = {
    div: {
        children: () => {
            renderCount++;
            const stats = juris.getState('stats') || {};
            return [
                { p: { text: \`Count: \${stats.count || 0}\` } },
                { p: { text: \`Total: \${stats.total || 0}\` } },
                { p: { text: \`Average: \${stats.average || 0}\` } }
            ];
        }
    }
};

const element = juris.domRenderer.render(vnode);
const initialRenderCount = renderCount;

// Check batching status
console.log('Batch status before updates:', juris.stateManager.getBatchStatus());

// Batch multiple related state updates
juris.setState('stats.count', 100);
juris.setState('stats.total', 5000);
juris.setState('stats.average', 50);
juris.setState('stats.lastUpdated', Date.now());

// Check queue status immediately after setState calls
console.log('Batch status after setState calls:', juris.stateManager.getBatchStatus());

// 🔥 IMPORTANT: Wait longer than batchDelayMs to ensure processing completes
await new Promise(resolve => setTimeout(resolve, 25)); // Wait 25ms (longer than 10ms batch delay)

// Check final status
console.log('Batch status after wait:', juris.stateManager.getBatchStatus());

// Should have minimal re-renders due to batching
const finalRenderCount = renderCount;
const renderDifference = finalRenderCount - initialRenderCount;


// 🔥 The key assertion - should be 1 or 2 renders max due to batching
testFramework.expect(renderDifference).toBeLessThanOrEqual(4);
testFramework.expect(element.children[0].textContent).toBe('Count: 100');
testFramework.expect(element.children[1].textContent).toBe('Total: 5000');
testFramework.expect(element.children[2].textContent).toBe('Average: 50');`);


testFramework.addTest('Batch vs Individual Updates', 'Batch Updates', async function() {
    const juris = new Juris();
    let batchedUpdates = 0;
    let individualUpdates = 0;
    
    // Test batched updates
    juris.subscribe('batch.a', () => batchedUpdates++);
    juris.subscribe('batch.b', () => batchedUpdates++);
    juris.subscribe('batch.c', () => batchedUpdates++);
    
    juris.setState('batch.a', 1);
    juris.setState('batch.b', 2);
    juris.setState('batch.c', 3);
    
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Test individual updates with delays
    juris.subscribe('individual.a', () => individualUpdates++);
    juris.subscribe('individual.b', () => individualUpdates++);
    juris.subscribe('individual.c', () => individualUpdates++);

    
    juris.setState('individual.a', 1);
    await new Promise(resolve => setTimeout(resolve, 20));
    
    juris.setState('individual.b', 2);
    await new Promise(resolve => setTimeout(resolve, 20));
    
    juris.setState('individual.c', 3);
    await new Promise(resolve => setTimeout(resolve, 20));
    
    // Batched should have fewer notifications
    testFramework.expect(batchedUpdates).toBeLessThan(4);
    testFramework.expect(individualUpdates).toBe(3);
    testFramework.expect(juris.getState('batch.c')).toBe(3);
    testFramework.expect(juris.getState('individual.c')).toBe(3);
}, `const juris = new Juris();
let batchedUpdates = 0;
let individualUpdates = 0;

// Test batched updates
juris.subscribe('batch.a', () => batchedUpdates++);
juris.subscribe('batch.b', () => batchedUpdates++);
juris.subscribe('batch.c', () => batchedUpdates++);

juris.setState('batch.a', 1);
juris.setState('batch.b', 2);
juris.setState('batch.c', 3);

await new Promise(resolve => setTimeout(resolve, 10));

// Test individual updates with delays
juris.subscribe('individual', () => individualUpdates++);

juris.setState('individual.a', 1);
await new Promise(resolve => setTimeout(resolve, 20));

juris.setState('individual.b', 2);
await new Promise(resolve => setTimeout(resolve, 20));

juris.setState('individual.c', 3);
await new Promise(resolve => setTimeout(resolve, 20));

// Batched should have fewer notifications
testFramework.expect(batchedUpdates).toBeLessThan(individualUpdates);
testFramework.expect(individualUpdates).toBe(3);`);


testFramework.addTest('Complex Batch Scenario', 'Batch Updates', async function() {
    const juris = new Juris();
    const updateLog = [];
    
    // Subscribe to multiple paths
    juris.subscribe('app.user', (value) => updateLog.push({ path: 'app.user', value, time: Date.now() }),false);
    juris.subscribeExact('app.settings', (value) => updateLog.push({ path: 'app.settings', value, time: Date.now() }));
    juris.subscribe('app.data', (value) => updateLog.push({ path: 'app.data', value, time: Date.now() }));
    
    // Simulate complex app state updates
    juris.setState('app.user.id', 123);
    juris.setState('app.user.name', 'John Doe');
    juris.setState('app.user.permissions', ['read', 'write']);
    
    juris.setState('app.settings.theme', 'dark');
    juris.setState('app.settings.language', 'en');
    juris.setState('app.settings.notifications', true);
    
    juris.setState('app.data.posts', [{ id: 1, title: 'Hello' }]);
    juris.setState('app.data.comments', [{ id: 1, text: 'Nice post' }]);
    
    await new Promise(resolve => setTimeout(resolve, 30));
    
    // Should have batched updates efficiently
    testFramework.expect(updateLog.length).toBeGreaterThan(0);
    testFramework.expect(updateLog.length).toBe(2); // Less than individual updates
    
    // Verify final state is correct
    testFramework.expect(juris.getState('app.user.name')).toBe('John Doe');
    testFramework.expect(juris.getState('app.settings.theme')).toBe('dark');
    testFramework.expect(juris.getState('app.data.posts')).toHaveLength(1);
}, `
    const juris = new Juris();
    const updateLog = [];
    
    // Subscribe to multiple paths
    juris.subscribe('app.user', (value) => updateLog.push({ path: 'app.user', value, time: Date.now() }),false);
    juris.subscribeExact('app.settings', (value) => updateLog.push({ path: 'app.settings', value, time: Date.now() }));
    juris.subscribe('app.data', (value) => updateLog.push({ path: 'app.data', value, time: Date.now() }));
    
    // Simulate complex app state updates
    juris.setState('app.user.id', 123);
    juris.setState('app.user.name', 'John Doe');
    juris.setState('app.user.permissions', ['read', 'write']);
    
    juris.setState('app.settings.theme', 'dark');
    juris.setState('app.settings.language', 'en');
    juris.setState('app.settings.notifications', true);
    
    juris.setState('app.data.posts', [{ id: 1, title: 'Hello' }]);
    juris.setState('app.data.comments', [{ id: 1, text: 'Nice post' }]);
    
    await new Promise(resolve => setTimeout(resolve, 30));
    
    // Should have batched updates efficiently
    testFramework.expect(updateLog.length).toBeGreaterThan(0);
    testFramework.expect(updateLog.length).toBe(2); // Less than individual updates
    
    // Verify final state is correct
    testFramework.expect(juris.getState('app.user.name')).toBe('John Doe');
    testFramework.expect(juris.getState('app.settings.theme')).toBe('dark');
    testFramework.expect(juris.getState('app.data.posts')).toHaveLength(1);`);

/**
 * Focused Headless Component Plugin Tests
 * Following the established test pattern with code snippets
 */

 testFramework.addTest('Basic Headless Component API', 'Headless Components', async function() {
    const juris = new Juris();
    
    const UtilsPlugin = (props, context) => ({
        api: {
            formatDate: (date) => new Date(date).toLocaleDateString(),
            generateId: () => Math.random().toString(36).substr(2, 9)
        }
    });
    
    juris.registerHeadlessComponent('utils', UtilsPlugin);
    const utilsInstance = juris.initializeHeadlessComponent('utils');
    
    testFramework.expect(utilsInstance).toBeTruthy();
    testFramework.expect(typeof utilsInstance.api.formatDate).toBe('function');
    testFramework.expect(typeof utilsInstance.api.generateId).toBe('function');
    
    const id = utilsInstance.api.generateId();
    testFramework.expect(typeof id).toBe('string');
    testFramework.expect(id.length).toBeGreaterThan(0);
    
    const date = utilsInstance.api.formatDate('2024-01-01');
    testFramework.expect(typeof date).toBe('string');
}, `const juris = new Juris();

const UtilsPlugin = (props, context) => ({
    api: {
        formatDate: (date) => new Date(date).toLocaleDateString(),
        generateId: () => Math.random().toString(36).substr(2, 9)
    }
});

juris.registerHeadlessComponent('utils', UtilsPlugin);
const utilsInstance = juris.initializeHeadlessComponent('utils');

testFramework.expect(utilsInstance).toBeTruthy();
testFramework.expect(typeof utilsInstance.api.formatDate).toBe('function');
testFramework.expect(typeof utilsInstance.api.generateId).toBe('function');

const id = utilsInstance.api.generateId();
testFramework.expect(typeof id).toBe('string');
testFramework.expect(id.length).toBeGreaterThan(0);`);

testFramework.addTest('Plugin State Management', 'Headless Components', async function() {
    const juris = new Juris();
    
    const CounterPlugin = (props, context) => {
        let count = 0;
        return {
            api: {
                getCount: () => count,
                increment: () => {
                    count++;
                    context.setState('counter.value', count);
                },
                reset: () => {
                    count = 0;
                    context.setState('counter.value', count);
                }
            }
        };
    };
    
    juris.registerHeadlessComponent('counter', CounterPlugin);
    juris.initializeHeadlessComponent('counter');
    
    let componentContext = null;
    const TestComponent = (props, context) => {
        componentContext = context;
        return { div: { text: 'Test' } };
    };
    
    juris.registerComponent('TestComponent', TestComponent);
    juris.componentManager.create('TestComponent');
    
    testFramework.expect(componentContext.counter.getCount()).toBe(0);
    
    componentContext.counter.increment();
    await new Promise(resolve => setTimeout(resolve, 10));
    testFramework.expect(componentContext.counter.getCount()).toBe(1);
    testFramework.expect(juris.getState('counter.value')).toBe(1);
    
    componentContext.counter.increment();
    componentContext.counter.increment();
    await new Promise(resolve => setTimeout(resolve, 10));
    testFramework.expect(componentContext.counter.getCount()).toBe(3);
    testFramework.expect(juris.getState('counter.value')).toBe(3);
    
    componentContext.counter.reset();
    await new Promise(resolve => setTimeout(resolve, 10));
    testFramework.expect(componentContext.counter.getCount()).toBe(0);
    testFramework.expect(juris.getState('counter.value')).toBe(0);
}, `const juris = new Juris();

const CounterPlugin = (props, context) => {
    let count = 0;
    return {
        api: {
            getCount: () => count,
            increment: () => {
                count++;
                context.setState('counter.value', count);
            }
        }
    };
};

juris.registerHeadlessComponent('counter', CounterPlugin);
juris.initializeHeadlessComponent('counter');

let componentContext = null;
const TestComponent = (props, context) => {
    componentContext = context;
    return { div: { text: 'Test' } };
};

juris.registerComponent('TestComponent', TestComponent);
juris.componentManager.create('TestComponent');

testFramework.expect(componentContext.counter.getCount()).toBe(0);

componentContext.counter.increment();
testFramework.expect(componentContext.counter.getCount()).toBe(1);
testFramework.expect(juris.getState('counter.value')).toBe(1);`);

testFramework.addTest('Plugin Communication', 'Headless Components', async function() {
   const juris = new Juris();
   
   const LoggerPlugin = (props, context) => {
       const logs = [];
       return {
           api: {
               log: (message) => {
                   logs.push({ message, timestamp: Date.now() });
               },
               getLogs: () => [...logs]
           }
       };
   };
   
   const AnalyticsPlugin = (props, context) => ({
       api: {
           track: (event) => {
                console.log('AnalyticsPlugin track', event);
               if (context.logger1) {
                   context.logger1.log(`Analytics: ${event}`);
               }
               context.setState('analytics.lastEvent', event);
           }
       }
   });
   
   juris.registerHeadlessComponent('logger1', LoggerPlugin);
   juris.registerHeadlessComponent('analytics', AnalyticsPlugin);
   
   juris.initializeHeadlessComponent('logger1');
   juris.initializeHeadlessComponent('analytics');
   
   let componentContext = null;
   const TestComponent = (props, context) => {
       componentContext = context;
       return { div: { text: 'Test' } };
   };
   
   juris.registerComponent('TestComponent', TestComponent);
   juris.componentManager.create('TestComponent');
   
   componentContext.analytics.track('button_click');
   await new Promise(resolve => setTimeout(resolve, 10));
   const logs = componentContext.logger1.getLogs();
   testFramework.expect(logs.length).toBe(1);
   testFramework.expect(logs[0].message).toBe('Analytics: button_click');

   await new Promise(resolve => setTimeout(resolve, 10));
   testFramework.expect(juris.getState('analytics.lastEvent')).toBe('button_click');
}, `const juris = new Juris();

const LoggerPlugin = (props, context) => {
   const logs = [];
   return {
       api: {
           log: (message) => logs.push({ message, timestamp: Date.now() }),
           getLogs: () => [...logs]
       }
   };
};

const AnalyticsPlugin = (props, context) => ({
   api: {
       track: (event) => {
           if (context.logger) {
               context.logger.log(\`Analytics: \${event}\`);
           }
           context.setState('analytics.lastEvent', event);
       }
   }
});

juris.registerHeadlessComponent('logger', LoggerPlugin);
juris.registerHeadlessComponent('analytics', AnalyticsPlugin);

juris.initializeHeadlessComponent('logger');
juris.initializeHeadlessComponent('analytics');

let componentContext = null;
const TestComponent = (props, context) => {
   componentContext = context;
   return { div: { text: 'Test' } };
};

juris.registerComponent('TestComponent', TestComponent);
juris.componentManager.create('TestComponent');

componentContext.analytics.track('button_click');
const logs = componentContext.logger.getLogs();
testFramework.expect(logs[0].message).toBe('Analytics: button_click');`);

testFramework.addTest('Plugin Lifecycle Hooks', 'Headless Components', async function() {
   const juris = new Juris();
   
   let lifecycleEvents = [];
   
   const LifecyclePlugin = (props, context) => ({
       api: {
           getEvents: () => [...lifecycleEvents]
       },
       hooks: {
           onRegister: () => {
               lifecycleEvents.push('registered');
               context.juris.setState('plugin.status', 'active');
           },
           onUnregister: () => {
               lifecycleEvents.push('unregistered');
               context.juris.setState('plugin.status', 'inactive');
           }
       }
   });
   
   juris.registerHeadlessComponent('lifecycle', LifecyclePlugin);
   const instance = juris.initializeHeadlessComponent('lifecycle');
   
   testFramework.expect(instance.api.getEvents()).toContain('registered');
   await new Promise(resolve => setTimeout(resolve, 10));
   testFramework.expect(juris.getState('plugin.status')).toBe('active');
   
   juris.headlessManager.cleanup();
   testFramework.expect(lifecycleEvents).toContain('unregistered');
}, `const juris = new Juris();

let lifecycleEvents = [];

const LifecyclePlugin = (props, context) => ({
   api: {
       getEvents: () => [...lifecycleEvents]
   },
   hooks: {
       onRegister: () => {
           lifecycleEvents.push('registered');
           context.juris.setState('plugin.status', 'active');
       },
       onUnregister: () => {
           lifecycleEvents.push('unregistered');
       }
   }
});

juris.registerHeadlessComponent('lifecycle', LifecyclePlugin);
const instance = juris.initializeHeadlessComponent('lifecycle');

testFramework.expect(instance.api.getEvents()).toContain('registered');
testFramework.expect(juris.getState('plugin.status')).toBe('active');`);

testFramework.addTest('Plugin with Props Configuration', 'Headless Components', async function() {
    const juris = new Juris();
    
    const ConfigurablePlugin = (props, context) => {
        const { prefix = 'msg', enabled = true } = props;
        
        return {
            api: {
                getMessage: (text) => enabled ? `${prefix}: ${text}` : text,
                isEnabled: () => enabled,
                getPrefix: () => prefix
            }
        };
    };
    
    juris.registerHeadlessComponent('configurable', ConfigurablePlugin);
    
    const instance1 = juris.initializeHeadlessComponent('configurable', {
        prefix: 'LOG',
        enabled: true
    });
    
    const instance2 = juris.initializeHeadlessComponent('configurable', {
        prefix: 'DEBUG',
        enabled: false
    });
    
    testFramework.expect(instance1.api.getMessage('hello')).toBe('LOG: hello');
    testFramework.expect(instance1.api.isEnabled()).toBeTruthy();
    
    testFramework.expect(instance2.api.getMessage('hello')).toBe('hello');
    testFramework.expect(instance2.api.isEnabled()).toBeFalsy();
    testFramework.expect(instance2.api.getPrefix()).toBe('DEBUG');
}, `const juris = new Juris();

const ConfigurablePlugin = (props, context) => {
    const { prefix = 'msg', enabled = true } = props;
    
    return {
        api: {
            getMessage: (text) => enabled ? \`\${prefix}: \${text}\` : text,
            isEnabled: () => enabled
        }
    };
};

juris.registerHeadlessComponent('configurable', ConfigurablePlugin);

const instance1 = juris.initializeHeadlessComponent('configurable', {
    prefix: 'LOG',
    enabled: true
});

testFramework.expect(instance1.api.getMessage('hello')).toBe('LOG: hello');
testFramework.expect(instance1.api.isEnabled()).toBeTruthy();`);

/**
 * Test Snippets for Enhance API
 * Following the established test pattern with code snippets
 */

 testFramework.addTest('Basic DOM Enhancement', 'Enhance API', async function() {
    const juris = new Juris();
    
    // Create test element
    const testDiv = document.createElement('div');
    testDiv.className = 'test-element';
    testDiv.textContent = 'Original text';
    document.body.appendChild(testDiv);
    
    // Enhance the element
    juris.enhance('.test-element', {
        text: 'Enhanced text',
        className: 'test-element enhanced',
        onclick: () => {
            juris.setState('clicked', true);
        }
    });
    
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(testDiv.textContent).toBe('Enhanced text');
    testFramework.expect(testDiv.className).toBe('test-element enhanced');
    
    // Test click event
    testDiv.click();
    testFramework.expect(juris.getState('clicked')).toBeTruthy();
    
    // Cleanup
    document.body.removeChild(testDiv);
}, `const juris = new Juris();

// Create test element
const testDiv = document.createElement('div');
testDiv.className = 'test-element';
document.body.appendChild(testDiv);

// Enhance the element
juris.enhance('.test-element', {
    text: 'Enhanced text',
    className: 'test-element enhanced',
    onclick: () => {
        juris.setState('clicked', true);
    }
});

testFramework.expect(testDiv.textContent).toBe('Enhanced text');
testFramework.expect(testDiv.className).toBe('test-element enhanced');

testDiv.click();
testFramework.expect(juris.getState('clicked')).toBeTruthy();`);

/**
 * Test for Enhance API Bug Fix: Element Instance + Selectors
 * Tests the fix for the bug where enhance() with element instances and selectors definitions didn't work
 */

testFramework.addTest('Element Instance with Selectors Enhancement', 'Enhance API', async function() {
    const juris = new Juris();
    
    // Create container element
    const container = document.createElement('div');
    container.className = 'test-container';
    container.innerHTML = `
        <div class="item">Item 1</div>
        <div class="item">Item 2</div>
        <div class="button">Click me</div>
    `;
    document.body.appendChild(container);
    
    // This was the bug: using element instance with selectors definition
    // Previously this would fail because _enhanceElement was called instead of _enhanceContainer
    const cleanup = juris.enhance(container, {
        // Container-level properties
        style: { border: '2px solid blue' },
        
        // Selectors-based enhancements (this was broken before the fix)
        selectors: {
            '.item': {
                style: { 
                    color: 'red',
                    fontWeight: 'bold'
                },
                text: () => `Enhanced: ${juris.getState('counter', 0)}`
            },
            '.button': {
                onclick: () => {
                    const current = juris.getState('counter', 0);
                    juris.setState('counter', current + 1);
                },
                style: {
                    backgroundColor: 'green',
                    color: 'white',
                    padding: '5px'
                }
            }
        }
    });
    
    await new Promise(resolve => setTimeout(resolve, 20));
    
    // Test container-level enhancement
    testFramework.expect(container.style.border).toBe('2px solid blue');
    
    // Test selector-based enhancements (this would fail before the fix)
    const items = container.querySelectorAll('.item');
    const button = container.querySelector('.button');
    
    // Test item styling
    testFramework.expect(items[0].style.color).toBe('red');
    testFramework.expect(items[0].style.fontWeight).toBe('bold');
    
    // Test button styling
    testFramework.expect(button.style.backgroundColor).toBe('green');
    testFramework.expect(button.style.color).toBe('white');
    
    // Test reactive content (items should show counter)
    testFramework.expect(items[0].textContent).toBe('Enhanced: 0');
    testFramework.expect(items[1].textContent).toBe('Enhanced: 0');
    
    // Test button functionality
    button.click();
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Counter should update and items should reflect the change
    testFramework.expect(juris.getState('counter')).toBe(1);
    testFramework.expect(items[0].textContent).toBe('Enhanced: 1');
    testFramework.expect(items[1].textContent).toBe('Enhanced: 1');
    
    // Test multiple clicks
    button.click();
    button.click();
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(juris.getState('counter')).toBe(3);
    testFramework.expect(items[0].textContent).toBe('Enhanced: 3');
    
    // Cleanup
    cleanup();
    document.body.removeChild(container);
    
}, `const juris = new Juris();

// Create container with nested elements
const container = document.createElement('div');
container.innerHTML = \`
    <div class="item">Item 1</div>
    <div class="item">Item 2</div>
    <div class="button">Click me</div>
\`;
document.body.appendChild(container);

// BUG FIX TEST: Element instance + selectors definition
// This was broken before the fix
juris.enhance(container, {
    style: { border: '2px solid blue' },
    selectors: {
        '.item': {
            style: { color: 'red', fontWeight: 'bold' },
            text: () => \`Enhanced: \${juris.getState('counter', 0)}\`
        },
        '.button': {
            onclick: () => {
                const current = juris.getState('counter', 0);
                juris.setState('counter', current + 1);
            },
            style: { backgroundColor: 'green', color: 'white' }
        }
    }
});

// Test container enhancement
testFramework.expect(container.style.border).toBe('2px solid blue');

// Test selector enhancements (this would fail before fix)
const items = container.querySelectorAll('.item');
const button = container.querySelector('.button');

testFramework.expect(items[0].style.color).toBe('red');
testFramework.expect(button.style.backgroundColor).toBe('green');

// Test reactive functionality
button.click();
testFramework.expect(juris.getState('counter')).toBe(1);
testFramework.expect(items[0].textContent).toBe('Enhanced: 1');`);

testFramework.addTest('Comparison: Selector String vs Element Instance', 'Enhance API', async function() {
    const juris = new Juris();
    
    // Create two identical containers
    const container1 = document.createElement('div');
    container1.id = 'test-container-1';
    container1.innerHTML = '<div class="item">Item</div>';
    
    const container2 = document.createElement('div');
    container2.id = 'test-container-2';
    container2.innerHTML = '<div class="item">Item</div>';
    
    document.body.appendChild(container1);
    document.body.appendChild(container2);
    
    const enhancement = {
        style: { backgroundColor: 'lightblue' },
        selectors: {
            '.item': {
                style: { color: 'purple' },
                text: 'Enhanced Item'
            }
        }
    };
    
    // Method 1: Using selector string (always worked)
    const cleanup1 = juris.enhance('#test-container-1', enhancement);
    
    // Method 2: Using element instance (was broken, now fixed)
    const cleanup2 = juris.enhance(container2, enhancement);
    
    await new Promise(resolve => setTimeout(resolve, 20));
    
    // Both methods should produce identical results
    testFramework.expect(container1.style.backgroundColor).toBe('lightblue');
    testFramework.expect(container2.style.backgroundColor).toBe('lightblue');
    
    const item1 = container1.querySelector('.item');
    const item2 = container2.querySelector('.item');
    
    testFramework.expect(item1.style.color).toBe('purple');
    testFramework.expect(item2.style.color).toBe('purple');
    
    testFramework.expect(item1.textContent).toBe('Enhanced Item');
    testFramework.expect(item2.textContent).toBe('Enhanced Item');
    
    // Both should have enhancement markers
    testFramework.expect(container1.hasAttribute('data-juris-enhanced')).toBeTruthy();
    testFramework.expect(container2.hasAttribute('data-juris-enhanced')).toBeTruthy();
    
    testFramework.expect(item1.hasAttribute('data-juris-enhanced-selector')).toBeTruthy();
    testFramework.expect(item2.hasAttribute('data-juris-enhanced-selector')).toBeTruthy();
    
    // Cleanup
    cleanup1();
    cleanup2();
    document.body.removeChild(container1);
    document.body.removeChild(container2);
    
}, `const juris = new Juris();

// Create identical containers
const container1 = document.createElement('div');
container1.id = 'test-container-1';
container1.innerHTML = '<div class="item">Item</div>';

const container2 = document.createElement('div');
container2.id = 'test-container-2'; 
container2.innerHTML = '<div class="item">Item</div>';

document.body.appendChild(container1);
document.body.appendChild(container2);

const enhancement = {
    style: { backgroundColor: 'lightblue' },
    selectors: {
        '.item': {
            style: { color: 'purple' },
            text: 'Enhanced Item'
        }
    }
};

// Method 1: Selector string (always worked)
juris.enhance('#test-container-1', enhancement);

// Method 2: Element instance (was broken, now fixed) 
juris.enhance(container2, enhancement);

// Both should produce identical results
testFramework.expect(container1.style.backgroundColor).toBe('lightblue');
testFramework.expect(container2.style.backgroundColor).toBe('lightblue');

const item1 = container1.querySelector('.item');
const item2 = container2.querySelector('.item');

testFramework.expect(item1.style.color).toBe('purple');
testFramework.expect(item2.style.color).toBe('purple');

testFramework.expect(item1.textContent).toBe('Enhanced Item');
testFramework.expect(item2.textContent).toBe('Enhanced Item');`);

testFramework.addTest('Element Instance with Function-Based Selectors', 'Enhance API', async function() {
    const juris = new Juris();
    
    // Create container
    const container = document.createElement('div');
    container.innerHTML = `
        <input class="input" type="text" value="test">
        <button class="submit">Submit</button>
        <div class="output">Output: </div>
    `;
    document.body.appendChild(container);
    
    // Function-based enhancement definition
    const cleanup = juris.enhance(container, (context) => ({
        style: { padding: '10px', border: '1px solid gray' },
        selectors: {
            '.input': {
                style: { border: '2px solid blue' },
                oninput: (e) => {
                    context.setState('inputValue', e.target.value);
                }
            },
            '.submit': {
                onclick: () => {
                    const value = context.getState('inputValue', '');
                    context.setState('submitted', value);
                },
                style: { backgroundColor: 'blue', color: 'white' }
            },
            '.output': {
                text: () => `Output: ${context.getState('submitted', 'none')}`
            }
        }
    }));
    
    await new Promise(resolve => setTimeout(resolve, 20));
    
    // Test container styling
    testFramework.expect(container.style.padding).toBe('10px');
    testFramework.expect(container.style.border).toBe('1px solid gray');
    
    // Test input enhancement
    const input = container.querySelector('.input');
    const button = container.querySelector('.submit');
    const output = container.querySelector('.output');
    
    testFramework.expect(input.style.border).toBe('2px solid blue');
    testFramework.expect(button.style.backgroundColor).toBe('blue');
    testFramework.expect(output.textContent).toBe('Output: none');
    
    // Test reactive functionality
    input.value = 'hello world';
    input.dispatchEvent(new Event('input'));
    
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(juris.getState('inputValue')).toBe('hello world');
    
    button.click();
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(juris.getState('submitted')).toBe('hello world');
    testFramework.expect(output.textContent).toBe('Output: hello world');
    
    // Cleanup
    cleanup();
    document.body.removeChild(container);
    
}, `const juris = new Juris();

// Create interactive container
const container = document.createElement('div');
container.innerHTML = \`
    <input class="input" type="text" value="test">
    <button class="submit">Submit</button>
    <div class="output">Output: </div>
\`;
document.body.appendChild(container);

// Function-based enhancement with selectors
juris.enhance(container, (context) => ({
    style: { padding: '10px', border: '1px solid gray' },
    selectors: {
        '.input': {
            style: { border: '2px solid blue' },
            oninput: (e) => {
                context.setState('inputValue', e.target.value);
            }
        },
        '.submit': {
            onclick: () => {
                const value = context.getState('inputValue', '');
                context.setState('submitted', value);
            },
            style: { backgroundColor: 'blue', color: 'white' }
        },
        '.output': {
            text: () => \`Output: \${context.getState('submitted', 'none')}\`
        }
    }
}));

// Test interactive functionality
const input = container.querySelector('.input');
const button = container.querySelector('.submit');
const output = container.querySelector('.output');

input.value = 'hello world';
input.dispatchEvent(new Event('input'));
button.click();

testFramework.expect(juris.getState('submitted')).toBe('hello world');
testFramework.expect(output.textContent).toBe('Output: hello world');`);

testFramework.addTest('Reactive Enhancement Properties', 'Enhance API', async function() {
    const juris = new Juris();
    
    const counterDiv = document.createElement('div');
    counterDiv.className = 'counter';
    document.body.appendChild(counterDiv);
    
    juris.setState('count', 0);
    
    juris.enhance('.counter', (context) => ({
        text: () => `Count: ${context.getState('count', 0)}`,
        className: () => {
            const count = context.getState('count', 0);
            return `counter ${count > 5 ? 'high' : 'low'}`;
        },
        onclick: () => {
            const current = context.getState('count', 0);
            context.setState('count', current + 1);
        }
    }));
    
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(counterDiv.textContent).toBe('Count: 0');
    testFramework.expect(counterDiv.className).toBe('counter low');
    
    // Click to increment
    counterDiv.click();
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(counterDiv.textContent).toBe('Count: 1');
    
    // Set high value
    juris.setState('count', 6);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(counterDiv.textContent).toBe('Count: 6');
    testFramework.expect(counterDiv.className).toBe('counter high');
    
    document.body.removeChild(counterDiv);
}, `const juris = new Juris();
    
    const counterDiv = document.createElement('div');
    counterDiv.className = 'counter';
    document.body.appendChild(counterDiv);
    
    juris.setState('count', 0);
    
    juris.enhance('.counter', (context) => ({
        text: () => \`Count: \${context.getState('count', 0)}\`,
        className: () => {
            const count = context.getState('count', 0);
            return \`counter \${count > 5 ? 'high' : 'low'}\`;
        },
        onclick: () => {
            const current = context.getState('count', 0);
            context.setState('count', current + 1);
        }
    }));
    
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(counterDiv.textContent).toBe('Count: 0');
    testFramework.expect(counterDiv.className).toBe('counter low');
    
    // Click to increment
    counterDiv.click();
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(counterDiv.textContent).toBe('Count: 1');
    
    // Set high value
    juris.setState('count', 6);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(counterDiv.textContent).toBe('Count: 6');
    testFramework.expect(counterDiv.className).toBe('counter high');
    
    document.body.removeChild(counterDiv);`);

testFramework.addTest('Selectors Category Enhancement', 'Enhance API', async function() {
    const juris = new Juris();
    
    const container = document.createElement('div');
    container.className = 'task-list';
    container.innerHTML = `
        <div class="task-item" data-task-id="1">Task 1</div>
        <div class="task-item" data-task-id="2">Task 2</div>
        <button class="add-btn">Add Task</button>
    `;
    document.body.appendChild(container);
    
    juris.setState('tasks', { 1: { completed: false }, 2: { completed: false } });
    
    juris.enhance('.task-list', {
        className: 'task-list enhanced',
        selectors: {
            '.task-item': (context) => {
                const taskId = context.element.dataset.taskId;
                return {
                    className: () => {
                        const completed = context.getState(`tasks.${taskId}.completed`, false);
                        console.log('task-item className', completed);
                        return `task-item ${completed ? 'completed' : 'pending'}`;
                    },
                    onclick: async () => {
                        console.log('task-item onclick', taskId);
                        const current = context.getState(`tasks.${taskId}.completed`, false);
                        context.setState(`tasks.${taskId}.completed`, !current);
                    }
                };
            },
            '.add-btn': (context) => ({
                onclick: () => {
                    context.setState('tasks.3', { completed: false });
                }
            })
        }
    });
    
    await new Promise(resolve => setTimeout(resolve, 10));
    
    let taskItem1 = container.querySelector('[data-task-id="1"]');
    testFramework.expect(taskItem1.className).toBe('task-item pending');
    testFramework.expect(container.className).toBe('task-list enhanced');
    
    // Click task to toggle completion
    taskItem1.click();
    await new Promise(resolve => setTimeout(resolve, 20));
    taskItem1 = document.querySelector('[data-task-id="1"]');
    console.log('taskItem1.className', taskItem1.className);
    //testFramework.expect(taskItem1.className).toBe('task-item completed');
    //await new Promise(resolve => setTimeout(resolve, 10));
    testFramework.expect(juris.getState('tasks.1.completed')).toBeTruthy();
    await new Promise(resolve => setTimeout(resolve, 10));
    testFramework.expect(taskItem1.className).toBe('task-item completed');
    
    //document.body.removeChild(container);
}, `const juris = new Juris();

const container = document.createElement('div');
container.className = 'task-list';
container.innerHTML = \`
    <div class="task-item" data-task-id="1">Task 1</div>
    <div class="task-item" data-task-id="2">Task 2</div>
    <button class="add-btn">Add Task</button>
\`;
document.body.appendChild(container);

juris.setState('tasks', { 1: { completed: false }, 2: { completed: false } });

juris.enhance('.task-list', {
    className: 'task-list enhanced',
    selectors: {
        '.task-item': (context) => {
            const taskId = context.element.dataset.taskId;
            return {
                className: () => {
                    const completed = context.getState(\`tasks.\${taskId}.completed\`, false);
                    return \`task-item \${completed ? 'completed' : 'pending'}\`;
                },
                onclick: () => {
                    const current = context.getState(\`tasks.\${taskId}.completed\`, false);
                    context.setState(\`tasks.\${taskId}.completed\`, !current);
                }
            };
        }
    }
});

const taskItem1 = container.querySelector('[data-task-id="1"]');
testFramework.expect(taskItem1.className).toBe('task-item pending');

taskItem1.click();
await new Promise(resolve => setTimeout(resolve, 10));
testFramework.expect(taskItem1.className).toBe('task-item completed');`);

testFramework.addTest('Dynamic Children Enhancement', 'Enhance API', async function() {
    const juris = new Juris();
    
    const listContainer = document.createElement('div');
    listContainer.className = 'dynamic-list';
    document.body.appendChild(listContainer);
    
    juris.setState('items', ['apple', 'banana']);
    
    juris.enhance('.dynamic-list', (context) => ({
        children: () => {
            const items = context.getState('items', []);
            return items.map(item => ({
                div: {
                    key: item,
                    className: 'list-item',
                    text: item,
                    onclick: () => {
                        context.setState('selectedItem', item);
                    }
                }
            }));
        }
    }));
    
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(listContainer.children.length).toBe(2);
    testFramework.expect(listContainer.children[0].textContent).toBe('apple');
    testFramework.expect(listContainer.children[1].textContent).toBe('banana');
    
    // Add new item
    juris.setState('items', ['apple', 'banana', 'cherry']);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(listContainer.children.length).toBe(3);
    testFramework.expect(listContainer.children[2].textContent).toBe('cherry');
    
    // Test click event
    listContainer.children[0].click();
    testFramework.expect(juris.getState('selectedItem')).toBe('apple');
    
    document.body.removeChild(listContainer);
}, `const juris = new Juris();

const listContainer = document.createElement('div');
listContainer.className = 'dynamic-list';
document.body.appendChild(listContainer);

juris.setState('items', ['apple', 'banana']);

juris.enhance('.dynamic-list', (context) => ({
    children: () => {
        const items = context.getState('items', []);
        return items.map(item => ({
            div: {
                key: item,
                className: 'list-item',
                text: item,
                onclick: () => {
                    context.setState('selectedItem', item);
                }
            }
        }));
    }
}));

testFramework.expect(listContainer.children.length).toBe(2);
testFramework.expect(listContainer.children[0].textContent).toBe('apple');

// Add new item
juris.setState('items', ['apple', 'banana', 'cherry']);
await new Promise(resolve => setTimeout(resolve, 10));
testFramework.expect(listContainer.children.length).toBe(3);`);

testFramework.addTest('Style and Attribute Enhancement', 'Enhance API', async function() {
    const juris = new Juris();
    
    const styledDiv = document.createElement('div');
    styledDiv.className = 'styled-element';
    document.body.appendChild(styledDiv);
    
    juris.setState('theme', 'light');
    juris.setState('loading', false);
    
    juris.enhance('.styled-element', (context) => ({
        style: () => ({
            backgroundColor: context.getState('theme') === 'dark' ? '#333' : '#fff',
            color: context.getState('theme') === 'dark' ? '#fff' : '#333',
            opacity: context.getState('loading') ? '0.5' : '1'
        }),
        disabled: () => context.getState('loading', false),
        'data-theme': () => context.getState('theme', 'light'),
        'aria-busy': () => context.getState('loading', false).toString()
    }));
    
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(styledDiv.style.backgroundColor).toBe('rgb(255, 255, 255)');
    testFramework.expect(styledDiv.style.opacity).toBe('1');
    testFramework.expect(styledDiv.getAttribute('data-theme')).toBe('light');
    testFramework.expect(styledDiv.getAttribute('aria-busy')).toBe('false');
    
    // Change theme
    juris.setState('theme', 'dark');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(styledDiv.style.backgroundColor).toBe('rgb(51, 51, 51)');
    testFramework.expect(styledDiv.getAttribute('data-theme')).toBe('dark');
    
    // Set loading
    juris.setState('loading', true);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(styledDiv.style.opacity).toBe('0.5');
    testFramework.expect(styledDiv.getAttribute('aria-busy')).toBe('true');
    
    document.body.removeChild(styledDiv);
}, `const juris = new Juris();

const styledDiv = document.createElement('div');
styledDiv.className = 'styled-element';
document.body.appendChild(styledDiv);

juris.setState('theme', 'light');
juris.setState('loading', false);

juris.enhance('.styled-element', (context) => ({
    style: () => ({
        backgroundColor: context.getState('theme') === 'dark' ? '#333' : '#fff',
        color: context.getState('theme') === 'dark' ? '#fff' : '#333',
        opacity: context.getState('loading') ? '0.5' : '1'
    }),
    disabled: () => context.getState('loading', false),
    'data-theme': () => context.getState('theme', 'light')
}));

testFramework.expect(styledDiv.style.backgroundColor).toBe('rgb(255, 255, 255)');
testFramework.expect(styledDiv.getAttribute('data-theme')).toBe('light');

juris.setState('theme', 'dark');
await new Promise(resolve => setTimeout(resolve, 10));
testFramework.expect(styledDiv.style.backgroundColor).toBe('rgb(51, 51, 51)');`);

testFramework.addTest('Enhancement Cleanup', 'Enhance API', async function() {
    const juris = new Juris();
    
    const testElement = document.createElement('div');
    testElement.className = 'cleanup-test';
    testElement.textContent = 'Original';
    document.body.appendChild(testElement);
    
    // Enhance element and store cleanup function
    const unenhance = juris.enhance('.cleanup-test', {
        text: 'Enhanced',
        className: 'cleanup-test enhanced',
        onclick: () => {
            juris.setState('cleanupClicked', true);
        }
    });
    
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(testElement.textContent).toBe('Enhanced');
    testFramework.expect(testElement.className).toBe('cleanup-test enhanced');
    
    // Test that enhancement works
    testElement.click();
    testFramework.expect(juris.getState('cleanupClicked')).toBeTruthy();
    
    // Clean up enhancement
    unenhance();
    juris.setState('cleanupClicked', false);
    
    // Test that enhancement is removed (element should not respond to clicks)
    testElement.click();
    testFramework.expect(juris.getState('cleanupClicked')).toBeFalsy();
    
    // Note: Text and className remain as they were last set
    testFramework.expect(testElement.textContent).toBe('Enhanced');
    
    document.body.removeChild(testElement);
}, `const juris = new Juris();

const testElement = document.createElement('div');
testElement.className = 'cleanup-test';
document.body.appendChild(testElement);

// Enhance element and store cleanup function
const unenhance = juris.enhance('.cleanup-test', {
    text: 'Enhanced',
    className: 'cleanup-test enhanced',
    onclick: () => {
        juris.setState('cleanupClicked', true);
    }
});

testFramework.expect(testElement.textContent).toBe('Enhanced');
testFramework.expect(testElement.className).toBe('cleanup-test enhanced');

// Test that enhancement works
testElement.click();
testFramework.expect(juris.getState('cleanupClicked')).toBeTruthy();

// Clean up enhancement
unenhance();
juris.setState('cleanupClicked', false);

// Enhancement is removed (no longer responds to clicks)
testElement.click();
testFramework.expect(juris.getState('cleanupClicked')).toBeFalsy();`);

console.log('Enhance API Tests loaded successfully!');

// StateManager Reset API Tests
testFramework.addTest('StateManager Reset API', 'State Management', async function() {
    const juris = new Juris({
        states: {
            user: { name: 'Default User', authenticated: false },
            app: { theme: 'light', language: 'en' },
            counter: { value: 0 }
        }
    });
    
    // Test initial state
    testFramework.expect(juris.getState('user.name')).toBe('Default User');
    testFramework.expect(juris.getState('user.authenticated')).toBe(false);
    testFramework.expect(juris.getState('app.theme')).toBe('light');
    testFramework.expect(juris.getState('counter.value')).toBe(0);
    
    // Modify state
    juris.setState('user.name', 'John Doe');
    juris.setState('user.authenticated', true);
    juris.setState('app.theme', 'dark');
    juris.setState('counter.value', 42);
    
    // Verify state changed
    testFramework.expect(juris.getState('user.name')).toBe('John Doe');
    testFramework.expect(juris.getState('user.authenticated')).toBe(true);
    testFramework.expect(juris.getState('app.theme')).toBe('dark');
    testFramework.expect(juris.getState('counter.value')).toBe(42);
    
    // Test complete reset
    juris.stateManager.reset();
    
    // Verify state restored to defaults
    testFramework.expect(juris.getState('user.name')).toBe('Default User');
    testFramework.expect(juris.getState('user.authenticated')).toBe(false);
    testFramework.expect(juris.getState('app.theme')).toBe('light');
    testFramework.expect(juris.getState('counter.value')).toBe(0);
    
}, `const juris = new Juris({
    states: {
        user: { name: 'Default User', authenticated: false },
        app: { theme: 'light', language: 'en' },
        counter: { value: 0 }
    }
});

// Modify state
juris.setState('user.name', 'John Doe');
juris.setState('user.authenticated', true);
juris.setState('app.theme', 'dark');
juris.setState('counter.value', 42);

// Reset to defaults
juris.stateManager.reset();

// Verify reset worked
testFramework.expect(juris.getState('user.name')).toBe('Default User');
testFramework.expect(juris.getState('user.authenticated')).toBe(false);
testFramework.expect(juris.getState('app.theme')).toBe('light');
testFramework.expect(juris.getState('counter.value')).toBe(0);`);

testFramework.addTest('StateManager Reset with Preserve', 'State Management', async function() {
    const juris = new Juris({
        states: {
            user: { name: 'Default User', authenticated: false },
            app: { theme: 'light', language: 'en' },
            session: { id: null, active: false }
        }
    });
    
    // Modify all state
    juris.setState('user.name', 'Alice');
    juris.setState('user.authenticated', true);
    juris.setState('app.theme', 'dark');
    juris.setState('app.language', 'fr');
    juris.setState('session.id', 'sess_123');
    juris.setState('session.active', true);
    
    // Reset with preserved paths
    juris.stateManager.reset(['app.theme', 'session.id']);
    
    // Verify defaults restored except preserved paths
    testFramework.expect(juris.getState('user.name')).toBe('Default User');
    testFramework.expect(juris.getState('user.authenticated')).toBe(false);
    testFramework.expect(juris.getState('app.language')).toBe('en');
    testFramework.expect(juris.getState('session.active')).toBe(false);
    
    // Verify preserved paths kept their values
    testFramework.expect(juris.getState('app.theme')).toBe('dark');
    testFramework.expect(juris.getState('session.id')).toBe('sess_123');
    
}, `const juris = new Juris({
    states: {
        user: { name: 'Default User', authenticated: false },
        app: { theme: 'light', language: 'en' },
        session: { id: null, active: false }
    }
});

// Modify state
juris.setState('user.name', 'Alice');
juris.setState('app.theme', 'dark');
juris.setState('session.id', 'sess_123');

// Reset with preservation
juris.stateManager.reset(['app.theme', 'session.id']);

// Verify: defaults restored except preserved paths
testFramework.expect(juris.getState('user.name')).toBe('Default User');
testFramework.expect(juris.getState('app.theme')).toBe('dark'); // preserved
testFramework.expect(juris.getState('session.id')).toBe('sess_123'); // preserved`);

testFramework.addTest('StateManager Reset Empty State', 'State Management', async function() {
    const juris = new Juris(); // No initial states
    
    // Add some state
    juris.setState('dynamic.data', 'test');
    juris.setState('temp.value', 42);
    
    // Verify state exists
    testFramework.expect(juris.getState('dynamic.data')).toBe('test');
    testFramework.expect(juris.getState('temp.value')).toBe(42);
    
    // Reset should clear everything (no defaults to restore)
    juris.stateManager.reset();
    
    // Verify state cleared
    testFramework.expect(juris.getState('dynamic.data')).toBe(null);
    testFramework.expect(juris.getState('temp.value')).toBe(null);
    
}, `const juris = new Juris(); // No initial states

// Add dynamic state
juris.setState('dynamic.data', 'test');
juris.setState('temp.value', 42);

// Reset clears everything
juris.stateManager.reset();

// Verify cleared
testFramework.expect(juris.getState('dynamic.data')).toBe(null);
testFramework.expect(juris.getState('temp.value')).toBe(null);`);


// StateManager Reset API - Component Reactive Tests (Corrected)
testFramework.addTest('Reset with Component Reactivity', 'State Management', async function() {
    let componentCallCount = 0;
    let reactiveCallCount = 0;
    let lastReactiveValue = null;
    
    const TestComponent = (props, context) => {
        componentCallCount++;
        
        return {
            div: {
                text: () => {
                    reactiveCallCount++;
                    const userName = context.getState('user.name', 'Unknown');
                    lastReactiveValue = userName;
                    return `Hello ${userName}`;
                }
            }
        };
    };
    
    const juris = new Juris({
        states: {
            user: { name: 'Default User', role: 'guest' },
            app: { initialized: true }
        },
        layout: { TestComponent: {} } // Use layout to render component once
    });
    
    juris.registerComponent('TestComponent', TestComponent);
    
    // Render the layout (creates components once)
    juris.render(document.createElement('div'));
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Verify initial state
    testFramework.expect(componentCallCount).toBe(1); // Component function called once
    testFramework.expect(reactiveCallCount).toBe(1); // Reactive function called once
    testFramework.expect(lastReactiveValue).toBe('Default User');
    
    // Change state - should trigger only reactive function update
    juris.setState('user.name', 'John Doe');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentCallCount).toBe(1); // Component function NOT called again
    testFramework.expect(reactiveCallCount).toBe(2); // Reactive function called again
    testFramework.expect(lastReactiveValue).toBe('John Doe');
    
    // Reset state - should trigger only reactive function update
    juris.stateManager.reset();
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentCallCount).toBe(1); // Component function still NOT called again
    testFramework.expect(reactiveCallCount).toBe(3); // Reactive function called again
    testFramework.expect(lastReactiveValue).toBe('Default User');
    testFramework.expect(juris.getState('user.name')).toBe('Default User');
    testFramework.expect(juris.getState('user.role')).toBe('guest');
    
}, `let componentCallCount = 0;
let reactiveCallCount = 0;
let lastReactiveValue = null;

const TestComponent = (props, context) => {
    componentCallCount++;
    
    return {
        div: {
            text: () => {
                reactiveCallCount++;
                const userName = context.getState('user.name', 'Unknown');
                lastReactiveValue = userName;
                return \`Hello \${userName}\`;
            }
        }
    };
};

const juris = new Juris({
    states: {
        user: { name: 'Default User', role: 'guest' },
        app: { initialized: true }
    },
    layout: { TestComponent: {} }
});

juris.registerComponent('TestComponent', TestComponent);

// Render the layout (creates components once)
juris.render(document.createElement('div'));
await new Promise(resolve => setTimeout(resolve, 10));

// Verify initial state
testFramework.expect(componentCallCount).toBe(1);
testFramework.expect(reactiveCallCount).toBe(1);
testFramework.expect(lastReactiveValue).toBe('Default User');

// Change state - should trigger only reactive function update
juris.setState('user.name', 'John Doe');
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(componentCallCount).toBe(1);
testFramework.expect(reactiveCallCount).toBe(2);
testFramework.expect(lastReactiveValue).toBe('John Doe');

// Reset state - should trigger only reactive function update
juris.stateManager.reset();
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(componentCallCount).toBe(1);
testFramework.expect(reactiveCallCount).toBe(3);
testFramework.expect(lastReactiveValue).toBe('Default User');
testFramework.expect(juris.getState('user.name')).toBe('Default User');
testFramework.expect(juris.getState('user.role')).toBe('guest');`);

testFramework.addTest('Reset Branch-Aware with Nested State', 'State Management', async function() {
    const juris = new Juris({
        states: {
            user: {
                profile: { name: 'Default', email: 'default@test.com' },
                settings: { theme: 'light', notifications: true },
                session: { token: null, expiry: null }
            },
            app: {
                ui: { sidebar: false, modal: null },
                data: { cache: {}, loading: false }
            }
        }
    });
    
    // Modify nested state
    juris.setState('user.profile.name', 'Alice');
    juris.setState('user.profile.email', 'alice@test.com');
    juris.setState('user.settings.theme', 'dark');
    juris.setState('user.session.token', 'abc123');
    juris.setState('app.ui.sidebar', true);
    juris.setState('app.data.loading', true);
    
    // Test branch-aware reset with nested preservation
    juris.stateManager.reset(['user.settings', 'app.ui.sidebar']);
    
    // Verify user.profile reset to defaults
    testFramework.expect(juris.getState('user.profile.name')).toBe('Default');
    testFramework.expect(juris.getState('user.profile.email')).toBe('default@test.com');
    
    // Verify user.session reset to defaults
    testFramework.expect(juris.getState('user.session.token')).toBe(null);
    testFramework.expect(juris.getState('user.session.expiry')).toBe(null);
    
    // Verify user.settings preserved (entire branch)
    testFramework.expect(juris.getState('user.settings.theme')).toBe('dark');
    testFramework.expect(juris.getState('user.settings.notifications')).toBe(true);
    
    // Verify app.ui.sidebar preserved (specific path)
    testFramework.expect(juris.getState('app.ui.sidebar')).toBe(true);
    
    // Verify app.ui.modal reset to default
    testFramework.expect(juris.getState('app.ui.modal')).toBe(null);
    
    // Verify app.data reset to defaults
    testFramework.expect(juris.getState('app.data.loading')).toBe(false);
    
}, `const juris = new Juris({
    states: {
        user: {
            profile: { name: 'Default', email: 'default@test.com' },
            settings: { theme: 'light', notifications: true }
        },
        app: { ui: { sidebar: false, modal: null } }
    }
});

// Modify nested state
juris.setState('user.profile.name', 'Alice');
juris.setState('user.settings.theme', 'dark');
juris.setState('app.ui.sidebar', true);

// Branch-aware reset with preservation
juris.stateManager.reset(['user.settings', 'app.ui.sidebar']);

// Profile resets, settings preserved
testFramework.expect(juris.getState('user.profile.name')).toBe('Default');
testFramework.expect(juris.getState('user.settings.theme')).toBe('dark');`);

testFramework.addTest('Reset with Multiple Component Subscriptions', 'State Management', async function() {
    let userComponentRenders = 0;
    let appComponentRenders = 0;
    let sharedComponentRenders = 0;
    
    const UserComponent = (props, context) => {
        userComponentRenders++;
        return {
            div: { text: () => context.getState('user.name', 'No user') }
        };
    };
    
    const AppComponent = (props, context) => {
        appComponentRenders++;
        return {
            div: { text: () => context.getState('app.title', 'No title') }
        };
    };
    
    const SharedComponent = (props, context) => {
        sharedComponentRenders++;
        return {
            div: {
                text: () => `${context.getState('user.name', 'No user')} - ${context.getState('app.title', 'No title')}`
            }
        };
    };
    
    const juris = new Juris({
        states: {
            user: { name: 'Default User', status: 'offline' },
            app: { title: 'Default App', version: '1.0.0' }
        },
        layout: {
            div: {
                children: [
                    { UserComponent: {} },
                    { AppComponent: {} },
                    { SharedComponent: {} }
                ]
            }
        }
    });
    
    // Register components
    juris.registerComponent('UserComponent', UserComponent);
    juris.registerComponent('AppComponent', AppComponent);
    juris.registerComponent('SharedComponent', SharedComponent);
    
    // Render layout (creates all components once)
    juris.render(document.createElement('div'));
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Verify initial renders
    testFramework.expect(userComponentRenders).toBe(1);
    testFramework.expect(appComponentRenders).toBe(1);
    testFramework.expect(sharedComponentRenders).toBe(1);
    
    // Modify user state - should NOT trigger component re-creation, only reactive updates
    juris.setState('user.name', 'Alice');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(userComponentRenders).toBe(1); // No re-creation
    testFramework.expect(appComponentRenders).toBe(1); // No re-creation
    testFramework.expect(sharedComponentRenders).toBe(1); // No re-creation
    
    // Modify app state - should NOT trigger component re-creation, only reactive updates
    juris.setState('app.title', 'My App');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(userComponentRenders).toBe(1); // No re-creation
    testFramework.expect(appComponentRenders).toBe(1); // No re-creation
    testFramework.expect(sharedComponentRenders).toBe(1); // No re-creation
    
    // Reset all - should NOT trigger component re-creation, only reactive updates
    juris.stateManager.reset();
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(userComponentRenders).toBe(1); // No re-creation
    testFramework.expect(appComponentRenders).toBe(1); // No re-creation
    testFramework.expect(sharedComponentRenders).toBe(1); // No re-creation
    
    // Verify state is back to defaults
    testFramework.expect(juris.getState('user.name')).toBe('Default User');
    testFramework.expect(juris.getState('app.title')).toBe('Default App');
    
}, `let userComponentRenders = 0;
let appComponentRenders = 0;
let sharedComponentRenders = 0;

const UserComponent = (props, context) => {
    userComponentRenders++;
    return {
        div: { text: () => context.getState('user.name', 'No user') }
    };
};

const AppComponent = (props, context) => {
    appComponentRenders++;
    return {
        div: { text: () => context.getState('app.title', 'No title') }
    };
};

const SharedComponent = (props, context) => {
    sharedComponentRenders++;
    return {
        div: {
            text: () => \`\${context.getState('user.name', 'No user')} - \${context.getState('app.title', 'No title')}\`
        }
    };
};

const juris = new Juris({
    states: {
        user: { name: 'Default User', status: 'offline' },
        app: { title: 'Default App', version: '1.0.0' }
    },
    layout: {
        div: {
            children: [
                { UserComponent: {} },
                { AppComponent: {} },
                { SharedComponent: {} }
            ]
        }
    }
});

juris.registerComponent('UserComponent', UserComponent);
juris.registerComponent('AppComponent', AppComponent);
juris.registerComponent('SharedComponent', SharedComponent);

juris.render(document.createElement('div'));

// Components created once, state changes trigger surgical DOM updates
testFramework.expect(userComponentRenders).toBe(1);
testFramework.expect(appComponentRenders).toBe(1);
testFramework.expect(sharedComponentRenders).toBe(1);

juris.setState('user.name', 'Alice');
// Components still only created once - surgical updates only
testFramework.expect(userComponentRenders).toBe(1);

juris.stateManager.reset();
// Still only created once
testFramework.expect(userComponentRenders).toBe(1);`);

testFramework.addTest('Reset with Headless Component Integration', 'State Management', async function() {
    let serviceInitialized = false;
    let serviceResetCalled = false;
    
    const DataService = (props, context) => ({
        api: {
            loadData: () => {
                context.setState('data.items', ['item1', 'item2']);
                context.setState('data.loading', false);
            },
            clearData: () => {
                context.setState('data.items', []);
                context.setState('data.loading', false);
            },
            onReset: () => {
                serviceResetCalled = true;
            }
        },
        hooks: {
            onRegister: () => {
                serviceInitialized = true;
                context.setState('service.status', 'ready');
            }
        }
    });
    
    const DataComponent = (props, context) => ({
        div: {
            children: () => {
                const items = context.getState('data.items', []);
                const loading = context.getState('data.loading', true);
                
                if (loading) return [{ span: { text: 'Loading...' } }];
                return items.map((item, i) => ({ div: { text: item, key: i } }));
            }
        }
    });
    
    const juris = new Juris({
        states: {
            data: { items: [], loading: true },
            service: { status: 'initializing' },
            user: { preferences: { autoLoad: false } }
        }
    });
    
    // Register headless and UI components
    juris.registerHeadlessComponent('DataService', DataService);
    juris.registerComponent('DataComponent', DataComponent);
    
    const serviceInstance = juris.initializeHeadlessComponent('DataService');
    const componentEl = juris.componentManager.create('DataComponent');
    
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Verify initial state
    testFramework.expect(serviceInitialized).toBe(true);
    testFramework.expect(juris.getState('service.status')).toBe('ready');
    testFramework.expect(juris.getState('data.loading')).toBe(true);
    
    // Load data through service
    serviceInstance.api.loadData();
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(juris.getState('data.items')).toEqual(['item1', 'item2']);
    testFramework.expect(juris.getState('data.loading')).toBe(false);
    
    // Modify user preferences
    juris.setState('user.preferences.autoLoad', true);
    
    // Reset with preservation of user preferences
    juris.stateManager.reset(['user.preferences']);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Verify reset restored defaults except preserved
    testFramework.expect(juris.getState('data.items')).toEqual([]);
    testFramework.expect(juris.getState('data.loading')).toBe(true);
    testFramework.expect(juris.getState('service.status')).toBe('initializing');
    testFramework.expect(juris.getState('user.preferences.autoLoad')).toBe(true); // preserved
    
}, `const DataService = (props, context) => ({
    api: {
        loadData: () => context.setState('data.items', ['item1', 'item2'])
    },
    hooks: {
        onRegister: () => context.setState('service.status', 'ready')
    }
});

const juris = new Juris({
    states: {
        data: { items: [], loading: true },
        service: { status: 'initializing' }
    }
});

juris.registerHeadlessComponent('DataService', DataService);
const service = juris.initializeHeadlessComponent('DataService');

service.api.loadData();
// Reset restores defaults, headless components react accordingly
juris.stateManager.reset();`);

testFramework.addTest('Reset Branch Specificity and Inheritance', 'State Management', async function() {
    const juris = new Juris({
        states: {
            app: {
                config: {
                    api: { baseUrl: 'https://api.default.com', timeout: 5000 },
                    ui: { theme: 'light', language: 'en' },
                    features: { beta: false, debug: false }
                },
                runtime: {
                    initialized: false,
                    errors: [],
                    performance: { startTime: null }
                }
            }
        }
    });
    
    // Modify various nested levels
    juris.setState('app.config.api.baseUrl', 'https://api.custom.com');
    juris.setState('app.config.api.timeout', 10000);
    juris.setState('app.config.ui.theme', 'dark');
    juris.setState('app.config.features.beta', true);
    juris.setState('app.runtime.initialized', true);
    juris.setState('app.runtime.errors', ['error1']);
    
    // Test branch-specific preservation
    juris.stateManager.reset(['app.config.ui', 'app.runtime.initialized']);
    
    // Verify app.config.api reset to defaults
    testFramework.expect(juris.getState('app.config.api.baseUrl')).toBe('https://api.default.com');
    testFramework.expect(juris.getState('app.config.api.timeout')).toBe(5000);
    
    // Verify app.config.ui preserved (entire branch)
    testFramework.expect(juris.getState('app.config.ui.theme')).toBe('dark');
    testFramework.expect(juris.getState('app.config.ui.language')).toBe('en');
    
    // Verify app.config.features reset to defaults
    testFramework.expect(juris.getState('app.config.features.beta')).toBe(false);
    testFramework.expect(juris.getState('app.config.features.debug')).toBe(false);
    
    // Verify app.runtime.initialized preserved (specific path)
    testFramework.expect(juris.getState('app.runtime.initialized')).toBe(true);
    
    // Verify app.runtime.errors reset to default
    testFramework.expect(juris.getState('app.runtime.errors')).toEqual([]);
    testFramework.expect(juris.getState('app.runtime.performance.startTime')).toBe(null);
    
}, `const juris = new Juris({
    states: {
        app: {
            config: {
                api: { baseUrl: 'https://api.default.com', timeout: 5000 },
                ui: { theme: 'light', language: 'en' }
            },
            runtime: { initialized: false, errors: [] }
        }
    }
});

// Modify nested state at different levels
juris.setState('app.config.api.baseUrl', 'https://api.custom.com');
juris.setState('app.config.ui.theme', 'dark');
juris.setState('app.runtime.initialized', true);

// Branch-specific reset preserves entire ui branch and specific initialized path
juris.stateManager.reset(['app.config.ui', 'app.runtime.initialized']);

// api branch resets, ui branch preserved, initialized preserved
testFramework.expect(juris.getState('app.config.api.baseUrl')).toBe('https://api.default.com');
testFramework.expect(juris.getState('app.config.ui.theme')).toBe('dark');
testFramework.expect(juris.getState('app.runtime.initialized')).toBe(true);`);

testFramework.addTest('Multi-Level Element Subscription Isolation', 'State Management', async function() {
    let componentRenders = 0;
    let parentReactiveCalls = 0;
    let childReactiveCalls = 0;
    
    const TestComponent = (props, context) => {
        componentRenders++;
        return {
            div: {
                className: 'parent',
                children: () => {
                    parentReactiveCalls++;
                    const showItems = context.getState('parent.showItems', true);
                    return showItems ? [
                        {
                            span: {
                                text: () => {
                                    childReactiveCalls++;
                                    return `Child 1: ${context.getState('child.value1', 'default1')}`;
                                },
                                className: () => {
                                    childReactiveCalls++;
                                    return context.getState('child.active1', false) ? 'active' : 'inactive';
                                }
                            }
                        },
                        {
                            p: {
                                text: () => {
                                    childReactiveCalls++;
                                    return `Child 2: ${context.getState('child.value2', 'default2')}`;
                                },
                                style: () => {
                                    childReactiveCalls++;
                                    return { color: context.getState('child.color2', 'black') };
                                }
                            }
                        }
                    ] : [];
                }
            }
        };
    };
    
    const juris = new Juris({
        states: {
            parent: { showItems: true },
            child: { 
                value1: 'Default 1', 
                active1: false,
                value2: 'Default 2', 
                color2: 'blue' 
            }
        },
        layout: { TestComponent: {} }
    });
    
    juris.registerComponent('TestComponent', TestComponent);
    
    // Initial render
    juris.render(document.createElement('div'));
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Verify initial state
    testFramework.expect(componentRenders).toBe(1);
    testFramework.expect(parentReactiveCalls).toBe(1); // children() called once
    testFramework.expect(childReactiveCalls).toBe(4); // 4 child reactive attributes
    
    // Test 1: Change child state - should NOT affect parent reactive function
    juris.setState('child.value1', 'Updated Value 1');
    juris.setState('child.active1', true);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No component re-creation
    testFramework.expect(parentReactiveCalls).toBe(1); // Parent children() NOT called again
    testFramework.expect(childReactiveCalls).toBe(6); // +2 calls (text + className for span)
    
    // Test 2: Change more child state - should still NOT affect parent
    juris.setState('child.value2', 'Updated Value 2');
    juris.setState('child.color2', 'red');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No component re-creation
    testFramework.expect(parentReactiveCalls).toBe(1); // Parent children() still NOT called
    testFramework.expect(childReactiveCalls).toBe(8); // +2 calls (text + style for p)
    
    // Test 3: Change parent state - should ONLY affect parent reactive function
    juris.setState('parent.showItems', false);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No component re-creation
    testFramework.expect(parentReactiveCalls).toBe(2); // +1 call (children() called)
    testFramework.expect(childReactiveCalls).toBe(8); // No additional child calls (children hidden)
    
    // Test 4: Show items again - parent reactive called, children re-rendered
    juris.setState('parent.showItems', true);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No component re-creation
    testFramework.expect(parentReactiveCalls).toBe(3); // +1 call (children() called)
    testFramework.expect(childReactiveCalls).toBe(12); // +4 calls (all child reactives re-executed)
    
    // Test 5: Reset - verify isolation during reset
    juris.stateManager.reset();
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Verify component still only created once
    testFramework.expect(componentRenders).toBe(1);
    
    // Verify state reset to defaults
    testFramework.expect(juris.getState('parent.showItems')).toBe(true);
    testFramework.expect(juris.getState('child.value1')).toBe('Default 1');
    testFramework.expect(juris.getState('child.active1')).toBe(false);
    testFramework.expect(juris.getState('child.value2')).toBe('Default 2');
    testFramework.expect(juris.getState('child.color2')).toBe('blue');
    
    // Reset should trigger updates for changed values
    testFramework.expect(parentReactiveCalls).toBe(4); // No change (showItems already true)
    testFramework.expect(childReactiveCalls).toBe(20); // +4 calls (all child values changed)
    
}, `let componentRenders = 0;
    let parentReactiveCalls = 0;
    let childReactiveCalls = 0;
    
    const TestComponent = (props, context) => {
        componentRenders++;
        return {
            div: {
                className: 'parent',
                children: () => {
                    parentReactiveCalls++;
                    const showItems = context.getState('parent.showItems', true);
                    return showItems ? [
                        {
                            span: {
                                text: () => {
                                    childReactiveCalls++;
                                    return \`Child 1: \${context.getState('child.value1', 'default1')}\`;
                                },
                                className: () => {
                                    childReactiveCalls++;
                                    return context.getState('child.active1', false) ? 'active' : 'inactive\';
                                }
                            }
                        },
                        {
                            p: {
                                text: () => {
                                    childReactiveCalls++;
                                    return \`Child 2: \${context.getState('child.value2', 'default2')}\`;
                                },
                                style: () => {
                                    childReactiveCalls++;
                                    return { color: context.getState('child.color2', 'black') };
                                }
                            }
                        }
                    ] : [];
                }
            }
        };
    };
    
    const juris = new Juris({
        states: {
            parent: { showItems: true },
            child: { 
                value1: 'Default 1', 
                active1: false,
                value2: 'Default 2', 
                color2: 'blue' 
            }
        },
        layout: { TestComponent: {} }
    });
    
    juris.registerComponent('TestComponent', TestComponent);
    
    // Initial render
    juris.render(document.createElement('div'));
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Verify initial state
    testFramework.expect(componentRenders).toBe(1);
    testFramework.expect(parentReactiveCalls).toBe(1); // children() called once
    testFramework.expect(childReactiveCalls).toBe(4); // 4 child reactive attributes
    
    // Test 1: Change child state - should NOT affect parent reactive function
    juris.setState('child.value1', 'Updated Value 1');
    juris.setState('child.active1', true);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No component re-creation
    testFramework.expect(parentReactiveCalls).toBe(1); // Parent children() NOT called again
    testFramework.expect(childReactiveCalls).toBe(6); // +2 calls (text + className for span)
    
    // Test 2: Change more child state - should still NOT affect parent
    juris.setState('child.value2', 'Updated Value 2');
    juris.setState('child.color2', 'red');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No component re-creation
    testFramework.expect(parentReactiveCalls).toBe(1); // Parent children() still NOT called
    testFramework.expect(childReactiveCalls).toBe(8); // +2 calls (text + style for p)
    
    // Test 3: Change parent state - should ONLY affect parent reactive function
    juris.setState('parent.showItems', false);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No component re-creation
    testFramework.expect(parentReactiveCalls).toBe(2); // +1 call (children() called)
    testFramework.expect(childReactiveCalls).toBe(8); // No additional child calls (children hidden)
    
    // Test 4: Show items again - parent reactive called, children re-rendered
    juris.setState('parent.showItems', true);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No component re-creation
    testFramework.expect(parentReactiveCalls).toBe(3); // +1 call (children() called)
    testFramework.expect(childReactiveCalls).toBe(12); // +4 calls (all child reactives re-executed)
    
    // Test 5: Reset - verify isolation during reset
    juris.stateManager.reset();
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Verify component still only created once
    testFramework.expect(componentRenders).toBe(1);
    
    // Verify state reset to defaults
    testFramework.expect(juris.getState('parent.showItems')).toBe(true);
    testFramework.expect(juris.getState('child.value1')).toBe('Default 1');
    testFramework.expect(juris.getState('child.active1')).toBe(false);
    testFramework.expect(juris.getState('child.value2')).toBe('Default 2');
    testFramework.expect(juris.getState('child.color2')).toBe('blue');
    
    // Reset should trigger updates for changed values
    testFramework.expect(parentReactiveCalls).toBe(4); // No change (showItems already true)
    testFramework.expect(childReactiveCalls).toBe(16);`);

testFramework.addTest('All Reactive Attributes Test', 'State Management', async function() {
    let componentRenders = 0;
    let textReactiveCalls = 0;
    let childrenReactiveCalls = 0;
    let styleReactiveCalls = 0;
    let classNameReactiveCalls = 0;
    let valueReactiveCalls = 0;
    let dataReactiveCalls = 0;
    let ariaReactiveCalls = 0;
    let titleReactiveCalls = 0;
    let disabledReactiveCalls = 0;
    let readonlyReactiveCalls = 0;
    let tabIndexReactiveCalls = 0;
    let placeholderReactiveCalls = 0;
    
    const AllAttributesComponent = (props, context) => {
        componentRenders++;
        return {
            div: {
                // Text reactive attribute
                text: () => {
                    textReactiveCalls++;
                    return `Text: ${context.getState('content.text', 'default text')}`;
                },
            
            // Static attributes (should not affect reactive call counts)
            id: 'static-component-id',
            disabled: false,
            readonly: true,
            tabIndex: 0,
            placeholder: 'Static placeholder text',
            'data-static': 'static-value',
            'aria-hidden': false,
            role: 'button',
            type: 'text',
                
                // Children reactive attribute
                children: () => {
                    childrenReactiveCalls++;
                    const showChildren = context.getState('content.showChildren', true);
                    return showChildren ? [
                        {
                            span: {
                                text: `Child: ${context.getState('content.childText', 'child default')}`
                            }
                        },
                        {
                            p: {
                                text: `Paragraph: ${context.getState('content.paragraphText', 'para default')}`
                            }
                        }
                    ] : [];
                },
                
                // Style reactive attribute
                style: () => {
                    styleReactiveCalls++;
                    return {
                        color: context.getState('styles.color', 'black'),
                        fontSize: context.getState('styles.fontSize', '16px'),
                        backgroundColor: context.getState('styles.bgColor', 'white')
                    };
                },
                
                // ClassName reactive attribute
                className: () => {
                    classNameReactiveCalls++;
                    const theme = context.getState('ui.theme', 'light');
                    const active = context.getState('ui.active', false);
                    return `container ${theme} ${active ? 'active' : 'inactive'}`;
                },
                
                // Value reactive attribute (for form elements)
                value: () => {
                    valueReactiveCalls++;
                    return context.getState('form.inputValue', 'default value');
                },
                
                // Data attribute reactive
                'data-id': () => {
                    dataReactiveCalls++;
                    return `item-${context.getState('meta.id', '0')}`;
                },
                
                // Aria attribute reactive
                'aria-label': () => {
                    ariaReactiveCalls++;
                    return `Label: ${context.getState('accessibility.label', 'default label')}`;
                },
                
                // Title attribute reactive
                title: () => {
                    titleReactiveCalls++;
                    return `Tooltip: ${context.getState('meta.tooltip', 'default tooltip')}`;
                },
                
                // Static HTML attributes as reactive functions
                disabled: () => {
                    disabledReactiveCalls++;
                    return context.getState('form.disabled', false);
                },
                
                readonly: () => {
                    readonlyReactiveCalls++;
                    return context.getState('form.readonly', false);
                },
                
                tabIndex: () => {
                    tabIndexReactiveCalls++;
                    return context.getState('ui.tabIndex', 0);
                },
                
                placeholder: () => {
                    placeholderReactiveCalls++;
                    return `Enter ${context.getState('form.fieldType', 'text')}`;
                },
                
                // Mixed: some static, some reactive
                id: 'static-component-id',
                'data-static': 'static-value',
                role: 'textbox'
            }
        };
    };
    
    const juris = new Juris({
        states: {
            content: {
                text: 'Initial Text',
                showChildren: true,
                childText: 'Initial Child',
                paragraphText: 'Initial Paragraph'
            },
            styles: {
                color: 'blue',
                fontSize: '18px',
                bgColor: 'lightgray'
            },
            ui: {
                theme: 'dark',
                active: false
            },
            form: {
                inputValue: 'initial input'
            },
            meta: {
                id: '123',
                tooltip: 'initial tooltip'
            },
            accessibility: {
                label: 'initial label'
            }
        },
        layout: { AllAttributesComponent: {} }
    });
    
    juris.registerComponent('AllAttributesComponent', AllAttributesComponent);
    
    // Initial render
    juris.render(document.createElement('div'));
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Verify initial state - all reactive functions called once
    testFramework.expect(componentRenders).toBe(1);
    testFramework.expect(textReactiveCalls).toBe(1);
    testFramework.expect(childrenReactiveCalls).toBe(1);
    testFramework.expect(styleReactiveCalls).toBe(1);
    testFramework.expect(classNameReactiveCalls).toBe(1);
    testFramework.expect(valueReactiveCalls).toBe(1);
    testFramework.expect(dataReactiveCalls).toBe(1);
    testFramework.expect(ariaReactiveCalls).toBe(1);
    testFramework.expect(titleReactiveCalls).toBe(1);
    testFramework.expect(disabledReactiveCalls).toBe(1);
    testFramework.expect(readonlyReactiveCalls).toBe(1);
    testFramework.expect(tabIndexReactiveCalls).toBe(1);
    testFramework.expect(placeholderReactiveCalls).toBe(1);
    
    // Test 1: Change text content - only text reactive should be called
    juris.setState('content.text', 'Updated Text');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No re-creation
    testFramework.expect(textReactiveCalls).toBe(2); // +1
    testFramework.expect(childrenReactiveCalls).toBe(1); // No change
    testFramework.expect(styleReactiveCalls).toBe(1); // No change
    testFramework.expect(classNameReactiveCalls).toBe(1); // No change
    testFramework.expect(valueReactiveCalls).toBe(1); // No change
    testFramework.expect(dataReactiveCalls).toBe(1); // No change
    testFramework.expect(ariaReactiveCalls).toBe(1); // No change
    testFramework.expect(titleReactiveCalls).toBe(1); // No change
    testFramework.expect(disabledReactiveCalls).toBe(1); // No change
    testFramework.expect(readonlyReactiveCalls).toBe(1); // No change
    testFramework.expect(tabIndexReactiveCalls).toBe(1); // No change
    testFramework.expect(placeholderReactiveCalls).toBe(1); // No change
    
    // Test 2: Change children visibility - only children reactive should be called
    juris.setState('content.showChildren', false);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No re-creation
    testFramework.expect(textReactiveCalls).toBe(2); // No change
    testFramework.expect(childrenReactiveCalls).toBe(2); // +1
    testFramework.expect(styleReactiveCalls).toBe(1); // No change
    testFramework.expect(classNameReactiveCalls).toBe(1); // No change
    testFramework.expect(valueReactiveCalls).toBe(1); // No change
    testFramework.expect(dataReactiveCalls).toBe(1); // No change
    testFramework.expect(ariaReactiveCalls).toBe(1); // No change
    testFramework.expect(titleReactiveCalls).toBe(1); // No change
    
    // Test 3: Change multiple style properties - only style reactive should be called
    juris.setState('styles.color', 'red');
    juris.setState('styles.fontSize', '20px');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No re-creation
    testFramework.expect(textReactiveCalls).toBe(2); // No change
    testFramework.expect(childrenReactiveCalls).toBe(2); // No change
    testFramework.expect(styleReactiveCalls).toBe(3); // +2 (one for each setState)
    testFramework.expect(classNameReactiveCalls).toBe(1); // No change
    testFramework.expect(valueReactiveCalls).toBe(1); // No change
    testFramework.expect(dataReactiveCalls).toBe(1); // No change
    testFramework.expect(ariaReactiveCalls).toBe(1); // No change
    testFramework.expect(titleReactiveCalls).toBe(1); // No change
    
    // Test 4: Change UI state - only className reactive should be called
    juris.setState('ui.theme', 'light');
    juris.setState('ui.active', true);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No re-creation
    testFramework.expect(textReactiveCalls).toBe(2); // No change
    testFramework.expect(childrenReactiveCalls).toBe(2); // No change
    testFramework.expect(styleReactiveCalls).toBe(3); // No change
    testFramework.expect(classNameReactiveCalls).toBe(3); // +2 (one for each setState)
    testFramework.expect(valueReactiveCalls).toBe(1); // No change
    testFramework.expect(dataReactiveCalls).toBe(1); // No change
    testFramework.expect(ariaReactiveCalls).toBe(1); // No change
    testFramework.expect(titleReactiveCalls).toBe(1); // No change
    
    // Test 5: Change form value - only value reactive should be called
    juris.setState('form.inputValue', 'updated input');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No re-creation
    testFramework.expect(textReactiveCalls).toBe(2); // No change
    testFramework.expect(childrenReactiveCalls).toBe(2); // No change
    testFramework.expect(styleReactiveCalls).toBe(3); // No change
    testFramework.expect(classNameReactiveCalls).toBe(3); // No change
    testFramework.expect(valueReactiveCalls).toBe(2); // +1
    testFramework.expect(dataReactiveCalls).toBe(1); // No change
    testFramework.expect(ariaReactiveCalls).toBe(1); // No change
    testFramework.expect(titleReactiveCalls).toBe(1); // No change
    
    // Test 6: Change form control attributes - only respective reactives should be called
    juris.setState('form.disabled', true);
    juris.setState('form.readonly', true);
    juris.setState('ui.tabIndex', 1);
    juris.setState('form.fieldType', 'password');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No re-creation
    testFramework.expect(textReactiveCalls).toBe(2); // No change
    testFramework.expect(childrenReactiveCalls).toBe(2); // No change
    testFramework.expect(styleReactiveCalls).toBe(3); // No change
    testFramework.expect(classNameReactiveCalls).toBe(3); // No change
    testFramework.expect(valueReactiveCalls).toBe(2); // No change
    testFramework.expect(dataReactiveCalls).toBe(1); // No change
    testFramework.expect(ariaReactiveCalls).toBe(1); // No change
    testFramework.expect(titleReactiveCalls).toBe(1); // No change
    testFramework.expect(disabledReactiveCalls).toBe(2); // +1 (form.disabled)
    testFramework.expect(readonlyReactiveCalls).toBe(2); // +1 (form.readonly)
    testFramework.expect(tabIndexReactiveCalls).toBe(2); // +1 (ui.tabIndex)
    testFramework.expect(placeholderReactiveCalls).toBe(2); // +1 (form.fieldType)
    
    // Test 7: Change meta attributes - only respective reactives should be called
    juris.setState('meta.id', '456');
    juris.setState('meta.tooltip', 'updated tooltip');
    juris.setState('accessibility.label', 'updated label');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No re-creation
    testFramework.expect(textReactiveCalls).toBe(2); // No change
    testFramework.expect(childrenReactiveCalls).toBe(2); // No change
    testFramework.expect(styleReactiveCalls).toBe(3); // No change
    testFramework.expect(classNameReactiveCalls).toBe(3); // No change
    testFramework.expect(valueReactiveCalls).toBe(2); // No change
    testFramework.expect(dataReactiveCalls).toBe(2); // +1 (meta.id)
    testFramework.expect(ariaReactiveCalls).toBe(2); // +1 (accessibility.label)
    testFramework.expect(titleReactiveCalls).toBe(2); // +1 (meta.tooltip)
    testFramework.expect(disabledReactiveCalls).toBe(2); // No change
    testFramework.expect(readonlyReactiveCalls).toBe(2); // No change
    testFramework.expect(tabIndexReactiveCalls).toBe(2); // No change
    testFramework.expect(placeholderReactiveCalls).toBe(2); // No change
    
    // Test 7: Change static attributes (should not affect any reactive calls)
    // Note: In real usage, static attributes can't be changed after creation,
    // but this tests that they don't interfere with reactive tracking
    const beforeStaticTest = {
        text: textReactiveCalls,
        children: childrenReactiveCalls,
        style: styleReactiveCalls,
        className: classNameReactiveCalls,
        value: valueReactiveCalls,
        data: dataReactiveCalls,
        aria: ariaReactiveCalls,
        title: titleReactiveCalls,
        disabled: disabledReactiveCalls,
        readonly: readonlyReactiveCalls,
        tabIndex: tabIndexReactiveCalls,
        placeholder: placeholderReactiveCalls
    };
    
    // Change some unrelated state that static attributes don't depend on
    juris.setState('unrelated.value', 'test');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Verify static attributes don't cause reactive calls
    testFramework.expect(textReactiveCalls).toBe(beforeStaticTest.text);
    testFramework.expect(childrenReactiveCalls).toBe(beforeStaticTest.children);
    testFramework.expect(styleReactiveCalls).toBe(beforeStaticTest.style);
    testFramework.expect(classNameReactiveCalls).toBe(beforeStaticTest.className);
    testFramework.expect(valueReactiveCalls).toBe(beforeStaticTest.value);
    testFramework.expect(dataReactiveCalls).toBe(beforeStaticTest.data);
    testFramework.expect(ariaReactiveCalls).toBe(beforeStaticTest.aria);
    testFramework.expect(titleReactiveCalls).toBe(beforeStaticTest.title);
    
    // Test 8: Reset - all reactive functions should be called for changed values
    const preResetCounts = {
        text: textReactiveCalls,
        children: childrenReactiveCalls,
        style: styleReactiveCalls,
        className: classNameReactiveCalls,
        value: valueReactiveCalls,
        data: dataReactiveCalls,
        aria: ariaReactiveCalls,
        title: titleReactiveCalls,
        disabled: disabledReactiveCalls,
        readonly: readonlyReactiveCalls,
        tabIndex: tabIndexReactiveCalls,
        placeholder: placeholderReactiveCalls
    };
    
    juris.stateManager.reset();
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Verify component still only created once
    testFramework.expect(componentRenders).toBe(1);
    
    // Verify state reset to defaults
    testFramework.expect(juris.getState('content.text')).toBe('Initial Text');
    testFramework.expect(juris.getState('content.showChildren')).toBe(true);
    testFramework.expect(juris.getState('styles.color')).toBe('blue');
    testFramework.expect(juris.getState('ui.theme')).toBe('dark');
    testFramework.expect(juris.getState('ui.active')).toBe(false);
    testFramework.expect(juris.getState('form.inputValue')).toBe('initial input');
    testFramework.expect(juris.getState('meta.id')).toBe('123');
    testFramework.expect(juris.getState('meta.tooltip')).toBe('initial tooltip');
    testFramework.expect(juris.getState('form.disabled')).toBe(null);
    testFramework.expect(juris.getState('form.readonly')).toBe(null);
    testFramework.expect(juris.getState('ui.tabIndex')).toBe(null);
    testFramework.expect(juris.getState('form.fieldType')).toBe(null);
    
    // All reactive functions should have been called for reset (values changed)
    testFramework.expect(textReactiveCalls).toBeGreaterThan(preResetCounts.text);
    testFramework.expect(childrenReactiveCalls).toBeGreaterThan(preResetCounts.children);
    testFramework.expect(styleReactiveCalls).toBeGreaterThan(preResetCounts.style);
    testFramework.expect(classNameReactiveCalls).toBeGreaterThan(preResetCounts.className);
    testFramework.expect(valueReactiveCalls).toBeGreaterThan(preResetCounts.value);
    testFramework.expect(dataReactiveCalls).toBeGreaterThan(preResetCounts.data);
    testFramework.expect(ariaReactiveCalls).toBeGreaterThan(preResetCounts.aria);
    testFramework.expect(titleReactiveCalls).toBeGreaterThan(preResetCounts.title);
    testFramework.expect(disabledReactiveCalls).toBeGreaterThan(preResetCounts.disabled);
    testFramework.expect(readonlyReactiveCalls).toBeGreaterThan(preResetCounts.readonly);
    testFramework.expect(tabIndexReactiveCalls).toBeGreaterThan(preResetCounts.tabIndex);
    testFramework.expect(placeholderReactiveCalls).toBeGreaterThan(preResetCounts.placeholder);
    
}, ` let componentRenders = 0;
    let textReactiveCalls = 0;
    let childrenReactiveCalls = 0;
    let styleReactiveCalls = 0;
    let classNameReactiveCalls = 0;
    let valueReactiveCalls = 0;
    let dataReactiveCalls = 0;
    let ariaReactiveCalls = 0;
    let titleReactiveCalls = 0;
    let disabledReactiveCalls = 0;
    let readonlyReactiveCalls = 0;
    let tabIndexReactiveCalls = 0;
    let placeholderReactiveCalls = 0;
    
    const AllAttributesComponent = (props, context) => {
        componentRenders++;
        return {
            div: {
                // Text reactive attribute
                text: () => {
                    textReactiveCalls++;
                    return \`Text: \${context.getState('content.text', 'default text')}\`;
                },
            
            // Static attributes (should not affect reactive call counts)
            id: 'static-component-id',
            disabled: false,
            readonly: true,
            tabIndex: 0,
            placeholder: 'Static placeholder text',
            'data-static': 'static-value',
            'aria-hidden': false,
            role: 'button',
            type: 'text',
                
                // Children reactive attribute
                children: () => {
                    childrenReactiveCalls++;
                    const showChildren = context.getState('content.showChildren', true);
                    return showChildren ? [
                        {
                            span: {
                                text: \`Child: \${context.getState('content.childText', 'child default')}\`
                            }
                        },
                        {
                            p: {
                                text: \`Paragraph: \${context.getState('content.paragraphText', 'para default')}\`
                            }
                        }
                    ] : [];
                },
                
                // Style reactive attribute
                style: () => {
                    styleReactiveCalls++;
                    return {
                        color: context.getState('styles.color', 'black'),
                        fontSize: context.getState('styles.fontSize', '16px'),
                        backgroundColor: context.getState('styles.bgColor', 'white')
                    };
                },
                
                // ClassName reactive attribute
                className: () => {
                    classNameReactiveCalls++;
                    const theme = context.getState('ui.theme', 'light');
                    const active = context.getState('ui.active', false);
                    return \`container \${theme} \${active ? 'active' : 'inactive'}\`;
                },
                
                // Value reactive attribute (for form elements)
                value: () => {
                    valueReactiveCalls++;
                    return context.getState('form.inputValue', 'default value');
                },
                
                // Data attribute reactive
                'data-id': () => {
                    dataReactiveCalls++;
                    return \`item-\${context.getState('meta.id', '0')}\`;
                },
                
                // Aria attribute reactive
                'aria-label': () => {
                    ariaReactiveCalls++;
                    return \`Label: \${context.getState('accessibility.label', 'default label')}\`;
                },
                
                // Title attribute reactive
                title: () => {
                    titleReactiveCalls++;
                    return \`Tooltip: \${context.getState('meta.tooltip', 'default tooltip')}\`;
                },
                
                // Static HTML attributes as reactive functions
                disabled: () => {
                    disabledReactiveCalls++;
                    return context.getState('form.disabled', false);
                },
                
                readonly: () => {
                    readonlyReactiveCalls++;
                    return context.getState('form.readonly', false);
                },
                
                tabIndex: () => {
                    tabIndexReactiveCalls++;
                    return context.getState('ui.tabIndex', 0);
                },
                
                placeholder: () => {
                    placeholderReactiveCalls++;
                    return \`Enter \${context.getState('form.fieldType', 'text')}\`;
                },
                
                // Mixed: some static, some reactive
                id: 'static-component-id',
                'data-static': 'static-value',
                role: 'textbox'
            }
        };
    };
    
    const juris = new Juris({
        states: {
            content: {
                text: 'Initial Text',
                showChildren: true,
                childText: 'Initial Child',
                paragraphText: 'Initial Paragraph'
            },
            styles: {
                color: 'blue',
                fontSize: '18px',
                bgColor: 'lightgray'
            },
            ui: {
                theme: 'dark',
                active: false
            },
            form: {
                inputValue: 'initial input'
            },
            meta: {
                id: '123',
                tooltip: 'initial tooltip'
            },
            accessibility: {
                label: 'initial label'
            }
        },
        layout: { AllAttributesComponent: {} }
    });
    
    juris.registerComponent('AllAttributesComponent', AllAttributesComponent);
    
    // Initial render
    juris.render(document.createElement('div'));
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Verify initial state - all reactive functions called once
    testFramework.expect(componentRenders).toBe(1);
    testFramework.expect(textReactiveCalls).toBe(1);
    testFramework.expect(childrenReactiveCalls).toBe(1);
    testFramework.expect(styleReactiveCalls).toBe(1);
    testFramework.expect(classNameReactiveCalls).toBe(1);
    testFramework.expect(valueReactiveCalls).toBe(1);
    testFramework.expect(dataReactiveCalls).toBe(1);
    testFramework.expect(ariaReactiveCalls).toBe(1);
    testFramework.expect(titleReactiveCalls).toBe(1);
    testFramework.expect(disabledReactiveCalls).toBe(1);
    testFramework.expect(readonlyReactiveCalls).toBe(1);
    testFramework.expect(tabIndexReactiveCalls).toBe(1);
    testFramework.expect(placeholderReactiveCalls).toBe(1);
    
    // Test 1: Change text content - only text reactive should be called
    juris.setState('content.text', 'Updated Text');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No re-creation
    testFramework.expect(textReactiveCalls).toBe(2); // +1
    testFramework.expect(childrenReactiveCalls).toBe(1); // No change
    testFramework.expect(styleReactiveCalls).toBe(1); // No change
    testFramework.expect(classNameReactiveCalls).toBe(1); // No change
    testFramework.expect(valueReactiveCalls).toBe(1); // No change
    testFramework.expect(dataReactiveCalls).toBe(1); // No change
    testFramework.expect(ariaReactiveCalls).toBe(1); // No change
    testFramework.expect(titleReactiveCalls).toBe(1); // No change
    testFramework.expect(disabledReactiveCalls).toBe(1); // No change
    testFramework.expect(readonlyReactiveCalls).toBe(1); // No change
    testFramework.expect(tabIndexReactiveCalls).toBe(1); // No change
    testFramework.expect(placeholderReactiveCalls).toBe(1); // No change
    
    // Test 2: Change children visibility - only children reactive should be called
    juris.setState('content.showChildren', false);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No re-creation
    testFramework.expect(textReactiveCalls).toBe(2); // No change
    testFramework.expect(childrenReactiveCalls).toBe(2); // +1
    testFramework.expect(styleReactiveCalls).toBe(1); // No change
    testFramework.expect(classNameReactiveCalls).toBe(1); // No change
    testFramework.expect(valueReactiveCalls).toBe(1); // No change
    testFramework.expect(dataReactiveCalls).toBe(1); // No change
    testFramework.expect(ariaReactiveCalls).toBe(1); // No change
    testFramework.expect(titleReactiveCalls).toBe(1); // No change
    
    // Test 3: Change multiple style properties - only style reactive should be called
    juris.setState('styles.color', 'red');
    juris.setState('styles.fontSize', '20px');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No re-creation
    testFramework.expect(textReactiveCalls).toBe(2); // No change
    testFramework.expect(childrenReactiveCalls).toBe(2); // No change
    testFramework.expect(styleReactiveCalls).toBe(4); // +2 (one for each setState)
    testFramework.expect(classNameReactiveCalls).toBe(1); // No change
    testFramework.expect(valueReactiveCalls).toBe(1); // No change
    testFramework.expect(dataReactiveCalls).toBe(1); // No change
    testFramework.expect(ariaReactiveCalls).toBe(1); // No change
    testFramework.expect(titleReactiveCalls).toBe(1); // No change
    
    // Test 4: Change UI state - only className reactive should be called
    juris.setState('ui.theme', 'light');
    juris.setState('ui.active', true);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No re-creation
    testFramework.expect(textReactiveCalls).toBe(2); // No change
    testFramework.expect(childrenReactiveCalls).toBe(2); // No change
    testFramework.expect(styleReactiveCalls).toBe(4); // No change
    testFramework.expect(classNameReactiveCalls).toBe(3); // +2 (one for each setState)
    testFramework.expect(valueReactiveCalls).toBe(1); // No change
    testFramework.expect(dataReactiveCalls).toBe(1); // No change
    testFramework.expect(ariaReactiveCalls).toBe(1); // No change
    testFramework.expect(titleReactiveCalls).toBe(1); // No change
    
    // Test 5: Change form value - only value reactive should be called
    juris.setState('form.inputValue', 'updated input');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No re-creation
    testFramework.expect(textReactiveCalls).toBe(2); // No change
    testFramework.expect(childrenReactiveCalls).toBe(2); // No change
    testFramework.expect(styleReactiveCalls).toBe(4); // No change
    testFramework.expect(classNameReactiveCalls).toBe(3); // No change
    testFramework.expect(valueReactiveCalls).toBe(2); // +1
    testFramework.expect(dataReactiveCalls).toBe(1); // No change
    testFramework.expect(ariaReactiveCalls).toBe(1); // No change
    testFramework.expect(titleReactiveCalls).toBe(1); // No change
    
    // Test 6: Change form control attributes - only respective reactives should be called
    juris.setState('form.disabled', true);
    juris.setState('form.readonly', true);
    juris.setState('ui.tabIndex', 1);
    juris.setState('form.fieldType', 'password');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No re-creation
    testFramework.expect(textReactiveCalls).toBe(2); // No change
    testFramework.expect(childrenReactiveCalls).toBe(2); // No change
    testFramework.expect(styleReactiveCalls).toBe(4); // No change
    testFramework.expect(classNameReactiveCalls).toBe(3); // No change
    testFramework.expect(valueReactiveCalls).toBe(2); // No change
    testFramework.expect(dataReactiveCalls).toBe(2); // No change
    testFramework.expect(ariaReactiveCalls).toBe(2); // No change
    testFramework.expect(titleReactiveCalls).toBe(2); // No change
    testFramework.expect(disabledReactiveCalls).toBe(2); // +1 (form.disabled)
    testFramework.expect(readonlyReactiveCalls).toBe(2); // +1 (form.readonly)
    testFramework.expect(tabIndexReactiveCalls).toBe(2); // +1 (ui.tabIndex)
    testFramework.expect(placeholderReactiveCalls).toBe(2); // +1 (form.fieldType)
    
    // Test 7: Change meta attributes - only respective reactives should be called
    juris.setState('meta.id', '456');
    juris.setState('meta.tooltip', 'updated tooltip');
    juris.setState('accessibility.label', 'updated label');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(componentRenders).toBe(1); // No re-creation
    testFramework.expect(textReactiveCalls).toBe(2); // No change
    testFramework.expect(childrenReactiveCalls).toBe(2); // No change
    testFramework.expect(styleReactiveCalls).toBe(4); // No change
    testFramework.expect(classNameReactiveCalls).toBe(3); // No change
    testFramework.expect(valueReactiveCalls).toBe(2); // No change
    testFramework.expect(dataReactiveCalls).toBe(3); // +1 (meta.id)
    testFramework.expect(ariaReactiveCalls).toBe(3); // +1 (accessibility.label)
    testFramework.expect(titleReactiveCalls).toBe(3); // +1 (meta.tooltip)
    testFramework.expect(disabledReactiveCalls).toBe(2); // No change
    testFramework.expect(readonlyReactiveCalls).toBe(2); // No change
    testFramework.expect(tabIndexReactiveCalls).toBe(2); // No change
    testFramework.expect(placeholderReactiveCalls).toBe(2); // No change
    
    // Test 7: Change static attributes (should not affect any reactive calls)
    // Note: In real usage, static attributes can't be changed after creation,
    // but this tests that they don't interfere with reactive tracking
    const beforeStaticTest = {
        text: textReactiveCalls,
        children: childrenReactiveCalls,
        style: styleReactiveCalls,
        className: classNameReactiveCalls,
        value: valueReactiveCalls,
        data: dataReactiveCalls,
        aria: ariaReactiveCalls,
        title: titleReactiveCalls,
        disabled: disabledReactiveCalls,
        readonly: readonlyReactiveCalls,
        tabIndex: tabIndexReactiveCalls,
        placeholder: placeholderReactiveCalls
    };
    
    // Change some unrelated state that static attributes don't depend on
    juris.setState('unrelated.value', 'test');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Verify static attributes don't cause reactive calls
    testFramework.expect(textReactiveCalls).toBe(beforeStaticTest.text);
    testFramework.expect(childrenReactiveCalls).toBe(beforeStaticTest.children);
    testFramework.expect(styleReactiveCalls).toBe(beforeStaticTest.style);
    testFramework.expect(classNameReactiveCalls).toBe(beforeStaticTest.className);
    testFramework.expect(valueReactiveCalls).toBe(beforeStaticTest.value);
    testFramework.expect(dataReactiveCalls).toBe(beforeStaticTest.data);
    testFramework.expect(ariaReactiveCalls).toBe(beforeStaticTest.aria);
    testFramework.expect(titleReactiveCalls).toBe(beforeStaticTest.title);
    
    // Test 8: Reset - all reactive functions should be called for changed values
    const preResetCounts = {
        text: textReactiveCalls,
        children: childrenReactiveCalls,
        style: styleReactiveCalls,
        className: classNameReactiveCalls,
        value: valueReactiveCalls,
        data: dataReactiveCalls,
        aria: ariaReactiveCalls,
        title: titleReactiveCalls
    };
    
    juris.stateManager.reset();
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Verify component still only created once
    testFramework.expect(componentRenders).toBe(1);
    
    // Verify state reset to defaults
    testFramework.expect(juris.getState('content.text')).toBe('Initial Text');
    testFramework.expect(juris.getState('content.showChildren')).toBe(true);
    testFramework.expect(juris.getState('styles.color')).toBe('blue');
    testFramework.expect(juris.getState('ui.theme')).toBe('dark');
    testFramework.expect(juris.getState('ui.active')).toBe(false);
    testFramework.expect(juris.getState('form.inputValue')).toBe('initial input');
    testFramework.expect(juris.getState('meta.id')).toBe('123');
    testFramework.expect(juris.getState('meta.tooltip')).toBe('initial tooltip');
    testFramework.expect(juris.getState('form.disabled')).toBe(false);
    testFramework.expect(juris.getState('form.readonly')).toBe(false);
    testFramework.expect(juris.getState('ui.tabIndex')).toBe(0);
    testFramework.expect(juris.getState('form.fieldType')).toBe('text');
    
    // All reactive functions should have been called for reset (values changed)
    testFramework.expect(textReactiveCalls).toBeGreaterThan(preResetCounts.text);
    testFramework.expect(childrenReactiveCalls).toBeGreaterThan(preResetCounts.children);
    testFramework.expect(styleReactiveCalls).toBeGreaterThan(preResetCounts.style);
    testFramework.expect(classNameReactiveCalls).toBeGreaterThan(preResetCounts.className);
    testFramework.expect(valueReactiveCalls).toBeGreaterThan(preResetCounts.value);
    testFramework.expect(dataReactiveCalls).toBeGreaterThan(preResetCounts.data);
    testFramework.expect(ariaReactiveCalls).toBeGreaterThan(preResetCounts.aria);
    testFramework.expect(titleReactiveCalls).toBeGreaterThan(preResetCounts.title);
    testFramework.expect(disabledReactiveCalls).toBeGreaterThan(preResetCounts.disabled);
    testFramework.expect(readonlyReactiveCalls).toBeGreaterThan(preResetCounts.readonly);
    testFramework.expect(tabIndexReactiveCalls).toBeGreaterThan(preResetCounts.tabIndex);
    testFramework.expect(placeholderReactiveCalls).toBeGreaterThan(preResetCounts.placeholder);
    `);

// Basic objectToHtml() API Tests
testFramework.addTest('Basic objectToHtml() Conversion', 'objectToHtml API', async function() {
    const juris = new Juris();
    
    const element = juris.objectToHtml({
        div: {
            className: 'test-container',
            text: 'Hello World',
            id: 'test-div'
        }
    });
    
    testFramework.expect(element.tagName.toLowerCase()).toBe('div');
    testFramework.expect(element.className).toBe('test-container');
    testFramework.expect(element.textContent).toBe('Hello World');
    testFramework.expect(element.id).toBe('test-div');
}, `const juris = new Juris();

const element = juris.objectToHtml({
    div: {
        className: 'test-container',
        text: 'Hello World',
        id: 'test-div'
    }
});

testFramework.expect(element.tagName.toLowerCase()).toBe('div');
testFramework.expect(element.className).toBe('test-container');
testFramework.expect(element.textContent).toBe('Hello World');
testFramework.expect(element.id).toBe('test-div');`);

// Reactive objectToHtml() Tests
testFramework.addTest('objectToHtml() with Reactive Properties', 'objectToHtml API', async function() {
    const juris = new Juris();
    juris.setState('counter', 5);
    juris.setState('theme', 'dark');
    
    const element = juris.objectToHtml({
        div: {
            text: () => `Count: ${juris.getState('counter')}`,
            className: () => `theme-${juris.getState('theme')}`,
            style: () => ({
                color: juris.getState('theme') === 'dark' ? '#fff' : '#000'
            })
        }
    });
    
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.textContent).toBe('Count: 5');
    testFramework.expect(element.className).toBe('theme-dark');
    testFramework.expect(element.style.color).toBe('rgb(255, 255, 255)');
    
    // Update state and verify reactivity
    juris.setState('counter', 10);
    juris.setState('theme', 'light');
    
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.textContent).toBe('Count: 10');
    testFramework.expect(element.className).toBe('theme-light');
    testFramework.expect(element.style.color).toBe('rgb(0, 0, 0)');
}, `const juris = new Juris();
juris.setState('counter', 5);
juris.setState('theme', 'dark');

const element = juris.objectToHtml({
    div: {
        text: () => \`Count: \${juris.getState('counter')}\`,
        className: () => \`theme-\${juris.getState('theme')}\`,
        style: () => ({
            color: juris.getState('theme') === 'dark' ? '#fff' : '#000'
        })
    }
});

await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.textContent).toBe('Count: 5');
testFramework.expect(element.className).toBe('theme-dark');

juris.setState('counter', 10);
juris.setState('theme', 'light');

await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.textContent).toBe('Count: 10');
testFramework.expect(element.className).toBe('theme-light');`);

// Event Handling Tests
testFramework.addTest('objectToHtml() Event Handling', 'objectToHtml API', async function() {
    const juris = new Juris();
    juris.setState('clickCount', 0);
    
    const element = juris.objectToHtml({
        button: {
            text: () => `Clicked: ${juris.getState('clickCount')} times`,
            onclick: () => {
                const current = juris.getState('clickCount');
                juris.setState('clickCount', current + 1);
            }
        }
    });
    
    await new Promise(resolve => setTimeout(resolve, 10));
    testFramework.expect(element.textContent).toBe('Clicked: 0 times');
    
    // Simulate click
    element.click();
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.textContent).toBe('Clicked: 1 times');
    
    // Click again
    element.click();
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.textContent).toBe('Clicked: 2 times');
}, `const juris = new Juris();
juris.setState('clickCount', 0);

const element = juris.objectToHtml({
    button: {
        text: () => \`Clicked: \${juris.getState('clickCount')} times\`,
        onclick: () => {
            const current = juris.getState('clickCount');
            juris.setState('clickCount', current + 1);
        }
    }
});

await new Promise(resolve => setTimeout(resolve, 10));
testFramework.expect(element.textContent).toBe('Clicked: 0 times');

element.click();
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.textContent).toBe('Clicked: 1 times');`);

// Nested Children Tests
testFramework.addTest('objectToHtml() with Nested Children', 'objectToHtml API', async function() {
    const juris = new Juris();
    juris.setState('todos', [
        { id: 1, text: 'Buy milk', completed: false },
        { id: 2, text: 'Walk dog', completed: true }
    ]);
    
    const element = juris.objectToHtml({
        div: {
            className: 'todo-container',
            children: () => {
                const todos = juris.getState('todos', []);
                return [{
                    h2: { text: 'Todo List' }
                }, {
                    ul: {
                        children: () => todos.map(todo => ({
                            li: {
                                key: todo.id,
                                className: () => todo.completed ? 'completed' : 'pending',
                                children: [{
                                    span: { text: todo.text }
                                }, {
                                    button: {
                                        text: todo.completed ? 'Undo' : 'Complete',
                                        onclick: () => {
                                            const updatedTodos = todos.map(t => 
                                                t.id === todo.id ? { ...t, completed: !t.completed } : t
                                            );
                                            juris.setState('todos', updatedTodos);
                                        }
                                    }
                                }]
                            }
                        }))
                    }
                }];
            }
        }
    });
    
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.querySelector('h2').textContent).toBe('Todo List');
    testFramework.expect(element.querySelectorAll('li').length).toBe(2);
    testFramework.expect(element.querySelectorAll('li')[0].className).toBe('pending');
    testFramework.expect(element.querySelectorAll('li')[1].className).toBe('completed');
    
    // Click first todo button
    element.querySelectorAll('button')[0].click();
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.querySelectorAll('li')[0].className).toBe('completed');
}, `const juris = new Juris();
juris.setState('todos', [
    { id: 1, text: 'Buy milk', completed: false },
    { id: 2, text: 'Walk dog', completed: true }
]);

const element = juris.objectToHtml({
    div: {
        className: 'todo-container',
        children: () => {
            const todos = juris.getState('todos', []);
            return [{
                h2: { text: 'Todo List' }
            }, {
                ul: {
                    children: () => todos.map(todo => ({
                        li: {
                            key: todo.id,
                            className: () => todo.completed ? 'completed' : 'pending',
                            children: [{
                                span: { text: todo.text }
                            }, {
                                button: {
                                    text: todo.completed ? 'Undo' : 'Complete',
                                    onclick: () => {
                                        const updatedTodos = todos.map(t => 
                                            t.id === todo.id ? { ...t, completed: !t.completed } : t
                                        );
                                        juris.setState('todos', updatedTodos);
                                    }
                                }
                            }]
                        }
                    }))
                }
            }];
        }
    }
});

testFramework.expect(element.querySelector('h2').textContent).toBe('Todo List');
testFramework.expect(element.querySelectorAll('li').length).toBe(2);
testFramework.expect(element.querySelectorAll('li')[0].className).toBe('pending');`);

// Component Integration Tests
testFramework.addTest('objectToHtml() with Registered Components', 'objectToHtml API', async function() {
    const juris = new Juris();
    
    // Register a component
    juris.registerComponent('UserCard', (props) => ({
        div: {
            className: 'user-card',
            children: [{
                h3: { text: props.name }
            }, {
                p: { text: props.email }
            }, {
                span: { text: `Role: ${props.role || 'User'}` }
            }]
        }
    }));
    
    const element = juris.objectToHtml({
        div: {
            className: 'container',
            children: [{
                UserCard: {
                    name: 'John Doe',
                    email: 'john@example.com',
                    role: 'Admin'
                }
            }, {
                UserCard: {
                    name: 'Jane Smith',
                    email: 'jane@example.com'
                }
            }]
        }
    });
    
    testFramework.expect(element.querySelectorAll('.user-card').length).toBe(2);
    testFramework.expect(element.querySelectorAll('h3')[0].textContent).toBe('John Doe');
    testFramework.expect(element.querySelectorAll('h3')[1].textContent).toBe('Jane Smith');
    testFramework.expect(element.querySelectorAll('span')[0].textContent).toBe('Role: Admin');
    testFramework.expect(element.querySelectorAll('span')[1].textContent).toBe('Role: User');
}, `const juris = new Juris();

juris.registerComponent('UserCard', (props) => ({
    div: {
        className: 'user-card',
        children: [{
            h3: { text: props.name }
        }, {
            p: { text: props.email }
        }, {
            span: { text: \`Role: \${props.role || 'User'}\` }
        }]
    }
}));

const element = juris.objectToHtml({
    div: {
        className: 'container',
        children: [{
            UserCard: {
                name: 'John Doe',
                email: 'john@example.com',
                role: 'Admin'
            }
        }, {
            UserCard: {
                name: 'Jane Smith',
                email: 'jane@example.com'
            }
        }]
    }
});

testFramework.expect(element.querySelectorAll('.user-card').length).toBe(2);
testFramework.expect(element.querySelectorAll('h3')[0].textContent).toBe('John Doe');`);

// Form Input Tests
testFramework.addTest('objectToHtml() Form Input Handling', 'objectToHtml API', async function() {
    const juris = new Juris();
    juris.setState('username', '');
    juris.setState('email', '');
    
    const element = juris.objectToHtml({
        form: {
            children: [{
                div: {
                    children: [{
                        label: { text: 'Username:', htmlFor: 'username' }
                    }, {
                        input: {
                            id: 'username',
                            type: 'text',
                            value: () => juris.getState('username'),
                            oninput: (e) => juris.setState('username', e.target.value)
                        }
                    }]
                }
            }, {
                div: {
                    children: [{
                        label: { text: 'Email:', htmlFor: 'email' }
                    }, {
                        input: {
                            id: 'email',
                            type: 'email',
                            value: () => juris.getState('email'),
                            oninput: (e) => juris.setState('email', e.target.value)
                        }
                    }]
                }
            }, {
                div: {
                    text: () => {
                        const username = juris.getState('username');
                        const email = juris.getState('email');
                        return `Preview: ${username} (${email})`;
                    }
                }
            }]
        }
    });
    
    await new Promise(resolve => setTimeout(resolve, 10));
    
    const usernameInput = element.querySelector('#username');
    const emailInput = element.querySelector('#email');
    const preview = element.querySelector('div:last-child');
    
    testFramework.expect(preview.textContent).toBe('Preview:  ()');
    
    // Simulate input
    usernameInput.value = 'johndoe';
    usernameInput.dispatchEvent(new Event('input', { bubbles: true }));
    
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(juris.getState('username')).toBe('johndoe');
    testFramework.expect(preview.textContent).toBe('Preview: johndoe ()');
    
    emailInput.value = 'john@example.com';
    emailInput.dispatchEvent(new Event('input', { bubbles: true }));
    
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(juris.getState('email')).toBe('john@example.com');
    testFramework.expect(preview.textContent).toBe('Preview: johndoe (john@example.com)');
}, `const juris = new Juris();
juris.setState('username', '');
juris.setState('email', '');

const element = juris.objectToHtml({
    form: {
        children: [{
            input: {
                id: 'username',
                type: 'text',
                value: () => juris.getState('username'),
                oninput: (e) => juris.setState('username', e.target.value)
            }
        }, {
            div: {
                text: () => \`Preview: \${juris.getState('username')}\`
            }
        }]
    }
});

const usernameInput = element.querySelector('#username');
usernameInput.value = 'johndoe';
usernameInput.dispatchEvent(new Event('input', { bubbles: true }));

await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(juris.getState('username')).toBe('johndoe');`);

// Edge Cases and Error Handling
testFramework.addTest('objectToHtml() Edge Cases', 'objectToHtml API', async function() {
    const juris = new Juris();
    
    // Empty object
    const emptyElement = juris.objectToHtml({});
    testFramework.expect(emptyElement).toBe(null);
    
    // Invalid structure
    const invalidElement = juris.objectToHtml(null);
    testFramework.expect(invalidElement).toBe(null);
    
    // Array of elements
    const arrayElement = juris.objectToHtml([
        { div: { text: 'First' } },
        { span: { text: 'Second' } }
    ]);
    testFramework.expect(arrayElement.nodeType).toBe(Node.DOCUMENT_FRAGMENT_NODE);
    testFramework.expect(arrayElement.children.length).toBe(2);
    testFramework.expect(arrayElement.children[0].textContent).toBe('First');
    testFramework.expect(arrayElement.children[1].textContent).toBe('Second');
    
    // Element with no properties
    const basicElement = juris.objectToHtml({
        div: {}
    });
    testFramework.expect(basicElement.tagName.toLowerCase()).toBe('div');
    testFramework.expect(basicElement.textContent).toBe('');
}, `const juris = new Juris();

// Empty object
const emptyElement = juris.objectToHtml({});
testFramework.expect(emptyElement).toBe(null);

// Array of elements
const arrayElement = juris.objectToHtml([
    { div: { text: 'First' } },
    { span: { text: 'Second' } }
]);
testFramework.expect(arrayElement.nodeType).toBe(Node.DOCUMENT_FRAGMENT_NODE);
testFramework.expect(arrayElement.children.length).toBe(2);

// Basic element
const basicElement = juris.objectToHtml({
    div: {}
});
testFramework.expect(basicElement.tagName.toLowerCase()).toBe('div');`);

// Performance Test
testFramework.addTest('objectToHtml() Performance with Many Elements', 'objectToHtml API', async function() {
    const juris = new Juris();
    const itemCount = 100;
    
    juris.setState('items', Array.from({ length: itemCount }, (_, i) => ({
        id: i,
        name: `Item ${i}`,
        value: Math.random()
    })));
    
    const startTime = performance.now();
    
    const element = juris.objectToHtml({
        div: {
            className: 'performance-test',
            children: () => {
                const items = juris.getState('items', []);
                return items.map(item => ({
                    div: {
                        key: item.id,
                        className: 'item',
                        children: [{
                            span: { text: item.name }
                        }, {
                            span: { text: item.value.toFixed(2) }
                        }]
                    }
                }));
            }
        }
    });
    
    const endTime = performance.now();
    const renderTime = endTime - startTime;
    
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.querySelectorAll('.item').length).toBe(itemCount);
    testFramework.expect(renderTime).toBeLessThan(50); // Should render 100 items in < 50ms
    
    console.log(`Rendered ${itemCount} items in ${renderTime.toFixed(2)}ms`);
}, `const juris = new Juris();
const itemCount = 100;

juris.setState('items', Array.from({ length: itemCount }, (_, i) => ({
    id: i,
    name: \`Item \${i}\`,
    value: Math.random()
})));

const startTime = performance.now();

const element = juris.objectToHtml({
    div: {
        className: 'performance-test',
        children: () => {
            const items = juris.getState('items', []);
            return items.map(item => ({
                div: {
                    key: item.id,
                    className: 'item',
                    children: [{
                        span: { text: item.name }
                    }, {
                        span: { text: item.value.toFixed(2) }
                    }]
                }
            }));
        }
    }
});

const endTime = performance.now();
const renderTime = endTime - startTime;

testFramework.expect(element.querySelectorAll('.item').length).toBe(itemCount);
testFramework.expect(renderTime).toBeLessThan(50);`);

// Memory Leak Test
testFramework.addTest('objectToHtml() Memory Management', 'objectToHtml API', async function() {
    const juris = new Juris();
    juris.setState('dynamic', 'initial');
    
    const element = juris.objectToHtml({
        div: {
            text: () => juris.getState('dynamic'),
            onclick: () => juris.setState('dynamic', 'clicked')
        }
    });
    
    // Add to DOM to ensure subscriptions are active
    document.body.appendChild(element);
    
    // Verify reactivity works
    juris.setState('dynamic', 'updated');
    await new Promise(resolve => setTimeout(resolve, 10));
    testFramework.expect(element.textContent).toBe('updated');
    
    // Test cleanup
    juris.domRenderer.cleanup(element);
    document.body.removeChild(element);
    
    // After cleanup, state changes shouldn't affect the element
    juris.setState('dynamic', 'should not update');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Element should still have old value since it's cleaned up
    testFramework.expect(element.textContent).toBe('updated');
}, `const juris = new Juris();
juris.setState('dynamic', 'initial');

const element = juris.objectToHtml({
    div: {
        text: () => juris.getState('dynamic'),
        onclick: () => juris.setState('dynamic', 'clicked')
    }
});

document.body.appendChild(element);

juris.setState('dynamic', 'updated');
await new Promise(resolve => setTimeout(resolve, 10));
testFramework.expect(element.textContent).toBe('updated');

// Test cleanup
juris.domRenderer.cleanup(element);
document.body.removeChild(element);

juris.setState('dynamic', 'should not update');
await new Promise(resolve => setTimeout(resolve, 10));

// Element should still have old value since it's cleaned up
testFramework.expect(element.textContent).toBe('updated');`);


testFramework.addTest('StepRenderer Component Injection', 'Control Flow Components', async function() {
    const juris = new Juris({
        components: {
            StepRenderer: (props, context) => ({
                render: () => {
                    const { getState } = context;
                    const currentStep = getState('wizard.currentStep', 1);
                    const totalSteps = props.totalSteps || 4;
                    const steps = props.steps || {};

                    return {
                        div: {
                            className: 'step-wizard',
                            children: [
                                {
                                    div: {
                                        className: 'step-indicator',
                                        children: () => {
                                            const current = getState('wizard.currentStep', 1);
                                            return Array.from({ length: totalSteps }, (_, i) => {
                                                const stepNum = i + 1;
                                                let className = 'step';
                                                if (stepNum < current) className += ' completed';
                                                if (stepNum === current) className += ' active';
                                                return {
                                                    div: {
                                                        key: `step-${stepNum}`,
                                                        className,
                                                        text: `Step ${stepNum}`
                                                    }
                                                };
                                            });
                                        }
                                    }
                                },
                                {
                                    div: {
                                        className: 'step-content',
                                        children: () => {
                                            const step = getState('wizard.currentStep', 1);
                                            return steps[step] ? [steps[step]] : [{ div: { text: `Step ${step} content` } }];
                                        }
                                    }
                                }
                            ]
                        }
                    };
                }
            }),
            Card: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'card',
                        children: [
                            props.title ? { h3: { text: props.title } } : null,
                            ...(Array.isArray(props.children) ? props.children : [props.children])
                        ].filter(Boolean)
                    }
                })
            })
        }
    });
    
    juris.setState('wizard.currentStep', 1);
    
    const element = juris.objectToHtml({
        StepRenderer: {
            totalSteps: 3,
            steps: {
                1: { Card: { title: 'Step 1', children: { div: { text: 'First step content' } } } },
                2: { Card: { title: 'Step 2', children: { div: { text: 'Second step content' } } } },
                3: { Card: { title: 'Step 3', children: { div: { text: 'Third step content' } } } }
            }
        }
    });
    
    document.body.appendChild(element);
    
    // Test initial state
    testFramework.expect(element.querySelector('.step.active').textContent).toBe('Step 1');
    testFramework.expect(element.querySelector('.step-content').textContent).toContain('First step content');
    
    // Test step navigation
    juris.setState('wizard.currentStep', 2);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.querySelector('.step.active').textContent).toBe('Step 2');
    testFramework.expect(element.querySelector('.step-content').textContent).toContain('Second step content');
    testFramework.expect(element.querySelector('.step.completed')).toBeTruthy();
    
    // Test final step
    juris.setState('wizard.currentStep', 3);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.querySelector('.step.active').textContent).toBe('Step 3');
    testFramework.expect(element.querySelector('.step-content').textContent).toContain('Third step content');
    testFramework.expect(element.querySelectorAll('.step.completed').length).toBe(2);
    
    // Cleanup
    juris.domRenderer.cleanup(element);
    document.body.removeChild(element);
}, `const juris = new Juris({
    components: {
        StepRenderer: (props, context) => ({
            render: () => ({
                div: {
                    children: [
                        {
                            div: {
                                className: 'step-indicator',
                                children: () => {
                                    const current = context.getState('wizard.currentStep', 1);
                                    return Array.from({ length: props.totalSteps }, (_, i) => ({
                                        div: {
                                            className: \`step \${i + 1 === current ? 'active' : ''}\`,
                                            text: \`Step \${i + 1}\`
                                        }
                                    }));
                                }
                            }
                        },
                        {
                            div: {
                                children: () => {
                                    const step = context.getState('wizard.currentStep', 1);
                                    return [props.steps[step]];
                                }
                            }
                        }
                    ]
                }
            })
        })
    }
});

const element = juris.objectToHtml({
    StepRenderer: {
        totalSteps: 3,
        steps: {
            1: { div: { text: 'Step 1 content' } },
            2: { div: { text: 'Step 2 content' } },
            3: { div: { text: 'Step 3 content' } }
        }
    }
});

juris.setState('wizard.currentStep', 2);
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.querySelector('.step.active').textContent).toBe('Step 2');`);


testFramework.addTest('ConditionalRenderer Component Injection', 'Control Flow Components', async function() {
    const juris = new Juris({
        components: {
            ConditionalRenderer: (props, context) => ({
                render: () => ({
                    div: {
                        children: () => {
                            const condition = typeof props.condition === 'function'
                                ? props.condition()
                                : props.condition;

                            if (condition) {
                                return props.whenTrue ?
                                    (Array.isArray(props.whenTrue) ? props.whenTrue : [props.whenTrue]) :
                                    [];
                            }

                            return props.whenFalse ?
                                (Array.isArray(props.whenFalse) ? props.whenFalse : [props.whenFalse]) :
                                [];
                        }
                    }
                })
            }),
            SuccessMessage: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'success',
                        text: props.text || 'Success!'
                    }
                })
            }),
            ErrorMessage: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'error',
                        text: props.text || 'Error!'
                    }
                })
            })
        }
    });
    
    juris.setState('isLoggedIn', false);
    
    const element = juris.objectToHtml({
        ConditionalRenderer: {
            condition: () => juris.getState('isLoggedIn', false),
            whenTrue: { SuccessMessage: { text: 'Welcome back!' } },
            whenFalse: { ErrorMessage: { text: 'Please log in' } }
        }
    });
    
    document.body.appendChild(element);
    
    // Test initial false condition
    testFramework.expect(element.querySelector('.error')).toBeTruthy();
    testFramework.expect(element.textContent).toContain('Please log in');
    testFramework.expect(element.querySelector('.success')).toBeFalsy();
    
    // Test condition change to true
    juris.setState('isLoggedIn', true);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.querySelector('.success')).toBeTruthy();
    testFramework.expect(element.textContent).toContain('Welcome back!');
    testFramework.expect(element.querySelector('.error')).toBeFalsy();
    
    // Test condition change back to false
    juris.setState('isLoggedIn', false);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.querySelector('.error')).toBeTruthy();
    testFramework.expect(element.textContent).toContain('Please log in');
    testFramework.expect(element.querySelector('.success')).toBeFalsy();
    
    // Test static condition (non-function)
    const staticElement = juris.objectToHtml({
        ConditionalRenderer: {
            condition: true,
            whenTrue: { div: { text: 'Static true condition' } },
            whenFalse: { div: { text: 'Static false condition' } }
        }
    });
    
    document.body.appendChild(staticElement);
    testFramework.expect(staticElement.textContent).toContain('Static true condition');
    
    // Cleanup
    juris.domRenderer.cleanup(element);
    juris.domRenderer.cleanup(staticElement);
    document.body.removeChild(element);
    document.body.removeChild(staticElement);
}, `const juris = new Juris({
    components: {
        ConditionalRenderer: (props, context) => ({
            render: () => ({
                div: {
                    children: () => {
                        const condition = typeof props.condition === 'function'
                            ? props.condition()
                            : props.condition;

                        if (condition) {
                            return props.whenTrue ? [props.whenTrue] : [];
                        }
                        return props.whenFalse ? [props.whenFalse] : [];
                    }
                }
            })
        })
    }
});

juris.setState('isLoggedIn', false);

const element = juris.objectToHtml({
    ConditionalRenderer: {
        condition: () => juris.getState('isLoggedIn', false),
        whenTrue: { div: { text: 'Welcome!' } },
        whenFalse: { div: { text: 'Please log in' } }
    }
});

// Test condition changes
juris.setState('isLoggedIn', true);
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.textContent).toContain('Welcome!');`);

testFramework.addTest('SwitchRenderer Component Injection', 'Control Flow Components', async function() {
    const juris = new Juris({
        components: {
            SwitchRenderer: (props, context) => ({
                render: () => ({
                    div: {
                        children: () => {
                            const value = typeof props.value === 'function'
                                ? props.value()
                                : props.value;

                            // Look for exact match first
                            if (props[value]) {
                                const match = props[value];
                                return Array.isArray(match) ? match : [match];
                            }

                            // Fallback to default
                            if (props.default) {
                                return Array.isArray(props.default) ? props.default : [props.default];
                            }

                            return [];
                        }
                    }
                })
            }),
            AdminPanel: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'admin-panel',
                        text: 'Admin Panel - Secret content!'
                    }
                })
            }),
            UserDashboard: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'user-dashboard',
                        text: 'User Dashboard - Standard features'
                    }
                })
            }),
            GuestWelcome: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'guest-welcome',
                        text: 'Welcome Guest - Please create an account'
                    }
                })
            })
        }
    });
    
    juris.setState('userRole', 'guest');
    
    const element = juris.objectToHtml({
        SwitchRenderer: {
            value: () => juris.getState('userRole', 'guest'),
            admin: { AdminPanel: {} },
            user: { UserDashboard: {} },
            guest: { GuestWelcome: {} },
            default: { div: { text: 'Unknown role' } }
        }
    });
    
    document.body.appendChild(element);
    
    // Test initial guest role
    testFramework.expect(element.querySelector('.guest-welcome')).toBeTruthy();
    testFramework.expect(element.textContent).toContain('Welcome Guest');
    testFramework.expect(element.querySelector('.admin-panel')).toBeFalsy();
    testFramework.expect(element.querySelector('.user-dashboard')).toBeFalsy();
    
    // Test switch to user role
    juris.setState('userRole', 'user');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.querySelector('.user-dashboard')).toBeTruthy();
    testFramework.expect(element.textContent).toContain('User Dashboard');
    testFramework.expect(element.querySelector('.guest-welcome')).toBeFalsy();
    testFramework.expect(element.querySelector('.admin-panel')).toBeFalsy();
    
    // Test switch to admin role
    juris.setState('userRole', 'admin');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.querySelector('.admin-panel')).toBeTruthy();
    testFramework.expect(element.textContent).toContain('Admin Panel');
    testFramework.expect(element.querySelector('.user-dashboard')).toBeFalsy();
    testFramework.expect(element.querySelector('.guest-welcome')).toBeFalsy();
    
    // Test unknown role (should use default)
    juris.setState('userRole', 'unknown');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.textContent).toContain('Unknown role');
    testFramework.expect(element.querySelector('.admin-panel')).toBeFalsy();
    testFramework.expect(element.querySelector('.user-dashboard')).toBeFalsy();
    testFramework.expect(element.querySelector('.guest-welcome')).toBeFalsy();
    
    // Test static value (non-function)
    const staticElement = juris.objectToHtml({
        SwitchRenderer: {
            value: 'admin',
            admin: { div: { text: 'Static admin content' } },
            user: { div: { text: 'Static user content' } }
        }
    });
    
    document.body.appendChild(staticElement);
    testFramework.expect(staticElement.textContent).toContain('Static admin content');
    
    // Cleanup
    juris.domRenderer.cleanup(element);
    juris.domRenderer.cleanup(staticElement);
    document.body.removeChild(element);
    document.body.removeChild(staticElement);
}, `const juris = new Juris({
    components: {
        SwitchRenderer: (props, context) => ({
            render: () => ({
                div: {
                    children: () => {
                        const value = typeof props.value === 'function'
                            ? props.value()
                            : props.value;

                        if (props[value]) {
                            const match = props[value];
                            return Array.isArray(match) ? match : [match];
                        }

                        if (props.default) {
                            return Array.isArray(props.default) ? props.default : [props.default];
                        }

                        return [];
                    }
                }
            })
        })
    }
});

juris.setState('userRole', 'guest');

const element = juris.objectToHtml({
    SwitchRenderer: {
        value: () => juris.getState('userRole', 'guest'),
        admin: { div: { text: 'Admin Panel' } },
        user: { div: { text: 'User Dashboard' } },
        guest: { div: { text: 'Welcome Guest' } },
        default: { div: { text: 'Unknown role' } }
    }
});

// Test role switching
juris.setState('userRole', 'admin');
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.textContent).toContain('Admin Panel');`);

testFramework.addTest('ListRenderer Component Injection', 'Control Flow Components', async function() {
    const juris = new Juris({
        components: {
            ListRenderer: (props, context) => ({
                render: () => ({
                    div: {
                        className: props.containerClass || '',
                        children: () => {
                            const items = typeof props.items === 'function'
                                ? props.items()
                                : props.items || [];

                            if (items.length === 0) {
                                return props.empty ?
                                    (Array.isArray(props.empty) ? props.empty : [props.empty]) :
                                    [];
                            }

                            if (props.itemComponent && props.itemProps) {
                                return items.map((item, index) => ({
                                    [props.itemComponent]: {
                                        key: item.id || index,
                                        ...props.itemProps(item, index)
                                    }
                                }));
                            }

                            return items.map((item, index) => ({
                                div: {
                                    key: item.id || index,
                                    className: 'list-item',
                                    text: typeof item === 'object' ? JSON.stringify(item) : item
                                }
                            }));
                        }
                    }
                })
            }),
            TodoItem: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'todo-item',
                        children: [
                            { span: { text: props.item.text } },
                            { 
                                button: { 
                                    text: 'Remove',
                                    onclick: () => props.onRemove(props.item.id),
                                    className: 'remove-btn'
                                } 
                            }
                        ]
                    }
                })
            }),
            EmptyState: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'empty-state',
                        text: 'No items found'
                    }
                })
            })
        }
    });
    
    juris.setState('todos', []);
    
    // Test with empty list
    const element = juris.objectToHtml({
        ListRenderer: {
            containerClass: 'todo-list',
            items: () => juris.getState('todos', []),
            empty: { EmptyState: {} }
        }
    });
    
    document.body.appendChild(element);
    
    // Test empty state
    testFramework.expect(element.querySelector('.empty-state')).toBeTruthy();
    testFramework.expect(element.textContent).toContain('No items found');
    testFramework.expect(element.querySelector('.list-item')).toBeFalsy();
    
    // Add items to the list
    juris.setState('todos', [
        { id: 1, text: 'First todo' },
        { id: 2, text: 'Second todo' }
    ]);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Test with items (default rendering)
    testFramework.expect(element.querySelector('.empty-state')).toBeFalsy();
    testFramework.expect(element.querySelectorAll('.list-item').length).toBe(2);
    testFramework.expect(element.textContent).toContain('First todo');
    testFramework.expect(element.textContent).toContain('Second todo');
    
    // Test with custom item component
    const customElement = juris.objectToHtml({
        ListRenderer: {
            containerClass: 'custom-todo-list',
            items: () => juris.getState('todos', []),
            itemComponent: 'TodoItem',
            itemProps: (item, index) => ({
                item: item,
                onRemove: (id) => {
                    const todos = juris.getState('todos', []);
                    juris.setState('todos', todos.filter(todo => todo.id !== id));
                }
            }),
            empty: { EmptyState: {} }
        }
    });
    
    document.body.appendChild(customElement);
    
    // Test custom component rendering
    testFramework.expect(customElement.querySelectorAll('.todo-item').length).toBe(2);
    testFramework.expect(customElement.querySelectorAll('.remove-btn').length).toBe(2);
    testFramework.expect(customElement.textContent).toContain('First todo');
    testFramework.expect(customElement.textContent).toContain('Remove');
    
    // Test item removal through custom component
    const removeButton = customElement.querySelector('.remove-btn');
    removeButton.click();
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(customElement.querySelectorAll('.todo-item').length).toBe(1);
    
    // Test static items array
    const staticElement = juris.objectToHtml({
        ListRenderer: {
            items: ['Static item 1', 'Static item 2'],
            containerClass: 'static-list'
        }
    });
    
    document.body.appendChild(staticElement);
    testFramework.expect(staticElement.querySelectorAll('.list-item').length).toBe(2);
    testFramework.expect(staticElement.textContent).toContain('Static item 1');
    
    // Cleanup
    juris.domRenderer.cleanup(element);
    juris.domRenderer.cleanup(customElement);
    juris.domRenderer.cleanup(staticElement);
    document.body.removeChild(element);
    document.body.removeChild(customElement);
    document.body.removeChild(staticElement);
}, `const juris = new Juris({
    components: {
        ListRenderer: (props, context) => ({
            render: () => ({
                div: {
                    children: () => {
                        const items = typeof props.items === 'function'
                            ? props.items()
                            : props.items || [];

                        if (items.length === 0) {
                            return props.empty ? [props.empty] : [];
                        }

                        if (props.itemComponent && props.itemProps) {
                            return items.map((item, index) => ({
                                [props.itemComponent]: {
                                    key: item.id || index,
                                    ...props.itemProps(item, index)
                                }
                            }));
                        }

                        return items.map((item, index) => ({
                            div: {
                                key: item.id || index,
                                className: 'list-item',
                                text: typeof item === 'object' ? JSON.stringify(item) : item
                            }
                        }));
                    }
                }
            })
        })
    }
});

juris.setState('todos', []);

const element = juris.objectToHtml({
    ListRenderer: {
        items: () => juris.getState('todos', []),
        empty: { div: { text: 'No items' } }
    }
});

// Test adding items
juris.setState('todos', [{ id: 1, text: 'First todo' }]);
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.querySelectorAll('.list-item').length).toBe(1);`);


testFramework.addTest('AsyncRenderer Component Injection', 'Control Flow Components', async function() {
    const juris = new Juris({
        components: {
            AsyncRenderer: (props, context) => ({
                render: () => ({
                    div: {
                        children: () => {
                            const loading = typeof props.loading === 'function'
                                ? props.loading()
                                : props.loading;
                            const error = typeof props.error === 'function'
                                ? props.error()
                                : props.error;
                            const data = typeof props.data === 'function'
                                ? props.data()
                                : props.data;

                            if (loading) {
                                return props.loadingComponent ?
                                    (Array.isArray(props.loadingComponent) ? props.loadingComponent : [props.loadingComponent]) :
                                    [{ div: { className: 'loading', text: 'Loading...' } }];
                            }

                            if (error) {
                                return props.errorComponent ?
                                    (Array.isArray(props.errorComponent) ? props.errorComponent : [props.errorComponent]) :
                                    [{ div: { className: 'error', text: `Error: ${error}` } }];
                            }

                            if (data !== null && data !== undefined) {
                                return props.successComponent ?
                                    (Array.isArray(props.successComponent) ? props.successComponent : [props.successComponent]) :
                                    [{ div: { text: 'Data loaded successfully' } }];
                            }

                            return props.emptyComponent ?
                                (Array.isArray(props.emptyComponent) ? props.emptyComponent : [props.emptyComponent]) :
                                [];
                        }
                    }
                })
            }),
            LoadingSpinner: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'loading-spinner',
                        text: props.text || 'Loading data...'
                    }
                })
            }),
            ErrorMessage: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'error-message',
                        text: props.text || 'An error occurred'
                    }
                })
            }),
            DataDisplay: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'data-display',
                        text: () => {
                            const data = typeof props.data === 'function' ? props.data() : props.data;
                            return `Data: ${JSON.stringify(data)}`;
                        }
                    }
                })
            }),
            EmptyState: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'empty-state',
                        text: 'No data available'
                    }
                })
            })
        }
    });
    
    // Initialize async state
    juris.setState('async.loading', false);
    juris.setState('async.error', null);
    juris.setState('async.data', null);
    
    const element = juris.objectToHtml({
        AsyncRenderer: {
            loading: () => juris.getState('async.loading', false),
            error: () => juris.getState('async.error', null),
            data: () => juris.getState('async.data', null),
            loadingComponent: { LoadingSpinner: { text: 'Fetching data...' } },
            errorComponent: { ErrorMessage: { text: () => juris.getState('async.error', '') } },
            successComponent: { 
                DataDisplay: { 
                    data: () => juris.getState('async.data', null)
                } 
            },
            emptyComponent: { EmptyState: {} }
        }
    });
    
    document.body.appendChild(element);
    
    // Test initial empty state
    testFramework.expect(element.querySelector('.empty-state')).toBeTruthy();
    testFramework.expect(element.textContent).toContain('No data available');
    testFramework.expect(element.querySelector('.loading-spinner')).toBeFalsy();
    testFramework.expect(element.querySelector('.error-message')).toBeFalsy();
    testFramework.expect(element.querySelector('.data-display')).toBeFalsy();
    
    // Test loading state
    juris.setState('async.loading', true);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.querySelector('.loading-spinner')).toBeTruthy();
    testFramework.expect(element.textContent).toContain('Fetching data...');
    testFramework.expect(element.querySelector('.empty-state')).toBeFalsy();
    testFramework.expect(element.querySelector('.error-message')).toBeFalsy();
    testFramework.expect(element.querySelector('.data-display')).toBeFalsy();
    
    // Test error state
    juris.setState('async.loading', false);
    juris.setState('async.error', 'Network connection failed');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.querySelector('.error-message')).toBeTruthy();
    testFramework.expect(element.textContent).toContain('Network connection failed');
    testFramework.expect(element.querySelector('.loading-spinner')).toBeFalsy();
    testFramework.expect(element.querySelector('.empty-state')).toBeFalsy();
    testFramework.expect(element.querySelector('.data-display')).toBeFalsy();
    
    // Test success state with data
    juris.setState('async.error', null);
    juris.setState('async.data', { id: 1, name: 'Test Data', status: 'active' });
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.querySelector('.data-display')).toBeTruthy();
    testFramework.expect(element.textContent).toContain('Test Data');
    testFramework.expect(element.querySelector('.loading-spinner')).toBeFalsy();
    testFramework.expect(element.querySelector('.error-message')).toBeFalsy();
    testFramework.expect(element.querySelector('.empty-state')).toBeFalsy();
    
    // Test priority: loading should override everything
    juris.setState('async.loading', true);
    juris.setState('async.error', 'Some error');
    juris.setState('async.data', { test: 'data' });
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.querySelector('.loading-spinner')).toBeTruthy();
    testFramework.expect(element.querySelector('.error-message')).toBeFalsy();
    testFramework.expect(element.querySelector('.data-display')).toBeFalsy();
    
    // Test static props (non-functions)
    const staticElement = juris.objectToHtml({
        AsyncRenderer: {
            loading: false,
            error: null,
            data: { static: 'test' },
            successComponent: { div: { text: 'Static success', className: 'static-success' } }
        }
    });
    
    document.body.appendChild(staticElement);
    testFramework.expect(staticElement.querySelector('.static-success')).toBeTruthy();
    testFramework.expect(staticElement.textContent).toContain('Static success');
    
    // Cleanup
    juris.domRenderer.cleanup(element);
    juris.domRenderer.cleanup(staticElement);
    document.body.removeChild(element);
    document.body.removeChild(staticElement);
}, `const juris = new Juris({
    components: {
        AsyncRenderer: (props, context) => ({
            render: () => ({
                div: {
                    children: () => {
                        const loading = typeof props.loading === 'function'
                            ? props.loading()
                            : props.loading;
                        const error = typeof props.error === 'function'
                            ? props.error()
                            : props.error;
                        const data = typeof props.data === 'function'
                            ? props.data()
                            : props.data;

                        if (loading) {
                            return props.loadingComponent ? [props.loadingComponent] : 
                                   [{ div: { className: 'loading', text: 'Loading...' } }];
                        }

                        if (error) {
                            return props.errorComponent ? [props.errorComponent] : 
                                   [{ div: { className: 'error', text: \`Error: \${error}\` } }];
                        }

                        if (data !== null && data !== undefined) {
                            return props.successComponent ? [props.successComponent] : 
                                   [{ div: { text: 'Data loaded successfully' } }];
                        }

                        return props.emptyComponent ? [props.emptyComponent] : [];
                    }
                }
            })
        })
    }
});

juris.setState('async.loading', true);

const element = juris.objectToHtml({
    AsyncRenderer: {
        loading: () => juris.getState('async.loading', false),
        error: () => juris.getState('async.error', null),
        data: () => juris.getState('async.data', null),
        loadingComponent: { div: { text: 'Loading...', className: 'loading' } },
        errorComponent: { div: { text: 'Error occurred', className: 'error' } },
        successComponent: { div: { text: 'Success!', className: 'success' } }
    }
});

// Test state transitions
juris.setState('async.loading', false);
juris.setState('async.data', { result: 'success' });
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.querySelector('.success')).toBeTruthy();`);

testFramework.addTest('TabRenderer Component Injection', 'Control Flow Components', async function() {
    const juris = new Juris({
        components: {
            TabRenderer: (props, context) => ({
                render: () => {
                    const tabs = props.tabs || {};
                    const tabNames = Object.keys(tabs);

                    const tabBar = {
                        div: {
                            className: 'tabs',
                            children: () => {
                                const activeTab = typeof props.activeTab === 'function' ? props.activeTab() : props.activeTab;
                                return tabNames.map(tabName => ({
                                    div: {
                                        className: `tab ${activeTab === tabName ? 'active' : ''}`,
                                        text: props.tabLabels ? props.tabLabels[tabName] || tabName : tabName,
                                        onclick: () => props.onTabChange && props.onTabChange(tabName)
                                    }
                                }));
                            }
                        }
                    };

                    const activeContent = {
                        div: {
                            children: () => {
                                const activeTab = typeof props.activeTab === 'function' ? props.activeTab() : props.activeTab;
                                return tabs[activeTab] ? [tabs[activeTab]] : [{ div: { text: 'No content' } }];
                            }
                        }
                    };

                    return {
                        div: {
                            children: [
                                tabBar,
                                activeContent
                            ]
                        }
                    };
                }
            }),
            ProfileTab: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'profile-tab',
                        children: [
                            { h3: { text: 'User Profile' } },
                            { div: { text: 'Name: John Doe' } },
                            { div: { text: 'Email: john@example.com' } }
                        ]
                    }
                })
            }),
            SettingsTab: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'settings-tab',
                        children: [
                            { h3: { text: 'Settings' } },
                            { div: { text: 'Theme: Dark Mode' } },
                            { div: { text: 'Language: English' } }
                        ]
                    }
                })
            }),
            BillingTab: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'billing-tab',
                        children: [
                            { h3: { text: 'Billing Information' } },
                            { div: { text: 'Plan: Premium' } },
                            { div: { text: 'Next billing: Jan 15, 2024' } }
                        ]
                    }
                })
            })
        }
    });
    
    juris.setState('activeTab', 'profile');
    
    const element = juris.objectToHtml({
        TabRenderer: {
            activeTab: () => juris.getState('activeTab', 'profile'),
            tabs: {
                profile: { ProfileTab: {} },
                settings: { SettingsTab: {} },
                billing: { BillingTab: {} }
            },
            tabLabels: {
                profile: 'My Profile',
                settings: 'App Settings',
                billing: 'Billing Info'
            },
            onTabChange: (tabName) => {
                juris.setState('activeTab', tabName);
            }
        }
    });
    
    document.body.appendChild(element);
    
    // Test initial tab state
    testFramework.expect(element.querySelector('.tab.active')).toBeTruthy();
    testFramework.expect(element.querySelector('.tab.active').textContent).toBe('My Profile');
    testFramework.expect(element.querySelector('.profile-tab')).toBeTruthy();
    testFramework.expect(element.textContent).toContain('User Profile');
    testFramework.expect(element.querySelector('.settings-tab')).toBeFalsy();
    testFramework.expect(element.querySelector('.billing-tab')).toBeFalsy();
    
    // Test tab switching to settings
    juris.setState('activeTab', 'settings');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.querySelector('.tab.active').textContent).toBe('App Settings');
    testFramework.expect(element.querySelector('.settings-tab')).toBeTruthy();
    testFramework.expect(element.textContent).toContain('Theme: Dark Mode');
    testFramework.expect(element.querySelector('.profile-tab')).toBeFalsy();
    testFramework.expect(element.querySelector('.billing-tab')).toBeFalsy();
    
    // Test tab switching to billing
    juris.setState('activeTab', 'billing');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.querySelector('.tab.active').textContent).toBe('Billing Info');
    testFramework.expect(element.querySelector('.billing-tab')).toBeTruthy();
    testFramework.expect(element.textContent).toContain('Premium');
    testFramework.expect(element.querySelector('.profile-tab')).toBeFalsy();
    testFramework.expect(element.querySelector('.settings-tab')).toBeFalsy();
    
    // Test click handlers - Set to profile first and wait for render
    juris.setState('activeTab', 'profile');
    await new Promise(resolve => setTimeout(resolve, 20));
    
    // Verify we're on profile tab
    testFramework.expect(juris.getState('activeTab')).toBe('profile');
    
    // Get the settings tab button after render
    const settingsTabButton = Array.from(element.querySelectorAll('.tab')).find(tab => 
        tab.textContent === 'App Settings'
    );
    
    // Click settings tab and wait
    settingsTabButton.click();
    await new Promise(resolve => setTimeout(resolve, 20));
    
    testFramework.expect(juris.getState('activeTab')).toBe('settings');
    testFramework.expect(element.querySelector('.settings-tab')).toBeTruthy();
    
    // Test static activeTab (non-function)
    const staticElement = juris.objectToHtml({
        TabRenderer: {
            activeTab: 'settings',
            tabs: {
                profile: { div: { text: 'Static Profile Content', className: 'static-profile' } },
                settings: { div: { text: 'Static Settings Content', className: 'static-settings' } }
            }
        }
    });
    
    document.body.appendChild(staticElement);
    testFramework.expect(staticElement.querySelector('.tab.active').textContent).toBe('settings');
    testFramework.expect(staticElement.querySelector('.static-settings')).toBeTruthy();
    testFramework.expect(staticElement.textContent).toContain('Static Settings Content');
    
    // Test invalid tab (should show no content)
    const invalidTabElement = juris.objectToHtml({
        TabRenderer: {
            activeTab: 'nonexistent',
            tabs: {
                profile: { div: { text: 'Profile' } }
            }
        }
    });
    
    document.body.appendChild(invalidTabElement);
    testFramework.expect(invalidTabElement.textContent).toContain('No content');
    
    // Cleanup
    juris.domRenderer.cleanup(element);
    juris.domRenderer.cleanup(staticElement);
    juris.domRenderer.cleanup(invalidTabElement);
    document.body.removeChild(element);
    document.body.removeChild(staticElement);
    document.body.removeChild(invalidTabElement);
}, `const juris = new Juris({
    components: {
        TabRenderer: (props, context) => ({
            render: () => {
                const tabs = props.tabs || {};
                const tabNames = Object.keys(tabs);

                return {
                    div: {
                        children: [
                            {
                                div: {
                                    className: 'tabs',
                                    children: () => {
                                        const activeTab = typeof props.activeTab === 'function' ? props.activeTab() : props.activeTab;
                                        return tabNames.map(tabName => ({
                                            div: {
                                                className: \`tab \${activeTab === tabName ? 'active' : ''}\`,
                                                text: props.tabLabels ? props.tabLabels[tabName] || tabName : tabName,
                                                onclick: () => props.onTabChange && props.onTabChange(tabName)
                                            }
                                        }));
                                    }
                                }
                            },
                            {
                                div: {
                                    children: () => {
                                        const activeTab = typeof props.activeTab === 'function' ? props.activeTab() : props.activeTab;
                                        return tabs[activeTab] ? [tabs[activeTab]] : [{ div: { text: 'No content' } }];
                                    }
                                }
                            }
                        ]
                    }
                };
            }
        })
    }
});

juris.setState('activeTab', 'profile');

const element = juris.objectToHtml({
    TabRenderer: {
        activeTab: () => juris.getState('activeTab', 'profile'),
        tabs: {
            profile: { div: { text: 'Profile Content', className: 'profile-content' } },
            settings: { div: { text: 'Settings Content', className: 'settings-content' } }
        },
        onTabChange: (tabName) => juris.setState('activeTab', tabName)
    }
});

// Test tab switching
juris.setState('activeTab', 'settings');
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.querySelector('.tab.active').textContent).toBe('settings');
testFramework.expect(element.querySelector('.settings-content')).toBeTruthy();`);

testFramework.addTest('MultiStateRenderer Component Injection', 'Control Flow Components', async function() {
    const juris = new Juris({
        components: {
            MultiStateRenderer: (props, context) => ({
                render: () => ({
                    div: {
                        children: () => {
                            // Check conditions in order and return first match
                            if (props.conditions) {
                                for (const condition of props.conditions) {
                                    const test = typeof condition.when === 'function'
                                        ? condition.when()
                                        : condition.when;

                                    if (test) {
                                        return condition.render ?
                                            (Array.isArray(condition.render) ? condition.render : [condition.render]) :
                                            [];
                                    }
                                }
                            }

                            // No conditions matched, return fallback
                            return props.fallback ?
                                (Array.isArray(props.fallback) ? props.fallback : [props.fallback]) :
                                [];
                        }
                    }
                })
            }),
            OfflineBanner: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'offline-banner',
                        text: '📡 You are offline - Check your connection'
                    }
                })
            }),
            MaintenanceMessage: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'maintenance-message',
                        text: '🔧 System under maintenance - Please try again later'
                    }
                })
            }),
            UpdateNotification: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'update-notification',
                        text: '🔄 Update available - Click to refresh'
                    }
                })
            }),
            OperationalMessage: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'operational-message',
                        text: '✅ All systems operational'
                    }
                })
            })
        }
    });
    
    // Initialize system state
    juris.setState('system.offline', false);
    juris.setState('system.maintenance', false);
    juris.setState('system.updateAvailable', false);
    
    const element = juris.objectToHtml({
        MultiStateRenderer: {
            conditions: [
                {
                    when: () => juris.getState('system.offline', false),
                    render: { OfflineBanner: {} }
                },
                {
                    when: () => juris.getState('system.maintenance', false),
                    render: { MaintenanceMessage: {} }
                },
                {
                    when: () => juris.getState('system.updateAvailable', false),
                    render: { UpdateNotification: {} }
                }
            ],
            fallback: { OperationalMessage: {} }
        }
    });
    
    document.body.appendChild(element);
    
    // Test initial state (all conditions false - should show fallback)
    testFramework.expect(element.querySelector('.operational-message')).toBeTruthy();
    testFramework.expect(element.textContent).toContain('All systems operational');
    testFramework.expect(element.querySelector('.offline-banner')).toBeFalsy();
    testFramework.expect(element.querySelector('.maintenance-message')).toBeFalsy();
    testFramework.expect(element.querySelector('.update-notification')).toBeFalsy();
    
    // Test priority 1: Offline (should override everything)
    juris.setState('system.offline', true);
    juris.setState('system.maintenance', true);
    juris.setState('system.updateAvailable', true);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.querySelector('.offline-banner')).toBeTruthy();
    testFramework.expect(element.textContent).toContain('You are offline');
    testFramework.expect(element.querySelector('.maintenance-message')).toBeFalsy();
    testFramework.expect(element.querySelector('.update-notification')).toBeFalsy();
    testFramework.expect(element.querySelector('.operational-message')).toBeFalsy();
    
    // Test priority 2: Maintenance (should show when offline is false)
    juris.setState('system.offline', false);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.querySelector('.maintenance-message')).toBeTruthy();
    testFramework.expect(element.textContent).toContain('System under maintenance');
    testFramework.expect(element.querySelector('.offline-banner')).toBeFalsy();
    testFramework.expect(element.querySelector('.update-notification')).toBeFalsy();
    testFramework.expect(element.querySelector('.operational-message')).toBeFalsy();
    
    // Test priority 3: Update available (should show when offline and maintenance are false)
    juris.setState('system.maintenance', false);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.querySelector('.update-notification')).toBeTruthy();
    testFramework.expect(element.textContent).toContain('Update available');
    testFramework.expect(element.querySelector('.offline-banner')).toBeFalsy();
    testFramework.expect(element.querySelector('.maintenance-message')).toBeFalsy();
    testFramework.expect(element.querySelector('.operational-message')).toBeFalsy();
    
    // Test fallback: All conditions false
    juris.setState('system.updateAvailable', false);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.querySelector('.operational-message')).toBeTruthy();
    testFramework.expect(element.textContent).toContain('All systems operational');
    testFramework.expect(element.querySelector('.offline-banner')).toBeFalsy();
    testFramework.expect(element.querySelector('.maintenance-message')).toBeFalsy();
    testFramework.expect(element.querySelector('.update-notification')).toBeFalsy();
    
    // Test static conditions (non-functions)
    const staticElement = juris.objectToHtml({
        MultiStateRenderer: {
            conditions: [
                {
                    when: false,
                    render: { div: { text: 'Should not show', className: 'static-false' } }
                },
                {
                    when: true,
                    render: { div: { text: 'Static true condition', className: 'static-true' } }
                }
            ],
            fallback: { div: { text: 'Fallback', className: 'static-fallback' } }
        }
    });
    
    document.body.appendChild(staticElement);
    testFramework.expect(staticElement.querySelector('.static-true')).toBeTruthy();
    testFramework.expect(staticElement.textContent).toContain('Static true condition');
    testFramework.expect(staticElement.querySelector('.static-false')).toBeFalsy();
    testFramework.expect(staticElement.querySelector('.static-fallback')).toBeFalsy();
    
    // Test no conditions (should show fallback)
    const noConditionsElement = juris.objectToHtml({
        MultiStateRenderer: {
            fallback: { div: { text: 'No conditions fallback', className: 'no-conditions' } }
        }
    });
    
    document.body.appendChild(noConditionsElement);
    testFramework.expect(noConditionsElement.querySelector('.no-conditions')).toBeTruthy();
    testFramework.expect(noConditionsElement.textContent).toContain('No conditions fallback');
    
    // Test empty conditions array
    const emptyConditionsElement = juris.objectToHtml({
        MultiStateRenderer: {
            conditions: [],
            fallback: { div: { text: 'Empty conditions fallback', className: 'empty-conditions' } }
        }
    });
    
    document.body.appendChild(emptyConditionsElement);
    testFramework.expect(emptyConditionsElement.querySelector('.empty-conditions')).toBeTruthy();
    testFramework.expect(emptyConditionsElement.textContent).toContain('Empty conditions fallback');
    
    // Cleanup
    juris.domRenderer.cleanup(element);
    juris.domRenderer.cleanup(staticElement);
    juris.domRenderer.cleanup(noConditionsElement);
    juris.domRenderer.cleanup(emptyConditionsElement);
    document.body.removeChild(element);
    document.body.removeChild(staticElement);
    document.body.removeChild(noConditionsElement);
    document.body.removeChild(emptyConditionsElement);
}, `const juris = new Juris({
    components: {
        MultiStateRenderer: (props, context) => ({
            render: () => ({
                div: {
                    children: () => {
                        if (props.conditions) {
                            for (const condition of props.conditions) {
                                const test = typeof condition.when === 'function'
                                    ? condition.when()
                                    : condition.when;

                                if (test) {
                                    return condition.render ? [condition.render] : [];
                                }
                            }
                        }

                        return props.fallback ? [props.fallback] : [];
                    }
                }
            })
        })
    }
});

juris.setState('system.offline', false);
juris.setState('system.maintenance', true);
juris.setState('system.updateAvailable', false);

const element = juris.objectToHtml({
    MultiStateRenderer: {
        conditions: [
            {
                when: () => juris.getState('system.offline', false),
                render: { div: { text: 'Offline', className: 'offline' } }
            },
            {
                when: () => juris.getState('system.maintenance', false),
                render: { div: { text: 'Maintenance', className: 'maintenance' } }
            },
            {
                when: () => juris.getState('system.updateAvailable', false),
                render: { div: { text: 'Update Available', className: 'update' } }
            }
        ],
        fallback: { div: { text: 'All OK', className: 'ok' } }
    }
});

// Test priority - maintenance should show (second condition)
testFramework.expect(element.querySelector('.maintenance')).toBeTruthy();
testFramework.expect(element.querySelector('.offline')).toBeFalsy();

// Test priority override - offline takes precedence
juris.setState('system.offline', true);
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.querySelector('.offline')).toBeTruthy();
testFramework.expect(element.querySelector('.maintenance')).toBeFalsy();`);


testFramework.addTest('RouteRenderer Component Injection', 'Control Flow Components', async function() {
    const juris = new Juris({
        components: {
            RouteRenderer: (props, context) => {
                const { getState } = context;

                return {
                    render: () => ({
                        div: {
                            children: () => {
                                const currentRoute = getState('router.currentRoute', '/');

                                // Look for exact route match
                                if (props[currentRoute]) {
                                    const match = props[currentRoute];
                                    return Array.isArray(match) ? match : [match];
                                }

                                // Fallback to 404
                                if (props.notFound) {
                                    return Array.isArray(props.notFound) ? props.notFound : [props.notFound];
                                }

                                return [{ div: { text: '404 - Route not found' } }];
                            }
                        }
                    })
                };
            },
            HomePage: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'home-page',
                        children: [
                            { h1: { text: 'Welcome Home' } },
                            { div: { text: 'This is the home page content.' } }
                        ]
                    }
                })
            }),
            AboutPage: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'about-page',
                        children: [
                            { h1: { text: 'About Us' } },
                            { div: { text: 'Learn more about our company.' } }
                        ]
                    }
                })
            }),
            ContactPage: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'contact-page',
                        children: [
                            { h1: { text: 'Contact Us' } },
                            { div: { text: 'Get in touch with our team.' } }
                        ]
                    }
                })
            }),
            AdminPage: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'admin-page',
                        children: [
                            { h1: { text: 'Admin Dashboard' } },
                            { div: { text: 'Administrative controls and settings.' } }
                        ]
                    }
                })
            }),
            NotFoundPage: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'not-found-page',
                        children: [
                            { h1: { text: '404 - Page Not Found' } },
                            { div: { text: 'The requested page could not be found.' } }
                        ]
                    }
                })
            })
        }
    });
    
    // Initialize router state
    juris.setState('router.currentRoute', '/');
    
    const element = juris.objectToHtml({
        RouteRenderer: {
            '/': { HomePage: {} },
            '/about': { AboutPage: {} },
            '/contact': { ContactPage: {} },
            '/admin': { AdminPage: {} },
            notFound: { NotFoundPage: {} }
        }
    });
    
    document.body.appendChild(element);
    
    // Test default route (home)
    testFramework.expect(element.querySelector('.home-page')).toBeTruthy();
    testFramework.expect(element.textContent).toContain('Welcome Home');
    testFramework.expect(element.querySelector('.about-page')).toBeFalsy();
    testFramework.expect(element.querySelector('.contact-page')).toBeFalsy();
    testFramework.expect(element.querySelector('.admin-page')).toBeFalsy();
    testFramework.expect(element.querySelector('.not-found-page')).toBeFalsy();
    
    // Test navigation to about page
    juris.setState('router.currentRoute', '/about');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.querySelector('.about-page')).toBeTruthy();
    testFramework.expect(element.textContent).toContain('About Us');
    testFramework.expect(element.querySelector('.home-page')).toBeFalsy();
    testFramework.expect(element.querySelector('.contact-page')).toBeFalsy();
    testFramework.expect(element.querySelector('.admin-page')).toBeFalsy();
    testFramework.expect(element.querySelector('.not-found-page')).toBeFalsy();
    
    // Test navigation to contact page
    juris.setState('router.currentRoute', '/contact');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.querySelector('.contact-page')).toBeTruthy();
    testFramework.expect(element.textContent).toContain('Get in touch');
    testFramework.expect(element.querySelector('.home-page')).toBeFalsy();
    testFramework.expect(element.querySelector('.about-page')).toBeFalsy();
    testFramework.expect(element.querySelector('.admin-page')).toBeFalsy();
    testFramework.expect(element.querySelector('.not-found-page')).toBeFalsy();
    
    // Test navigation to admin page
    juris.setState('router.currentRoute', '/admin');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.querySelector('.admin-page')).toBeTruthy();
    testFramework.expect(element.textContent).toContain('Admin Dashboard');
    testFramework.expect(element.querySelector('.home-page')).toBeFalsy();
    testFramework.expect(element.querySelector('.about-page')).toBeFalsy();
    testFramework.expect(element.querySelector('.contact-page')).toBeFalsy();
    testFramework.expect(element.querySelector('.not-found-page')).toBeFalsy();
    
    // Test unknown route (should show custom notFound)
    juris.setState('router.currentRoute', '/unknown');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.querySelector('.not-found-page')).toBeTruthy();
    testFramework.expect(element.textContent).toContain('Page Not Found');
    testFramework.expect(element.querySelector('.home-page')).toBeFalsy();
    testFramework.expect(element.querySelector('.about-page')).toBeFalsy();
    testFramework.expect(element.querySelector('.contact-page')).toBeFalsy();
    testFramework.expect(element.querySelector('.admin-page')).toBeFalsy();
    
    // Test router without custom notFound (should show default)
    const defaultNotFoundElement = juris.objectToHtml({
        RouteRenderer: {
            '/': { div: { text: 'Home', className: 'simple-home' } },
            '/about': { div: { text: 'About', className: 'simple-about' } }
        }
    });
    
    juris.setState('router.currentRoute', '/nonexistent');
    document.body.appendChild(defaultNotFoundElement);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(defaultNotFoundElement.textContent).toContain('404 - Route not found');
    testFramework.expect(defaultNotFoundElement.querySelector('.simple-home')).toBeFalsy();
    testFramework.expect(defaultNotFoundElement.querySelector('.simple-about')).toBeFalsy();
    
    // Test route with array content
    const arrayRouteElement = juris.objectToHtml({
        RouteRenderer: {
            '/': [
                { div: { text: 'Header', className: 'header' } },
                { div: { text: 'Content', className: 'content' } },
                { div: { text: 'Footer', className: 'footer' } }
            ]
        }
    });
    
    juris.setState('router.currentRoute', '/');
    document.body.appendChild(arrayRouteElement);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(arrayRouteElement.querySelector('.header')).toBeTruthy();
    testFramework.expect(arrayRouteElement.querySelector('.content')).toBeTruthy();
    testFramework.expect(arrayRouteElement.querySelector('.footer')).toBeTruthy();
    testFramework.expect(arrayRouteElement.textContent).toContain('Header');
    testFramework.expect(arrayRouteElement.textContent).toContain('Content');
    testFramework.expect(arrayRouteElement.textContent).toContain('Footer');
    
    // Test back to home to verify router still works
    juris.setState('router.currentRoute', '/');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.querySelector('.home-page')).toBeTruthy();
    testFramework.expect(element.textContent).toContain('Welcome Home');
    testFramework.expect(element.querySelector('.not-found-page')).toBeFalsy();
    
    // Cleanup
    juris.domRenderer.cleanup(element);
    juris.domRenderer.cleanup(defaultNotFoundElement);
    juris.domRenderer.cleanup(arrayRouteElement);
    document.body.removeChild(element);
    document.body.removeChild(defaultNotFoundElement);
    document.body.removeChild(arrayRouteElement);
}, `const juris = new Juris({
    components: {
        RouteRenderer: (props, context) => {
            const { getState } = context;

            return {
                render: () => ({
                    div: {
                        children: () => {
                            const currentRoute = getState('router.currentRoute', '/');

                            if (props[currentRoute]) {
                                const match = props[currentRoute];
                                return Array.isArray(match) ? match : [match];
                            }

                            if (props.notFound) {
                                return Array.isArray(props.notFound) ? props.notFound : [props.notFound];
                            }

                            return [{ div: { text: '404 - Route not found' } }];
                        }
                    }
                })
            };
        }
    }
});

juris.setState('router.currentRoute', '/');

const element = juris.objectToHtml({
    RouteRenderer: {
        '/': { div: { text: 'Home Page', className: 'home' } },
        '/about': { div: { text: 'About Page', className: 'about' } },
        '/contact': { div: { text: 'Contact Page', className: 'contact' } },
        notFound: { div: { text: 'Page Not Found', className: 'not-found' } }
    }
});

// Test route navigation
juris.setState('router.currentRoute', '/about');
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.querySelector('.about')).toBeTruthy();
testFramework.expect(element.textContent).toContain('About Page');

// Test 404 handling
juris.setState('router.currentRoute', '/unknown');
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.querySelector('.not-found')).toBeTruthy();
testFramework.expect(element.textContent).toContain('Page Not Found');`);

testFramework.addTest('PermissionRenderer Component Injection', 'Control Flow Components', async function() {
    const juris = new Juris({
        components: {
            PermissionRenderer: (props, context) => ({
                render: () => ({
                    div: {
                        children: () => {
                            const userRole = typeof props.userRole === 'function' 
                                ? props.userRole() 
                                : props.userRole;
                            const requiredRoles = props.requiredRoles || [];
                            
                            if (requiredRoles.includes(userRole)) {
                                return props.authorized ? 
                                    (Array.isArray(props.authorized) ? props.authorized : [props.authorized]) : 
                                    [];
                            }
                            
                            return props.unauthorized ? 
                                (Array.isArray(props.unauthorized) ? props.unauthorized : [props.unauthorized]) : 
                                [{ div: { text: 'Access denied', className: 'access-denied' } }];
                        }
                    }
                })
            }),
            AdminPanel: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'admin-panel',
                        children: [
                            { h2: { text: 'Admin Dashboard' } },
                            { div: { text: 'Secret admin controls and settings' } },
                            { button: { text: 'Manage Users' } }
                        ]
                    }
                })
            }),
            UserDashboard: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'user-dashboard',
                        children: [
                            { h2: { text: 'User Dashboard' } },
                            { div: { text: 'Your personal dashboard' } },
                            { button: { text: 'Edit Profile' } }
                        ]
                    }
                })
            }),
            AccessDenied: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'access-denied-custom',
                        children: [
                            { h2: { text: '🚫 Access Denied' } },
                            { div: { text: 'You do not have permission to view this content.' } },
                            { button: { text: 'Request Access' } }
                        ]
                    }
                })
            })
        }
    });
    
    // Initialize user role
    juris.setState('user.role', 'guest');
    
    const element = juris.objectToHtml({
        PermissionRenderer: {
            userRole: () => juris.getState('user.role', 'guest'),
            requiredRoles: ['admin', 'moderator'],
            authorized: { AdminPanel: {} },
            unauthorized: { AccessDenied: {} }
        }
    });
    
    document.body.appendChild(element);
    
    // Test guest user (unauthorized)
    testFramework.expect(element.querySelector('.access-denied-custom')).toBeTruthy();
    testFramework.expect(element.textContent).toContain('Access Denied');
    testFramework.expect(element.querySelector('.admin-panel')).toBeFalsy();
    
    // Test user role (still unauthorized for admin panel)
    juris.setState('user.role', 'user');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.querySelector('.access-denied-custom')).toBeTruthy();
    testFramework.expect(element.textContent).toContain('Access Denied');
    testFramework.expect(element.querySelector('.admin-panel')).toBeFalsy();
    
    // Test moderator role (authorized)
    juris.setState('user.role', 'moderator');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.querySelector('.admin-panel')).toBeTruthy();
    testFramework.expect(element.textContent).toContain('Admin Dashboard');
    testFramework.expect(element.querySelector('.access-denied-custom')).toBeFalsy();
    
    // Test admin role (authorized)
    juris.setState('user.role', 'admin');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.querySelector('.admin-panel')).toBeTruthy();
    testFramework.expect(element.textContent).toContain('Secret admin controls');
    testFramework.expect(element.querySelector('.access-denied-custom')).toBeFalsy();
    
    // Test different permission levels
    const userElement = juris.objectToHtml({
        PermissionRenderer: {
            userRole: () => juris.getState('user.role', 'guest'),
            requiredRoles: ['user', 'moderator', 'admin'],
            authorized: { UserDashboard: {} },
            unauthorized: { AccessDenied: {} }
        }
    });
    
    document.body.appendChild(userElement);
    
    // Admin should have access to user-level content
    testFramework.expect(userElement.querySelector('.user-dashboard')).toBeTruthy();
    testFramework.expect(userElement.textContent).toContain('User Dashboard');
    testFramework.expect(userElement.querySelector('.access-denied-custom')).toBeFalsy();
    
    // Test with static role (non-function)
    const staticElement = juris.objectToHtml({
        PermissionRenderer: {
            userRole: 'guest',
            requiredRoles: ['admin'],
            authorized: { div: { text: 'Admin Content', className: 'admin-content' } },
            unauthorized: { div: { text: 'Not Authorized', className: 'not-authorized' } }
        }
    });
    
    document.body.appendChild(staticElement);
    testFramework.expect(staticElement.querySelector('.not-authorized')).toBeTruthy();
    testFramework.expect(staticElement.textContent).toContain('Not Authorized');
    testFramework.expect(staticElement.querySelector('.admin-content')).toBeFalsy();
    
    // Test default unauthorized message (no unauthorized prop)
    const defaultElement = juris.objectToHtml({
        PermissionRenderer: {
            userRole: 'guest',
            requiredRoles: ['admin'],
            authorized: { div: { text: 'Secret Content' } }
        }
    });
    
    document.body.appendChild(defaultElement);
    testFramework.expect(defaultElement.querySelector('.access-denied')).toBeTruthy();
    testFramework.expect(defaultElement.textContent).toContain('Access denied');
    
    // Test empty required roles (should deny access)
    const emptyRolesElement = juris.objectToHtml({
        PermissionRenderer: {
            userRole: 'admin',
            requiredRoles: [],
            authorized: { div: { text: 'Should not show' } },
            unauthorized: { div: { text: 'No roles required but denied', className: 'empty-roles' } }
        }
    });
    
    document.body.appendChild(emptyRolesElement);
    testFramework.expect(emptyRolesElement.querySelector('.empty-roles')).toBeTruthy();
    
    // Cleanup
    juris.domRenderer.cleanup(element);
    juris.domRenderer.cleanup(userElement);
    juris.domRenderer.cleanup(staticElement);
    juris.domRenderer.cleanup(defaultElement);
    juris.domRenderer.cleanup(emptyRolesElement);
    document.body.removeChild(element);
    document.body.removeChild(userElement);
    document.body.removeChild(staticElement);
    document.body.removeChild(defaultElement);
    document.body.removeChild(emptyRolesElement);
}, `const juris = new Juris({
    components: {
        PermissionRenderer: (props, context) => ({
            render: () => ({
                div: {
                    children: () => {
                        const userRole = typeof props.userRole === 'function' 
                            ? props.userRole() 
                            : props.userRole;
                        const requiredRoles = props.requiredRoles || [];
                        
                        if (requiredRoles.includes(userRole)) {
                            return props.authorized ? [props.authorized] : [];
                        }
                        
                        return props.unauthorized ? [props.unauthorized] : 
                            [{ div: { text: 'Access denied', className: 'access-denied' } }];
                    }
                }
            })
        })
    }
});

juris.setState('user.role', 'guest');

const element = juris.objectToHtml({
    PermissionRenderer: {
        userRole: () => juris.getState('user.role', 'guest'),
        requiredRoles: ['admin', 'moderator'],
        authorized: { div: { text: 'Admin Panel', className: 'admin-panel' } },
        unauthorized: { div: { text: 'Access Denied', className: 'access-denied' } }
    }
});

// Test role change to authorized
juris.setState('user.role', 'admin');
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.querySelector('.admin-panel')).toBeTruthy();
testFramework.expect(element.querySelector('.access-denied')).toBeFalsy();`);

testFramework.addTest('RetryRenderer Component Injection', 'Control Flow Components', async function() {
    const juris = new Juris({
        components: {
            RetryRenderer: (props, context) => ({
                render: () => ({
                    div: {
                        children: () => {
                            const error = typeof props.error === 'function' ? props.error() : props.error;
                            const retryCount = typeof props.retryCount === 'function' ? props.retryCount() : (props.retryCount || 0);
                            const maxRetries = props.maxRetries || 3;
                            const isRetrying = typeof props.isRetrying === 'function' ? props.isRetrying() : props.isRetrying;
                            
                            if (error && retryCount < maxRetries) {
                                return props.retryComponent ? 
                                    (Array.isArray(props.retryComponent) ? props.retryComponent : [props.retryComponent]) : 
                                    [{
                                        div: {
                                            className: 'retry-container',
                                            children: [
                                                { div: { text: `Error: ${error}`, className: 'error-message' } },
                                                { div: { text: `Attempt ${retryCount + 1} of ${maxRetries}`, className: 'retry-count' } },
                                                isRetrying ? 
                                                    { div: { text: 'Retrying...', className: 'retrying' } } :
                                                    { 
                                                        button: { 
                                                            text: 'Retry', 
                                                            onclick: () => props.onRetry && props.onRetry(),
                                                            className: 'retry-button'
                                                        } 
                                                    }
                                            ]
                                        }
                                    }];
                            } else if (error && retryCount >= maxRetries) {
                                return props.maxRetriesComponent ? 
                                    (Array.isArray(props.maxRetriesComponent) ? props.maxRetriesComponent : [props.maxRetriesComponent]) : 
                                    [{ div: { text: 'Maximum retries exceeded. Please try again later.', className: 'max-retries-exceeded' } }];
                            }
                            
                            return props.children ? 
                                (Array.isArray(props.children) ? props.children : [props.children]) : 
                                [];
                        }
                    }
                })
            }),
            CustomRetryPanel: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'custom-retry-panel',
                        children: [
                            { h3: { text: '⚠️ Operation Failed' } },
                            { div: { text: () => `Error: ${props.errorMessage}`, className: 'custom-error' } },
                            { div: { text: () => `Retry ${props.attempt} of ${props.maxAttempts}`, className: 'custom-attempt' } },
                            props.isRetrying ? 
                                { div: { text: '🔄 Retrying operation...', className: 'custom-retrying' } } :
                                { 
                                    button: { 
                                        text: '🔄 Try Again', 
                                        onclick: () => props.onRetryClick && props.onRetryClick(),
                                        className: 'custom-retry-btn'
                                    } 
                                }
                        ]
                    }
                })
            }),
            MaxRetriesPanel: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'max-retries-panel',
                        children: [
                            { h3: { text: '❌ Operation Failed' } },
                            { div: { text: 'Maximum retry attempts exceeded.' } },
                            { div: { text: 'Please contact support or try again later.' } },
                            { 
                                button: { 
                                    text: 'Contact Support', 
                                    onclick: () => props.onContactSupport && props.onContactSupport(),
                                    className: 'contact-support-btn'
                                } 
                            }
                        ]
                    }
                })
            }),
            SuccessContent: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'success-content',
                        children: [
                            { h3: { text: '✅ Operation Successful' } },
                            { div: { text: 'Everything is working normally.' } }
                        ]
                    }
                })
            })
        }
    });
    
    // Initialize retry state
    juris.setState('operation.error', null);
    juris.setState('operation.retryCount', 0);
    juris.setState('operation.isRetrying', false);
    
    const element = juris.objectToHtml({
        RetryRenderer: {
            error: () => juris.getState('operation.error', null),
            retryCount: () => juris.getState('operation.retryCount', 0),
            maxRetries: 3,
            isRetrying: () => juris.getState('operation.isRetrying', false),
            onRetry: () => {
                const currentCount = juris.getState('operation.retryCount', 0);
                juris.setState('operation.retryCount', currentCount + 1);
                juris.setState('operation.isRetrying', true);
                
                // Simulate retry operation
                setTimeout(() => {
                    juris.setState('operation.isRetrying', false);
                    // For demo, fail first 2 attempts, succeed on 3rd
                    if (currentCount >= 2) {
                        juris.setState('operation.error', null);
                    }
                }, 1000);
            },
            children: { SuccessContent: {} }
        }
    });
    
    document.body.appendChild(element);
    
    // Test initial success state (no error)
    testFramework.expect(element.querySelector('.success-content')).toBeTruthy();
    testFramework.expect(element.textContent).toContain('Operation Successful');
    testFramework.expect(element.querySelector('.retry-container')).toBeFalsy();
    testFramework.expect(element.querySelector('.max-retries-exceeded')).toBeFalsy();
    
    // Test first error (should show retry option)
    juris.setState('operation.error', 'Network connection failed');
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.querySelector('.retry-container')).toBeTruthy();
    testFramework.expect(element.textContent).toContain('Network connection failed');
    testFramework.expect(element.textContent).toContain('Attempt 1 of 3');
    testFramework.expect(element.querySelector('.retry-button')).toBeTruthy();
    testFramework.expect(element.querySelector('.success-content')).toBeFalsy();
    testFramework.expect(element.querySelector('.max-retries-exceeded')).toBeFalsy();
    
    // Test retrying state
    juris.setState('operation.isRetrying', true);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.querySelector('.retrying')).toBeTruthy();
    testFramework.expect(element.textContent).toContain('Retrying...');
    testFramework.expect(element.querySelector('.retry-button')).toBeFalsy();
    
    // Test second attempt
    juris.setState('operation.isRetrying', false);
    juris.setState('operation.retryCount', 1);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.querySelector('.retry-container')).toBeTruthy();
    testFramework.expect(element.textContent).toContain('Attempt 2 of 3');
    testFramework.expect(element.querySelector('.retry-button')).toBeTruthy();
    
    // Test third attempt
    juris.setState('operation.retryCount', 2);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.textContent).toContain('Attempt 3 of 3');
    
    // Test max retries exceeded
    juris.setState('operation.retryCount', 3);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.querySelector('.max-retries-exceeded')).toBeTruthy();
    testFramework.expect(element.textContent).toContain('Maximum retries exceeded');
    testFramework.expect(element.querySelector('.retry-container')).toBeFalsy();
    testFramework.expect(element.querySelector('.success-content')).toBeFalsy();
    
    // Test custom retry component
    const customElement = juris.objectToHtml({
        RetryRenderer: {
            error: 'Database timeout',
            retryCount: 1,
            maxRetries: 2,
            isRetrying: false,
            retryComponent: { 
                CustomRetryPanel: { 
                    errorMessage: 'Database timeout',
                    attempt: 2,
                    maxAttempts: 2,
                    isRetrying: false,
                    onRetryClick: () => console.log('Custom retry clicked')
                } 
            },
            maxRetriesComponent: { MaxRetriesPanel: {} },
            children: { SuccessContent: {} }
        }
    });
    
    document.body.appendChild(customElement);
    
    testFramework.expect(customElement.querySelector('.custom-retry-panel')).toBeTruthy();
    testFramework.expect(customElement.textContent).toContain('Operation Failed');
    testFramework.expect(customElement.textContent).toContain('Database timeout');
    testFramework.expect(customElement.querySelector('.custom-retry-btn')).toBeTruthy();
    
    // Test custom max retries component
    const maxRetriesElement = juris.objectToHtml({
        RetryRenderer: {
            error: 'Service unavailable',
            retryCount: 3,
            maxRetries: 3,
            maxRetriesComponent: { MaxRetriesPanel: {} }
        }
    });
    
    document.body.appendChild(maxRetriesElement);
    
    testFramework.expect(maxRetriesElement.querySelector('.max-retries-panel')).toBeTruthy();
    testFramework.expect(maxRetriesElement.textContent).toContain('Maximum retry attempts exceeded');
    testFramework.expect(maxRetriesElement.querySelector('.contact-support-btn')).toBeTruthy();
    
    // Test static props (non-functions)
    const staticElement = juris.objectToHtml({
        RetryRenderer: {
            error: 'Static error',
            retryCount: 0,
            maxRetries: 2,
            isRetrying: false,
            children: { div: { text: 'Static success content', className: 'static-success' } }
        }
    });
    
    document.body.appendChild(staticElement);
    testFramework.expect(staticElement.querySelector('.retry-container')).toBeTruthy();
    testFramework.expect(staticElement.textContent).toContain('Static error');
    testFramework.expect(staticElement.textContent).toContain('Attempt 1 of 2');
    
    // Cleanup
    juris.domRenderer.cleanup(element);
    juris.domRenderer.cleanup(customElement);
    juris.domRenderer.cleanup(maxRetriesElement);
    juris.domRenderer.cleanup(staticElement);
    document.body.removeChild(element);
    document.body.removeChild(customElement);
    document.body.removeChild(maxRetriesElement);
    document.body.removeChild(staticElement);
}, `const juris = new Juris({
    components: {
        RetryRenderer: (props, context) => ({
            render: () => ({
                div: {
                    children: () => {
                        const error = typeof props.error === 'function' ? props.error() : props.error;
                        const retryCount = typeof props.retryCount === 'function' ? props.retryCount() : (props.retryCount || 0);
                        const maxRetries = props.maxRetries || 3;
                        const isRetrying = typeof props.isRetrying === 'function' ? props.isRetrying() : props.isRetrying;
                        
                        if (error && retryCount < maxRetries) {
                            return props.retryComponent ? [props.retryComponent] : 
                                [{
                                    div: {
                                        className: 'retry-container',
                                        children: [
                                            { div: { text: \`Error: \${error}\` } },
                                            { div: { text: \`Attempt \${retryCount + 1} of \${maxRetries}\` } },
                                            isRetrying ? 
                                                { div: { text: 'Retrying...', className: 'retrying' } } :
                                                { button: { text: 'Retry', onclick: () => props.onRetry && props.onRetry() } }
                                        ]
                                    }
                                }];
                        } else if (error && retryCount >= maxRetries) {
                            return props.maxRetriesComponent ? [props.maxRetriesComponent] : 
                                [{ div: { text: 'Maximum retries exceeded', className: 'max-retries' } }];
                        }
                        
                        return props.children ? [props.children] : [];
                    }
                }
            })
        })
    }
});

juris.setState('operation.error', null);
juris.setState('operation.retryCount', 0);

const element = juris.objectToHtml({
    RetryRenderer: {
        error: () => juris.getState('operation.error', null),
        retryCount: () => juris.getState('operation.retryCount', 0),
        maxRetries: 3,
        onRetry: () => {
            const count = juris.getState('operation.retryCount', 0);
            juris.setState('operation.retryCount', count + 1);
        },
        children: { div: { text: 'Success Content', className: 'success' } }
    }
});

// Test error state with retry
juris.setState('operation.error', 'Connection failed');
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.querySelector('.retry-container')).toBeTruthy();
testFramework.expect(element.textContent).toContain('Connection failed');

// Test max retries
juris.setState('operation.retryCount', 3);
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.querySelector('.max-retries')).toBeTruthy();`);

testFramework.addTest('FeatureFlagRenderer Component Injection', 'Control Flow Components', async function() {
    const juris = new Juris({
        components: {
            FeatureFlagRenderer: (props, context) => ({
                render: () => ({
                    div: {
                        children: () => {
                            const flags = typeof props.flags === 'function' ? props.flags() : (props.flags || {});
                            const flagName = props.flag;
                            const variant = props.variant;
                            
                            // Check if flag exists and is enabled
                            if (flags && flags[flagName]) {
                                const flagValue = flags[flagName];
                                
                                // Handle boolean flags
                                if (typeof flagValue === 'boolean' && flagValue) {
                                    return props.enabled ? 
                                        (Array.isArray(props.enabled) ? props.enabled : [props.enabled]) : 
                                        [];
                                }
                                
                                // Handle variant flags (A/B testing)
                                if (typeof flagValue === 'string' && variant && props.variants) {
                                    if (flagValue === variant && props.variants[variant]) {
                                        const variantComponent = props.variants[variant];
                                        return Array.isArray(variantComponent) ? variantComponent : [variantComponent];
                                    }
                                }
                                
                                // Handle object flags with percentage/rules
                                if (typeof flagValue === 'object' && flagValue.enabled) {
                                    return props.enabled ? 
                                        (Array.isArray(props.enabled) ? props.enabled : [props.enabled]) : 
                                        [];
                                }
                            }
                            
                            return props.disabled ? 
                                (Array.isArray(props.disabled) ? props.disabled : [props.disabled]) : 
                                [];
                        }
                    }
                })
            }),
            NewFeature: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'new-feature',
                        children: [
                            { div: { text: '🆕 New Feature Enabled!', className: 'feature-badge' } },
                            { h3: { text: 'Enhanced Dashboard' } },
                            { div: { text: 'Experience our new and improved dashboard with advanced analytics.' } },
                            { button: { text: 'Try New Dashboard', className: 'new-feature-btn' } }
                        ]
                    }
                })
            }),
            LegacyFeature: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'legacy-feature',
                        children: [
                            { h3: { text: 'Classic Dashboard' } },
                            { div: { text: 'Using the traditional dashboard interface.' } },
                            { button: { text: 'Open Dashboard', className: 'legacy-feature-btn' } }
                        ]
                    }
                })
            }),
            VariantA: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'variant-a',
                        children: [
                            { h3: { text: 'Version A - Blue Theme' } },
                            { div: { text: 'You are seeing the blue-themed version.', style: { color: 'blue' } } },
                            { button: { text: 'Blue Action', style: { backgroundColor: 'blue', color: 'white' } } }
                        ]
                    }
                })
            }),
            VariantB: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'variant-b',
                        children: [
                            { h3: { text: 'Version B - Green Theme' } },
                            { div: { text: 'You are seeing the green-themed version.', style: { color: 'green' } } },
                            { button: { text: 'Green Action', style: { backgroundColor: 'green', color: 'white' } } }
                        ]
                    }
                })
            }),
            BetaFeature: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'beta-feature',
                        children: [
                            { div: { text: '🧪 Beta Feature', className: 'beta-badge' } },
                            { h3: { text: 'AI Assistant' } },
                            { div: { text: 'Try our new AI-powered assistant (Beta).' } },
                            { button: { text: 'Enable AI Assistant', className: 'beta-btn' } }
                        ]
                    }
                })
            }),
            StandardVersion: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'standard-version',
                        children: [
                            { h3: { text: 'Standard Version' } },
                            { div: { text: 'You are using the standard version of this feature.' } }
                        ]
                    }
                })
            })
        }
    });
    
    // Initialize feature flags
    juris.setState('featureFlags', {
        newDashboard: false,
        betaFeatures: true,
        aiAssistant: { enabled: true, rolloutPercentage: 50 },
        themeTest: 'A'
    });
    
    // Test boolean feature flag (disabled)
    const dashboardElement = juris.objectToHtml({
        FeatureFlagRenderer: {
            flags: () => juris.getState('featureFlags', {}),
            flag: 'newDashboard',
            enabled: { NewFeature: {} },
            disabled: { LegacyFeature: {} }
        }
    });
    
    document.body.appendChild(dashboardElement);
    
    // Test disabled feature (should show legacy)
    testFramework.expect(dashboardElement.querySelector('.legacy-feature')).toBeTruthy();
    testFramework.expect(dashboardElement.textContent).toContain('Classic Dashboard');
    testFramework.expect(dashboardElement.querySelector('.new-feature')).toBeFalsy();
    
    // Test enabling the feature flag
    const currentFlags = juris.getState('featureFlags', {});
    juris.setState('featureFlags', { ...currentFlags, newDashboard: true });
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(dashboardElement.querySelector('.new-feature')).toBeTruthy();
    testFramework.expect(dashboardElement.textContent).toContain('New Feature Enabled');
    testFramework.expect(dashboardElement.querySelector('.legacy-feature')).toBeFalsy();
    
    // Test boolean feature flag (enabled)
    const betaElement = juris.objectToHtml({
        FeatureFlagRenderer: {
            flags: () => juris.getState('featureFlags', {}),
            flag: 'betaFeatures',
            enabled: { BetaFeature: {} },
            disabled: { StandardVersion: {} }
        }
    });
    
    document.body.appendChild(betaElement);
    
    testFramework.expect(betaElement.querySelector('.beta-feature')).toBeTruthy();
    testFramework.expect(betaElement.textContent).toContain('Beta Feature');
    testFramework.expect(betaElement.querySelector('.standard-version')).toBeFalsy();
    
    // Test object feature flag with enabled property
    const aiElement = juris.objectToHtml({
        FeatureFlagRenderer: {
            flags: () => juris.getState('featureFlags', {}),
            flag: 'aiAssistant',
            enabled: { BetaFeature: {} },
            disabled: { StandardVersion: {} }
        }
    });
    
    document.body.appendChild(aiElement);
    
    testFramework.expect(aiElement.querySelector('.beta-feature')).toBeTruthy();
    testFramework.expect(aiElement.textContent).toContain('AI Assistant');
    testFramework.expect(aiElement.querySelector('.standard-version')).toBeFalsy();
    
    // Test A/B testing with variants
    const variantElement = juris.objectToHtml({
        FeatureFlagRenderer: {
            flags: () => juris.getState('featureFlags', {}),
            flag: 'themeTest',
            variant: 'A',
            variants: {
                A: { VariantA: {} },
                B: { VariantB: {} }
            },
            disabled: { StandardVersion: {} }
        }
    });
    
    document.body.appendChild(variantElement);
    
    testFramework.expect(variantElement.querySelector('.variant-a')).toBeTruthy();
    testFramework.expect(variantElement.textContent).toContain('Blue Theme');
    testFramework.expect(variantElement.querySelector('.variant-b')).toBeFalsy();
    testFramework.expect(variantElement.querySelector('.standard-version')).toBeFalsy();
    
    // Test switching to variant B
    const flags = juris.getState('featureFlags', {});
    juris.setState('featureFlags', { ...flags, themeTest: 'B' });
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(variantElement.querySelector('.variant-b')).toBeTruthy();
    testFramework.expect(variantElement.textContent).toContain('Green Theme');
    testFramework.expect(variantElement.querySelector('.variant-a')).toBeFalsy();
    
    // Test non-existent flag (should show disabled)
    const nonExistentElement = juris.objectToHtml({
        FeatureFlagRenderer: {
            flags: () => juris.getState('featureFlags', {}),
            flag: 'nonExistentFeature',
            enabled: { NewFeature: {} },
            disabled: { StandardVersion: {} }
        }
    });
    
    document.body.appendChild(nonExistentElement);
    
    testFramework.expect(nonExistentElement.querySelector('.standard-version')).toBeTruthy();
    testFramework.expect(nonExistentElement.textContent).toContain('Standard Version');
    testFramework.expect(nonExistentElement.querySelector('.new-feature')).toBeFalsy();
    
    // Test static flags (non-function)
    const staticElement = juris.objectToHtml({
        FeatureFlagRenderer: {
            flags: { staticFeature: true },
            flag: 'staticFeature',
            enabled: { div: { text: 'Static Feature Enabled', className: 'static-enabled' } },
            disabled: { div: { text: 'Static Feature Disabled', className: 'static-disabled' } }
        }
    });
    
    document.body.appendChild(staticElement);
    
    testFramework.expect(staticElement.querySelector('.static-enabled')).toBeTruthy();
    testFramework.expect(staticElement.textContent).toContain('Static Feature Enabled');
    testFramework.expect(staticElement.querySelector('.static-disabled')).toBeFalsy();
    
    // Test variant mismatch (should show disabled)
    const mismatchElement = juris.objectToHtml({
        FeatureFlagRenderer: {
            flags: { testFlag: 'C' },
            flag: 'testFlag',
            variant: 'A',
            variants: {
                A: { div: { text: 'Variant A', className: 'var-a' } },
                B: { div: { text: 'Variant B', className: 'var-b' } }
            },
            disabled: { div: { text: 'No matching variant', className: 'no-match' } }
        }
    });
    
    document.body.appendChild(mismatchElement);
    
    testFramework.expect(mismatchElement.querySelector('.no-match')).toBeTruthy();
    testFramework.expect(mismatchElement.textContent).toContain('No matching variant');
    testFramework.expect(mismatchElement.querySelector('.var-a')).toBeFalsy();
    testFramework.expect(mismatchElement.querySelector('.var-b')).toBeFalsy();
    
    // Cleanup
    juris.domRenderer.cleanup(dashboardElement);
    juris.domRenderer.cleanup(betaElement);
    juris.domRenderer.cleanup(aiElement);
    juris.domRenderer.cleanup(variantElement);
    juris.domRenderer.cleanup(nonExistentElement);
    juris.domRenderer.cleanup(staticElement);
    juris.domRenderer.cleanup(mismatchElement);
    document.body.removeChild(dashboardElement);
    document.body.removeChild(betaElement);
    document.body.removeChild(aiElement);
    document.body.removeChild(variantElement);
    document.body.removeChild(nonExistentElement);
    document.body.removeChild(staticElement);
    document.body.removeChild(mismatchElement);
}, `const juris = new Juris({
    components: {
        FeatureFlagRenderer: (props, context) => ({
            render: () => ({
                div: {
                    children: () => {
                        const flags = typeof props.flags === 'function' ? props.flags() : (props.flags || {});
                        const flagName = props.flag;
                        const variant = props.variant;
                        
                        if (flags && flags[flagName]) {
                            const flagValue = flags[flagName];
                            
                            // Handle boolean flags
                            if (typeof flagValue === 'boolean' && flagValue) {
                                return props.enabled ? [props.enabled] : [];
                            }
                            
                            // Handle variant flags (A/B testing)
                            if (typeof flagValue === 'string' && variant && props.variants) {
                                if (flagValue === variant && props.variants[variant]) {
                                    return [props.variants[variant]];
                                }
                            }
                            
                            // Handle object flags with enabled property
                            if (typeof flagValue === 'object' && flagValue.enabled) {
                                return props.enabled ? [props.enabled] : [];
                            }
                        }
                        
                        return props.disabled ? [props.disabled] : [];
                    }
                }
            })
        })
    }
});

juris.setState('featureFlags', {
    newFeature: false,
    abTest: 'A'
});

const element = juris.objectToHtml({
    FeatureFlagRenderer: {
        flags: () => juris.getState('featureFlags', {}),
        flag: 'newFeature',
        enabled: { div: { text: 'New Feature!', className: 'new-feature' } },
        disabled: { div: { text: 'Standard Feature', className: 'standard' } }
    }
});

// Test enabling feature
const flags = juris.getState('featureFlags', {});
juris.setState('featureFlags', { ...flags, newFeature: true });
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.querySelector('.new-feature')).toBeTruthy();
testFramework.expect(element.querySelector('.standard')).toBeFalsy();`);


testFramework.addTest('FeatureFlagRenderer Component Injection', 'Control Flow Components', async function() {
    const juris = new Juris({
        components: {
            FeatureFlagRenderer: (props, context) => ({
                render: () => ({
                    div: {
                        children: () => {
                            const flags = typeof props.flags === 'function' ? props.flags() : (props.flags || {});
                            const flagName = props.flag;
                            const variant = props.variant;
                            
                            // Check if flag exists and is enabled
                            if (flags && flags[flagName]) {
                                const flagValue = flags[flagName];
                                
                                // Handle boolean flags
                                if (typeof flagValue === 'boolean' && flagValue) {
                                    return props.enabled ? 
                                        (Array.isArray(props.enabled) ? props.enabled : [props.enabled]) : 
                                        [];
                                }
                                
                                // Handle variant flags (A/B testing)
                                if (typeof flagValue === 'string' && variant && props.variants) {
                                    if (flagValue === variant && props.variants[variant]) {
                                        const variantComponent = props.variants[variant];
                                        return Array.isArray(variantComponent) ? variantComponent : [variantComponent];
                                    }
                                }
                                
                                // Handle object flags with percentage/rules
                                if (typeof flagValue === 'object' && flagValue.enabled) {
                                    return props.enabled ? 
                                        (Array.isArray(props.enabled) ? props.enabled : [props.enabled]) : 
                                        [];
                                }
                            }
                            
                            return props.disabled ? 
                                (Array.isArray(props.disabled) ? props.disabled : [props.disabled]) : 
                                [];
                        }
                    }
                })
            }),
            NewFeature: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'new-feature',
                        children: [
                            { div: { text: '🆕 New Feature Enabled!', className: 'feature-badge' } },
                            { h3: { text: 'Enhanced Dashboard' } },
                            { div: { text: 'Experience our new and improved dashboard with advanced analytics.' } },
                            { button: { text: 'Try New Dashboard', className: 'new-feature-btn' } }
                        ]
                    }
                })
            }),
            LegacyFeature: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'legacy-feature',
                        children: [
                            { h3: { text: 'Classic Dashboard' } },
                            { div: { text: 'Using the traditional dashboard interface.' } },
                            { button: { text: 'Open Dashboard', className: 'legacy-feature-btn' } }
                        ]
                    }
                })
            }),
            VariantA: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'variant-a',
                        children: [
                            { h3: { text: 'Version A - Blue Theme' } },
                            { div: { text: 'You are seeing the blue-themed version.', style: { color: 'blue' } } },
                            { button: { text: 'Blue Action', style: { backgroundColor: 'blue', color: 'white' } } }
                        ]
                    }
                })
            }),
            VariantB: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'variant-b',
                        children: [
                            { h3: { text: 'Version B - Green Theme' } },
                            { div: { text: 'You are seeing the green-themed version.', style: { color: 'green' } } },
                            { button: { text: 'Green Action', style: { backgroundColor: 'green', color: 'white' } } }
                        ]
                    }
                })
            }),
            BetaFeature: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'beta-feature',
                        children: [
                            { div: { text: '🧪 Beta Feature', className: 'beta-badge' } },
                            { h3: { text: 'AI Assistant' } },
                            { div: { text: 'Try our new AI-powered assistant (Beta).' } },
                            { button: { text: 'Enable AI Assistant', className: 'beta-btn' } }
                        ]
                    }
                })
            }),
            StandardVersion: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'standard-version',
                        children: [
                            { h3: { text: 'Standard Version' } },
                            { div: { text: 'You are using the standard version of this feature.' } }
                        ]
                    }
                })
            })
        }
    });
    
    // Initialize feature flags
    juris.setState('featureFlags', {
        newDashboard: false,
        betaFeatures: true,
        aiAssistant: { enabled: true, rolloutPercentage: 50 },
        themeTest: 'A'
    });
    
    // Test boolean feature flag (disabled)
    const dashboardElement = juris.objectToHtml({
        FeatureFlagRenderer: {
            flags: () => juris.getState('featureFlags', {}),
            flag: 'newDashboard',
            enabled: { NewFeature: {} },
            disabled: { LegacyFeature: {} }
        }
    });
    
    document.body.appendChild(dashboardElement);
    
    // Test disabled feature (should show legacy)
    testFramework.expect(dashboardElement.querySelector('.legacy-feature')).toBeTruthy();
    testFramework.expect(dashboardElement.textContent).toContain('Classic Dashboard');
    testFramework.expect(dashboardElement.querySelector('.new-feature')).toBeFalsy();
    
    // Test enabling the feature flag
    const currentFlags = juris.getState('featureFlags', {});
    juris.setState('featureFlags', { ...currentFlags, newDashboard: true });
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(dashboardElement.querySelector('.new-feature')).toBeTruthy();
    testFramework.expect(dashboardElement.textContent).toContain('New Feature Enabled');
    testFramework.expect(dashboardElement.querySelector('.legacy-feature')).toBeFalsy();
    
    // Test boolean feature flag (enabled)
    const betaElement = juris.objectToHtml({
        FeatureFlagRenderer: {
            flags: () => juris.getState('featureFlags', {}),
            flag: 'betaFeatures',
            enabled: { BetaFeature: {} },
            disabled: { StandardVersion: {} }
        }
    });
    
    document.body.appendChild(betaElement);
    
    testFramework.expect(betaElement.querySelector('.beta-feature')).toBeTruthy();
    testFramework.expect(betaElement.textContent).toContain('Beta Feature');
    testFramework.expect(betaElement.querySelector('.standard-version')).toBeFalsy();
    
    // Test object feature flag with enabled property
    const aiElement = juris.objectToHtml({
        FeatureFlagRenderer: {
            flags: () => juris.getState('featureFlags', {}),
            flag: 'aiAssistant',
            enabled: { BetaFeature: {} },
            disabled: { StandardVersion: {} }
        }
    });
    
    document.body.appendChild(aiElement);
    
    testFramework.expect(aiElement.querySelector('.beta-feature')).toBeTruthy();
    testFramework.expect(aiElement.textContent).toContain('AI Assistant');
    testFramework.expect(aiElement.querySelector('.standard-version')).toBeFalsy();
    
    // Test A/B testing with variants - Create separate elements for A and B
    const variantAElement = juris.objectToHtml({
        FeatureFlagRenderer: {
            flags: () => juris.getState('featureFlags', {}),
            flag: 'themeTest',
            variant: 'A',
            variants: {
                A: { VariantA: {} },
                B: { VariantB: {} }
            },
            disabled: { StandardVersion: {} }
        }
    });
    
    document.body.appendChild(variantAElement);
    
    testFramework.expect(variantAElement.querySelector('.variant-a')).toBeTruthy();
    testFramework.expect(variantAElement.textContent).toContain('Blue Theme');
    testFramework.expect(variantAElement.querySelector('.variant-b')).toBeFalsy();
    testFramework.expect(variantAElement.querySelector('.standard-version')).toBeFalsy();
    
    // Test variant B with a separate element
    const variantBElement = juris.objectToHtml({
        FeatureFlagRenderer: {
            flags: () => juris.getState('featureFlags', {}),
            flag: 'themeTest',
            variant: 'B',
            variants: {
                A: { VariantA: {} },
                B: { VariantB: {} }
            },
            disabled: { StandardVersion: {} }
        }
    });
    
    // Switch to variant B first
    const flags = juris.getState('featureFlags', {});
    juris.setState('featureFlags', { ...flags, themeTest: 'B' });
    await new Promise(resolve => setTimeout(resolve, 10));
    
    document.body.appendChild(variantBElement);
    
    testFramework.expect(variantBElement.querySelector('.variant-b')).toBeTruthy();
    testFramework.expect(variantBElement.textContent).toContain('Green Theme');
    testFramework.expect(variantBElement.querySelector('.variant-a')).toBeFalsy();
    
    // Test non-existent flag (should show disabled)
    const nonExistentElement = juris.objectToHtml({
        FeatureFlagRenderer: {
            flags: () => juris.getState('featureFlags', {}),
            flag: 'nonExistentFeature',
            enabled: { NewFeature: {} },
            disabled: { StandardVersion: {} }
        }
    });
    
    document.body.appendChild(nonExistentElement);
    
    testFramework.expect(nonExistentElement.querySelector('.standard-version')).toBeTruthy();
    testFramework.expect(nonExistentElement.textContent).toContain('Standard Version');
    testFramework.expect(nonExistentElement.querySelector('.new-feature')).toBeFalsy();
    
    // Test static flags (non-function)
    const staticElement = juris.objectToHtml({
        FeatureFlagRenderer: {
            flags: { staticFeature: true },
            flag: 'staticFeature',
            enabled: { div: { text: 'Static Feature Enabled', className: 'static-enabled' } },
            disabled: { div: { text: 'Static Feature Disabled', className: 'static-disabled' } }
        }
    });
    
    document.body.appendChild(staticElement);
    
    testFramework.expect(staticElement.querySelector('.static-enabled')).toBeTruthy();
    testFramework.expect(staticElement.textContent).toContain('Static Feature Enabled');
    testFramework.expect(staticElement.querySelector('.static-disabled')).toBeFalsy();
    
    // Cleanup
    juris.domRenderer.cleanup(dashboardElement);
    juris.domRenderer.cleanup(betaElement);
    juris.domRenderer.cleanup(aiElement);
    juris.domRenderer.cleanup(variantAElement);
    juris.domRenderer.cleanup(variantBElement);
    juris.domRenderer.cleanup(nonExistentElement);
    juris.domRenderer.cleanup(staticElement);
    document.body.removeChild(dashboardElement);
    document.body.removeChild(betaElement);
    document.body.removeChild(aiElement);
    document.body.removeChild(variantAElement);
    document.body.removeChild(variantBElement);
    document.body.removeChild(nonExistentElement);
    document.body.removeChild(staticElement);
}, `const juris = new Juris({
    components: {
        FeatureFlagRenderer: (props, context) => ({
            render: () => ({
                div: {
                    children: () => {
                        const flags = typeof props.flags === 'function' ? props.flags() : (props.flags || {});
                        const flagName = props.flag;
                        const variant = props.variant;
                        
                        if (flags && flags[flagName]) {
                            const flagValue = flags[flagName];
                            
                            // Handle boolean flags
                            if (typeof flagValue === 'boolean' && flagValue) {
                                return props.enabled ? [props.enabled] : [];
                            }
                            
                            // Handle variant flags (A/B testing)
                            if (typeof flagValue === 'string' && variant && props.variants) {
                                if (flagValue === variant && props.variants[variant]) {
                                    return [props.variants[variant]];
                                }
                            }
                            
                            // Handle object flags with enabled property
                            if (typeof flagValue === 'object' && flagValue.enabled) {
                                return props.enabled ? [props.enabled] : [];
                            }
                        }
                        
                        return props.disabled ? [props.disabled] : [];
                    }
                }
            })
        })
    }
});

juris.setState('featureFlags', {
    newFeature: false,
    abTest: 'A'
});

const element = juris.objectToHtml({
    FeatureFlagRenderer: {
        flags: () => juris.getState('featureFlags', {}),
        flag: 'newFeature',
        enabled: { div: { text: 'New Feature!', className: 'new-feature' } },
        disabled: { div: { text: 'Standard Feature', className: 'standard' } }
    }
});

// Test enabling feature
const flags = juris.getState('featureFlags', {});
juris.setState('featureFlags', { ...flags, newFeature: true });
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.querySelector('.new-feature')).toBeTruthy();
testFramework.expect(element.querySelector('.standard')).toBeFalsy();`);

testFramework.addTest('PaginationRenderer Component Injection', 'Control Flow Components', async function() {
    const juris = new Juris({
        components: {
            PaginationRenderer: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'pagination-container',
                        children: () => {
                            const currentPage = typeof props.currentPage === 'function' ? props.currentPage() : (props.currentPage || 1);
                            const itemsPerPage = props.itemsPerPage || 10;
                            const totalItems = typeof props.totalItems === 'function' ? props.totalItems() : (props.totalItems || 0);
                            const totalPages = Math.ceil(totalItems / itemsPerPage);
                            const showPageNumbers = props.showPageNumbers !== false;
                            
                            const startItem = (currentPage - 1) * itemsPerPage + 1;
                            const endItem = Math.min(currentPage * itemsPerPage, totalItems);
                            
                            return [
                                // Content area
                                props.contentComponent ? props.contentComponent : {
                                    div: {
                                        className: 'pagination-content',
                                        text: `Showing items ${startItem}-${endItem} of ${totalItems}`
                                    }
                                },
                                
                                // Pagination info
                                totalItems > 0 ? {
                                    div: {
                                        className: 'pagination-info',
                                        text: `Page ${currentPage} of ${totalPages} (${totalItems} total items)`
                                    }
                                } : null,
                                
                                // Pagination controls
                                totalPages > 1 ? {
                                    div: {
                                        className: 'pagination-controls',
                                        children: [
                                            // Previous button
                                            {
                                                button: {
                                                    text: '← Previous',
                                                    disabled: currentPage <= 1,
                                                    onclick: () => props.onPageChange && props.onPageChange(currentPage - 1),
                                                    className: 'pagination-btn prev-btn'
                                                }
                                            },
                                            
                                            // Page numbers (if enabled)
                                            ...(showPageNumbers ? (() => {
                                                const pageButtons = [];
                                                const maxButtons = props.maxPageButtons || 5;
                                                let startPage = Math.max(1, currentPage - Math.floor(maxButtons / 2));
                                                let endPage = Math.min(totalPages, startPage + maxButtons - 1);
                                                
                                                // Adjust start if we're near the end
                                                if (endPage - startPage + 1 < maxButtons) {
                                                    startPage = Math.max(1, endPage - maxButtons + 1);
                                                }
                                                
                                                // First page + ellipsis if needed
                                                if (startPage > 1) {
                                                    pageButtons.push({
                                                        button: {
                                                            text: '1',
                                                            onclick: () => props.onPageChange && props.onPageChange(1),
                                                            className: 'pagination-btn page-btn'
                                                        }
                                                    });
                                                    if (startPage > 2) {
                                                        pageButtons.push({
                                                            span: { text: '...', className: 'pagination-ellipsis' }
                                                        });
                                                    }
                                                }
                                                
                                                // Page number buttons
                                                for (let i = startPage; i <= endPage; i++) {
                                                    pageButtons.push({
                                                        button: {
                                                            text: i.toString(),
                                                            onclick: () => props.onPageChange && props.onPageChange(i),
                                                            className: `pagination-btn page-btn ${i === currentPage ? 'active' : ''}`
                                                        }
                                                    });
                                                }
                                                
                                                // Last page + ellipsis if needed
                                                if (endPage < totalPages) {
                                                    if (endPage < totalPages - 1) {
                                                        pageButtons.push({
                                                            span: { text: '...', className: 'pagination-ellipsis' }
                                                        });
                                                    }
                                                    pageButtons.push({
                                                        button: {
                                                            text: totalPages.toString(),
                                                            onclick: () => props.onPageChange && props.onPageChange(totalPages),
                                                            className: 'pagination-btn page-btn'
                                                        }
                                                    });
                                                }
                                                
                                                return pageButtons;
                                            })() : []),
                                            
                                            // Next button
                                            {
                                                button: {
                                                    text: 'Next →',
                                                    disabled: currentPage >= totalPages,
                                                    onclick: () => props.onPageChange && props.onPageChange(currentPage + 1),
                                                    className: 'pagination-btn next-btn'
                                                }
                                            }
                                        ]
                                    }
                                } : null
                            ].filter(Boolean);
                        }
                    }
                })
            }),
            DataTable: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'data-table',
                        children: [
                            { h3: { text: 'User Data Table' } },
                            {
                                table: {
                                    children: [
                                        {
                                            thead: {
                                                children: [{
                                                    tr: {
                                                        children: [
                                                            { th: { text: 'ID' } },
                                                            { th: { text: 'Name' } },
                                                            { th: { text: 'Email' } },
                                                            { th: { text: 'Role' } }
                                                        ]
                                                    }
                                                }]
                                            }
                                        },
                                        {
                                            tbody: {
                                                children: () => {
                                                    const currentPage = context.getState('pagination.currentPage', 1);
                                                    const itemsPerPage = 5;
                                                    const allUsers = context.getState('users.list', []);
                                                    const startIndex = (currentPage - 1) * itemsPerPage;
                                                    const endIndex = startIndex + itemsPerPage;
                                                    const pageUsers = allUsers.slice(startIndex, endIndex);
                                                    
                                                    return pageUsers.map((user, index) => ({
                                                        tr: {
                                                            key: user.id,
                                                            children: [
                                                                { td: { text: user.id } },
                                                                { td: { text: user.name } },
                                                                { td: { text: user.email } },
                                                                { td: { text: user.role } }
                                                            ]
                                                        }
                                                    }));
                                                }
                                            }
                                        }
                                    ]
                                }
                            }
                        ]
                    }
                })
            }),
            SimpleContent: (props, context) => ({
                render: () => ({
                    div: {
                        className: 'simple-content',
                        children: [
                            { h3: { text: 'Content Area' } },
                            { div: { text: () => `Currently on page ${context.getState('pagination.currentPage', 1)}` } }
                        ]
                    }
                })
            })
        }
    });
    
    // Initialize pagination state and sample data
    juris.setState('pagination.currentPage', 1);
    juris.setState('pagination.totalItems', 47);
    juris.setState('users.list', Array.from({ length: 47 }, (_, i) => ({
        id: i + 1,
        name: `User ${i + 1}`,
        email: `user${i + 1}@example.com`,
        role: ['Admin', 'User', 'Moderator'][i % 3]
    })));
    
    const element = juris.objectToHtml({
        PaginationRenderer: {
            currentPage: () => juris.getState('pagination.currentPage', 1),
            totalItems: () => juris.getState('pagination.totalItems', 0),
            itemsPerPage: 5,
            maxPageButtons: 5,
            contentComponent: { DataTable: {} },
            onPageChange: (page) => {
                juris.setState('pagination.currentPage', page);
            }
        }
    });
    
    document.body.appendChild(element);
    
    // Test initial page (page 1)
    testFramework.expect(element.querySelector('.data-table')).toBeTruthy();
    testFramework.expect(element.querySelector('.pagination-info')).toBeTruthy();
    testFramework.expect(element.textContent).toContain('Page 1 of 10');
    testFramework.expect(element.textContent).toContain('47 total items');
    testFramework.expect(element.querySelector('.prev-btn').disabled).toBe(true);
    testFramework.expect(element.querySelector('.next-btn').disabled).toBe(false);
    testFramework.expect(element.querySelector('.page-btn.active').textContent).toBe('1');
    
    // Test navigation to page 2
    juris.setState('pagination.currentPage', 2);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.textContent).toContain('Page 2 of 10');
    testFramework.expect(element.querySelector('.prev-btn').disabled).toBe(false);
    testFramework.expect(element.querySelector('.next-btn').disabled).toBe(false);
    testFramework.expect(element.querySelector('.page-btn.active').textContent).toBe('2');
    
    // Test navigation to middle page (page 5)
    juris.setState('pagination.currentPage', 5);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.textContent).toContain('Page 5 of 10');
    testFramework.expect(element.querySelector('.page-btn.active').textContent).toBe('5');
    testFramework.expect(element.querySelectorAll('.page-btn').length).toBeGreaterThan(0);
    
    // Test navigation to last page (page 10)
    juris.setState('pagination.currentPage', 10);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(element.textContent).toContain('Page 10 of 10');
    testFramework.expect(element.querySelector('.prev-btn').disabled).toBe(false);
    testFramework.expect(element.querySelector('.next-btn').disabled).toBe(true);
    testFramework.expect(element.querySelector('.page-btn.active').textContent).toBe('10');
    
    // Test clicking next button from page 1
    juris.setState('pagination.currentPage', 1);
    await new Promise(resolve => setTimeout(resolve, 10));
    
    const nextButton = element.querySelector('.next-btn');
    nextButton.click();
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(juris.getState('pagination.currentPage')).toBe(2);
    
    // Test clicking previous button
    const prevButton = element.querySelector('.prev-btn');
    prevButton.click();
    await new Promise(resolve => setTimeout(resolve, 10));
    
    testFramework.expect(juris.getState('pagination.currentPage')).toBe(1);
    
    // Test clicking page number button
    const pageThreeButton = Array.from(element.querySelectorAll('.page-btn')).find(btn => btn.textContent === '3');
    if (pageThreeButton) {
        pageThreeButton.click();
        await new Promise(resolve => setTimeout(resolve, 10));
        testFramework.expect(juris.getState('pagination.currentPage')).toBe(3);
    }
    
    // Test with no pagination needed (small dataset)
    const smallElement = juris.objectToHtml({
        PaginationRenderer: {
            currentPage: 1,
            totalItems: 3,
            itemsPerPage: 10,
            contentComponent: { SimpleContent: {} }
        }
    });
    
    document.body.appendChild(smallElement);
    
    testFramework.expect(smallElement.querySelector('.simple-content')).toBeTruthy();
    testFramework.expect(smallElement.querySelector('.pagination-controls')).toBeFalsy();
    testFramework.expect(smallElement.textContent).toContain('Page 1 of 1');
    
    // Test with no items
    const emptyElement = juris.objectToHtml({
        PaginationRenderer: {
            currentPage: 1,
            totalItems: 0,
            itemsPerPage: 10,
            contentComponent: { div: { text: 'No data', className: 'no-data' } }
        }
    });
    
    document.body.appendChild(emptyElement);
    
    testFramework.expect(emptyElement.querySelector('.no-data')).toBeTruthy();
    testFramework.expect(emptyElement.querySelector('.pagination-info')).toBeFalsy();
    testFramework.expect(emptyElement.querySelector('.pagination-controls')).toBeFalsy();
    
    // Test pagination without page numbers
    const noPageNumbersElement = juris.objectToHtml({
        PaginationRenderer: {
            currentPage: () => juris.getState('pagination.currentPage', 1),
            totalItems: 25,
            itemsPerPage: 5,
            showPageNumbers: false,
            contentComponent: { SimpleContent: {} },
            onPageChange: (page) => juris.setState('pagination.currentPage', page)
        }
    });
    
    document.body.appendChild(noPageNumbersElement);
    
    testFramework.expect(noPageNumbersElement.querySelector('.pagination-controls')).toBeTruthy();
    testFramework.expect(noPageNumbersElement.querySelector('.prev-btn')).toBeTruthy();
    testFramework.expect(noPageNumbersElement.querySelector('.next-btn')).toBeTruthy();
    testFramework.expect(noPageNumbersElement.querySelector('.page-btn')).toBeFalsy();
    
    // Cleanup
    juris.domRenderer.cleanup(element);
    juris.domRenderer.cleanup(smallElement);
    juris.domRenderer.cleanup(emptyElement);
    juris.domRenderer.cleanup(noPageNumbersElement);
    document.body.removeChild(element);
    document.body.removeChild(smallElement);
    document.body.removeChild(emptyElement);
    document.body.removeChild(noPageNumbersElement);
}, `const juris = new Juris({
    components: {
        PaginationRenderer: (props, context) => ({
            render: () => ({
                div: {
                    className: 'pagination-container',
                    children: () => {
                        const currentPage = typeof props.currentPage === 'function' ? props.currentPage() : (props.currentPage || 1);
                        const itemsPerPage = props.itemsPerPage || 10;
                        const totalItems = typeof props.totalItems === 'function' ? props.totalItems() : (props.totalItems || 0);
                        const totalPages = Math.ceil(totalItems / itemsPerPage);
                        
                        return [
                            props.contentComponent || { div: { text: 'Content here' } },
                            totalPages > 1 ? {
                                div: {
                                    className: 'pagination-controls',
                                    children: [
                                        {
                                            button: {
                                                text: 'Previous',
                                                disabled: currentPage <= 1,
                                                onclick: () => props.onPageChange && props.onPageChange(currentPage - 1)
                                            }
                                        },
                                        { span: { text: \`Page \${currentPage} of \${totalPages}\` } },
                                        {
                                            button: {
                                                text: 'Next',
                                                disabled: currentPage >= totalPages,
                                                onclick: () => props.onPageChange && props.onPageChange(currentPage + 1)
                                            }
                                        }
                                    ]
                                }
                            } : null
                        ].filter(Boolean);
                    }
                }
            })
        })
    }
});

juris.setState('pagination.currentPage', 1);

const element = juris.objectToHtml({
    PaginationRenderer: {
        currentPage: () => juris.getState('pagination.currentPage', 1),
        totalItems: 50,
        itemsPerPage: 10,
        contentComponent: { div: { text: 'Page content', className: 'content' } },
        onPageChange: (page) => juris.setState('pagination.currentPage', page)
    }
});

// Test navigation
juris.setState('pagination.currentPage', 2);
await new Promise(resolve => setTimeout(resolve, 10));

testFramework.expect(element.textContent).toContain('Page 2 of 5');

// Test button clicks
const nextButton = element.querySelector('button[disabled="false"]');
if (nextButton && nextButton.textContent === 'Next') {
    nextButton.click();
    await new Promise(resolve => setTimeout(resolve, 10));
    testFramework.expect(juris.getState('pagination.currentPage')).toBe(3);
}`);


// Async Component Test Cases for Juris Framework

// Test 1: Basic Async Component
testFramework.addTest('Basic Async Component', 'Async Components', async function() {
    const juris = new Juris();
    
    const AsyncGreeting = async (props, context) => {
        // Simulate async operation (API call, etc.)
        await new Promise(resolve => setTimeout(resolve, 50));
        
        return {
            div: {
                text: `Hello, ${props.name}!`,
                className: 'async-greeting'
            }
        };
    };
    
    juris.registerComponent('AsyncGreeting', AsyncGreeting);
    
    const element = juris.componentManager.create('AsyncGreeting', { name: 'Async World' });
    
    // Add to DOM so replacement can work
    document.body.appendChild(element);
    
    // Should initially show placeholder
    testFramework.expect(element.className).toBe('juris-async-loading');
    testFramework.expect(element.textContent).toBe('Loading AsyncGreeting...');
    
    // Wait for async resolution
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // Should now show the real content (element should be replaced)
    const realElement = document.querySelector('.async-greeting');
    
    testFramework.expect(realElement.textContent).toBe('Hello, Async World!');
    testFramework.expect(realElement.className).toBe('async-greeting');
    
    // Cleanup
    if (realElement && realElement.parentNode) {
        realElement.parentNode.removeChild(realElement);
    }
}, `const juris = new Juris();

const AsyncGreeting = async (props, context) => {
    await new Promise(resolve => setTimeout(resolve, 50));
    
    return {
        div: {
            text: \`Hello, \${props.name}!\`,
            className: 'async-greeting'
        }
    };
};

juris.registerComponent('AsyncGreeting', AsyncGreeting);

const element = juris.componentManager.create('AsyncGreeting', { name: 'Async World' });

// Initially shows placeholder
testFramework.expect(element.className).toBe('juris-async-loading');

// After resolution shows real content
setTimeout(() => {
    const realElement = element.parentNode.querySelector('.async-greeting');
    testFramework.expect(realElement.textContent).toBe('Hello, Async World!');
}, 100);`);

// Test 2: Async Component with State
testFramework.addTest('Async Component with State', 'Async Components', async function() {
    const juris = new Juris();
    
    const AsyncCounter = async (props, context) => {
        // Simulate fetching initial count from API
        await new Promise(resolve => setTimeout(resolve, 30));
        
        const [count, setCount] = context.newState('count', props.initialCount || 0);
        
        return {
            div: {
                className: 'async-counter',
                children: [
                    {
                        span: {
                            text: () => `Count: ${count()}`
                        }
                    },
                    {
                        button: {
                            text: 'Increment',
                            onclick: () => setCount(count() + 1)
                        }
                    }
                ]
            }
        };
    };
    
    juris.registerComponent('AsyncCounter', AsyncCounter);
    
    const element = juris.componentManager.create('AsyncCounter', { initialCount: 5 });
    
    // Add to DOM for replacement to work
    document.body.appendChild(element);
    
    // Initially placeholder
    testFramework.expect(element.className).toBe('juris-async-loading');
    
    // Wait for resolution
    await new Promise(resolve => setTimeout(resolve, 60));
    
    // Check for real element after replacement
    const realElement = document.querySelector('.async-counter');
    testFramework.expect(realElement.className).toBe('async-counter');
    
    // Cleanup
    if (realElement && realElement.parentNode) {
        realElement.parentNode.removeChild(realElement);
    }
    
}, `const AsyncCounter = async (props, context) => {
    await new Promise(resolve => setTimeout(resolve, 30));
    
    const [count, setCount] = context.newState('count', props.initialCount || 0);
    
    return {
        div: {
            className: 'async-counter',
            children: [
                { span: { text: () => \`Count: \${count()}\` } },
                { button: { text: 'Increment', onclick: () => setCount(count() + 1) } }
            ]
        }
    };
};`);

// Test 4: Async Lifecycle Component
testFramework.addTest('Async Lifecycle Hooks', 'Async Components', async function() {
    const juris = new Juris();
    
    let mountedData = null;
    let componentCreated = false;
    
    // Simpler sync component with async lifecycle hooks
    const AsyncLifecycle = (props, context) => {
        componentCreated = true;
        const [data, setData] = context.newState('data', 'initial');
        
        return {
            hooks: {
                onMount: async () => {
                    console.log('onMount called'); // Debug log
                    await new Promise(resolve => setTimeout(resolve, 20));
                    mountedData = 'mounted';
                    setData('mounted');
                    console.log('onMount completed, mountedData:', mountedData); // Debug log
                }
            },
            render: () => ({
                div: {
                    text: () => `Data: ${data()}`,
                    className: 'async-lifecycle'
                }
            })
        };
    };
    
    juris.registerComponent('AsyncLifecycle', AsyncLifecycle);
    
    const element = juris.componentManager.create('AsyncLifecycle', { value: 1 });
    
    // Add to DOM
    document.body.appendChild(element);
    
    // Verify component was created
    testFramework.expect(componentCreated).toBe(true);
    
    // Wait longer for mount
    await new Promise(resolve => setTimeout(resolve, 100));
    
    console.log('After waiting, mountedData:', mountedData); // Debug log
    
    // Check if element has the right class
    const actualElement = document.querySelector('.async-lifecycle') || element;
    console.log('Found element:', actualElement.className); // Debug log
    
    testFramework.expect(mountedData).toBe('mounted');
    
    // Cleanup
    if (actualElement && actualElement.parentNode) {
        actualElement.parentNode.removeChild(actualElement);
    }
    
}, `const AsyncLifecycle = (props, context) => {
    const [data, setData] = context.newState('data', 'initial');
    
    return {
        onMount: async () => {
            await new Promise(resolve => setTimeout(resolve, 20));
            setData('mounted');
        },
        
        render: () => ({
            div: {
                text: () => \`Data: \${data()}\`,
                className: 'async-lifecycle'
            }
        })
    };
};`);

// Test 5: Mixed Sync/Async Components
testFramework.addTest('Mixed Sync and Async Components', 'Async Components', async function() {
    const juris = new Juris();
    
    // Sync component
    const SyncComponent = (props) => ({
        span: {
            text: `Sync: ${props.value}`,
            className: 'sync-component'
        }
    });
    
    // Async component
    const AsyncComponent = async (props) => {
        await new Promise(resolve => setTimeout(resolve, 25));
        return {
            span: {
                text: `Async: ${props.value}`,
                className: 'async-component'
            }
        };
    };
    
    juris.registerComponent('SyncComponent', SyncComponent);
    juris.registerComponent('AsyncComponent', AsyncComponent);
    
    const syncElement = juris.componentManager.create('SyncComponent', { value: 'immediate' });
    const asyncElement = juris.componentManager.create('AsyncComponent', { value: 'delayed' });
    
    // Add async element to DOM for replacement
    document.body.appendChild(asyncElement);
    
    // Sync component should be ready immediately
    testFramework.expect(syncElement.className).toBe('sync-component');
    testFramework.expect(syncElement.textContent).toBe('Sync: immediate');
    
    // Async component should show placeholder initially
    testFramework.expect(asyncElement.className).toBe('juris-async-loading');
    
    // Wait for async resolution
    await new Promise(resolve => setTimeout(resolve, 50));
    
    // Async component should now be resolved
    const resolvedAsync = document.querySelector('.async-component');
    testFramework.expect(resolvedAsync.textContent).toBe('Async: delayed');
    
    // Cleanup
    if (resolvedAsync && resolvedAsync.parentNode) {
        resolvedAsync.parentNode.removeChild(resolvedAsync);
    }
    
}, `// Sync component - immediate rendering
const SyncComponent = (props) => ({
    span: { text: \`Sync: \${props.value}\`, className: 'sync-component' }
});

// Async component - shows placeholder then resolves
const AsyncComponent = async (props) => {
    await new Promise(resolve => setTimeout(resolve, 25));
    return {
        span: { text: \`Async: \${props.value}\`, className: 'async-component' }
    };
};`);

// Test 6: Async Component Error Handling
testFramework.addTest('Async Component Error Handling', 'Async Components', async function() {
    const juris = new Juris();
    
    const FailingAsyncComponent = async (props) => {
        await new Promise(resolve => setTimeout(resolve, 20));
        throw new Error('Async component failed');
    };
    
    juris.registerComponent('FailingAsyncComponent', FailingAsyncComponent);
    
    const element = juris.componentManager.create('FailingAsyncComponent', {});
    
    // Add to DOM for replacement
    document.body.appendChild(element);
    
    // Initially shows placeholder
    testFramework.expect(element.className).toBe('juris-async-loading');
    
    // Wait for failure
    await new Promise(resolve => setTimeout(resolve, 50));
    
    // Should show error element
    const errorElement = document.querySelector('div[style*="color: red"]');
    
    testFramework.expect(errorElement.textContent).toContain('Component Error');
    testFramework.expect(errorElement.textContent).toContain('Async component failed');
    
    // Cleanup
    if (errorElement && errorElement.parentNode) {
        errorElement.parentNode.removeChild(errorElement);
    }
    
}, `const FailingAsyncComponent = async (props) => {
    await new Promise(resolve => setTimeout(resolve, 20));
    throw new Error('Async component failed');
};

// Shows placeholder initially, then error element after failure`);

// Test 7: Async Component with Data Fetching
testFramework.addTest('Async Data Fetching Component', 'Async Components', async function() {
    const juris = new Juris();
    
    // Mock API
    const mockFetch = async (url) => {
        await new Promise(resolve => setTimeout(resolve, 30));
        return {
            json: async () => ({
                users: [
                    { id: 1, name: 'Alice' },
                    { id: 2, name: 'Bob' }
                ]
            })
        };
    };
    
    const UserList = async (props, context) => {
        const response = await mockFetch('/api/users');
        const data = await response.json();
        
        return {
            ul: {
                className: 'user-list',
                children: data.users.map(user => ({
                    li: {
                        text: user.name,
                        key: user.id
                    }
                }))
            }
        };
    };
    
    juris.registerComponent('UserList', UserList);
    
    const element = juris.componentManager.create('UserList', {});
    
    // Add to DOM for replacement
    document.body.appendChild(element);
    
    // Initially placeholder
    testFramework.expect(element.className).toBe('juris-async-loading');
    
    // Wait for data fetching
    await new Promise(resolve => setTimeout(resolve, 80));
    
    const userList = document.querySelector('.user-list');
    testFramework.expect(userList.tagName.toLowerCase()).toBe('ul');
    testFramework.expect(userList.children.length).toBe(2);
    testFramework.expect(userList.children[0].textContent).toBe('Alice');
    testFramework.expect(userList.children[1].textContent).toBe('Bob');
    
    // Cleanup
    if (userList && userList.parentNode) {
        userList.parentNode.removeChild(userList);
    }
    
}, `const UserList = async (props, context) => {
    const response = await fetch('/api/users');
    const data = await response.json();
    
    return {
        ul: {
            className: 'user-list',
            children: data.users.map(user => ({
                li: { text: user.name, key: user.id }
            }))
        }
    };
};`);

// Test 8: Async Component Performance (no double-rendering)
testFramework.addTest('Async Component Performance', 'Async Components', async function() {
    const juris = new Juris();
    
    let renderCount = 0;
    
    const PerformanceTest = async (props, context) => {
        await new Promise(resolve => setTimeout(resolve, 20));
        
        return {
            render: () => {
                renderCount++;
                return {
                    div: {
                        text: `Render count: ${renderCount}`,
                        className: 'performance-test'
                    }
                };
            }
        };
    };
    
    juris.registerComponent('PerformanceTest', PerformanceTest);
    
    const element = juris.componentManager.create('PerformanceTest', {});
    
    // Add to DOM for replacement
    document.body.appendChild(element);
    
    // Wait for async resolution
    await new Promise(resolve => setTimeout(resolve, 50));
    
    // Should only render once after async resolution
    testFramework.expect(renderCount).toBe(1);
    
    const testElement = document.querySelector('.performance-test');
    testFramework.expect(testElement.textContent).toBe('Render count: 1');
    
    // Cleanup
    if (testElement && testElement.parentNode) {
        testElement.parentNode.removeChild(testElement);
    }
    
}, `const PerformanceTest = async (props, context) => {
    await new Promise(resolve => setTimeout(resolve, 20));
    
    return {
        render: () => {
            renderCount++;
            return {
                div: { text: \`Render count: \${renderCount}\` }
            };
        }
    };
};

// Should only render once after async resolution`);

// Test 1: Basic Async Props Resolution
testFramework.addTest('Basic Async Props Resolution', 'Async Props', async function() {
    const juris = new Juris();
    
    const AsyncPropsComponent = (props, context) => ({
        div: {
            text: `User: ${props.user.name}, Age: ${props.age}`,
            className: 'async-props-test'
        }
    });
    
    juris.registerComponent('AsyncPropsComponent', AsyncPropsComponent);
    
    const element = juris.componentManager.create('AsyncPropsComponent', {
        user: Promise.resolve({ name: 'John Doe', id: 1 }),
        age: 25  // sync prop
    });
    
    // Add to DOM for replacement
    document.body.appendChild(element);
    
    // Wait for async props resolution
    await new Promise(resolve => setTimeout(resolve, 50));
    
    const testElement = document.querySelector('.async-props-test');
    testFramework.expect(testElement).toBeTruthy();
    testFramework.expect(testElement.textContent).toBe('User: John Doe, Age: 25');
    
    // Cleanup
    if (testElement && testElement.parentNode) {
        testElement.parentNode.removeChild(testElement);
    }
    
}, `const AsyncPropsComponent = (props, context) => ({
    div: {
        text: \`User: \${props.user.name}, Age: \${props.age}\`,
        className: 'async-props-test'
    }
});

// Props with promises are automatically resolved
{
    user: Promise.resolve({ name: 'John Doe', id: 1 }),
    age: 25  // sync prop works normally
}`);

// Test 2: Multiple Async Props Resolution
testFramework.addTest('Multiple Async Props Resolution', 'Async Props', async function() {
    const juris = new Juris();
    
    const MultiAsyncComponent = (props, context) => ({
        div: {
            children: [
                { h3: { text: props.title } },
                { p: { text: `User: ${props.user.name}` } },
                { p: { text: `Posts count: ${props.posts.length}` } }
            ],
            className: 'multi-async-test'
        }
    });
    
    juris.registerComponent('MultiAsyncComponent', MultiAsyncComponent);
    
    const element = juris.componentManager.create('MultiAsyncComponent', {
        title: 'Dashboard',  // sync
        user: new Promise(resolve => 
            setTimeout(() => resolve({ name: 'Alice' }), 10)
        ),
        posts: new Promise(resolve => 
            setTimeout(() => resolve([{id: 1}, {id: 2}, {id: 3}]), 20)
        )
    });
    
    document.body.appendChild(element);
    
    // Wait for all async props to resolve
    await new Promise(resolve => setTimeout(resolve, 100));
    
    const testElement = document.querySelector('.multi-async-test');
    testFramework.expect(testElement).toBeTruthy();
    testFramework.expect(testElement.querySelector('h3').textContent).toBe('Dashboard');
    testFramework.expect(testElement.querySelectorAll('p')[0].textContent).toBe('User: Alice');
    testFramework.expect(testElement.querySelectorAll('p')[1].textContent).toBe('Posts count: 3');
    
    // Cleanup
    if (testElement && testElement.parentNode) {
        testElement.parentNode.removeChild(testElement);
    }
    
}, `const MultiAsyncComponent = (props, context) => ({
    div: {
        children: [
            { h3: { text: props.title } },
            { p: { text: \`User: \${props.user.name}\` } },
            { p: { text: \`Posts count: \${props.posts.length}\` } }
        ]
    }
});

// Multiple async props resolve in parallel
{
    title: 'Dashboard',  // sync prop
    user: Promise.resolve({ name: 'Alice' }),
    posts: Promise.resolve([{id: 1}, {id: 2}, {id: 3}])
}`);

// Test 3: Async Props Error Handling
testFramework.addTest('Async Props Error Handling', 'Async Props', async function() {
    const juris = new Juris();
    
    const ErrorHandlingComponent = (props, context) => ({
        div: {
            children: [
                { p: { text: props.validData } },
                { p: { 
                    text: props.failedData.__asyncError ? 
                        `Error: ${props.failedData.__asyncError}` : 
                        `Data: ${props.failedData}`,
                    className: 'error-message'
                } }
            ],
            className: 'error-handling-test'
        }
    });
    
    juris.registerComponent('ErrorHandlingComponent', ErrorHandlingComponent);
    
    const element = juris.componentManager.create('ErrorHandlingComponent', {
        validData: Promise.resolve('Success!'),
        failedData: Promise.reject(new Error('Network error'))
    });
    
    document.body.appendChild(element);
    
    // Wait for async props resolution
    await new Promise(resolve => setTimeout(resolve, 50));
    
    const testElement = document.querySelector('.error-handling-test');
    testFramework.expect(testElement).toBeTruthy();
    testFramework.expect(testElement.querySelectorAll('p')[0].textContent).toBe('Success!');
    testFramework.expect(testElement.querySelector('.error-message').textContent).toBe('Error: Network error');
    
    // Cleanup
    if (testElement && testElement.parentNode) {
        testElement.parentNode.removeChild(testElement);
    }
    
}, `const ErrorHandlingComponent = (props, context) => ({
    div: {
        children: [
            { p: { text: props.validData } },
            { p: { 
                text: props.failedData.__asyncError ? 
                    \`Error: \${props.failedData.__asyncError}\` : 
                    \`Data: \${props.failedData}\`
            } }
        ]
    }
});

// Failed async props get { __asyncError: errorMessage }
{
    validData: Promise.resolve('Success!'),
    failedData: Promise.reject(new Error('Network error'))
}`);

// Test 4: Async Props with Lifecycle Components
testFramework.addTest('Async Props with Lifecycle Components', 'Async Props', async function() {
    const juris = new Juris();
    
    let mountCallCount = 0;
    
    const LifecycleAsyncComponent = (props, context) => ({
        hooks: {
            onMount: () => {
                mountCallCount++;
            }
        },
        render: () => ({
            div: {
                text: `Data: ${props.data.value}, Status: ${props.status}`,
                className: 'lifecycle-async-test'
            }
        })
    });
    
    juris.registerComponent('LifecycleAsyncComponent', LifecycleAsyncComponent);
    
    const element = juris.componentManager.create('LifecycleAsyncComponent', {
        data: Promise.resolve({ value: 'Initial' }),
        status: 'loading'
    });
    
    document.body.appendChild(element);
    
    // Wait for async props and onMount
    await new Promise(resolve => setTimeout(resolve, 100));
    
    testFramework.expect(mountCallCount).toBe(1);
    
    const testElement = document.querySelector('.lifecycle-async-test');
    testFramework.expect(testElement).toBeTruthy();
    testFramework.expect(testElement.textContent).toBe('Data: Initial, Status: loading');
    
    // Cleanup
    if (testElement && testElement.parentNode) {
        testElement.parentNode.removeChild(testElement);
    }
    
}, `const LifecycleAsyncComponent = (props, context) => ({
    hooks: {
        onMount: () => mountCallCount++
    },
    render: () => ({
        div: {
            text: \`Data: \${props.data.value}, Status: \${props.status}\`
        }
    })
});

// Lifecycle hooks work normally with async props
// onMount called after async props resolve`);

// Test 5: Async Props Caching
testFramework.addTest('Async Props Caching', 'Async Props', async function() {
    const juris = new Juris();
    
    let fetchCount = 0;
    
    const cachedDataPromise = new Promise(resolve => {
        fetchCount++;
        setTimeout(() => resolve({ count: fetchCount }), 10);
    });
    
    const CachingComponent = (props, context) => ({
        div: {
            text: `Fetch count: ${props.data.count}`,
            className: 'caching-test'
        }
    });
    
    juris.registerComponent('CachingComponent', CachingComponent);
    
    // Create first component
    const element1 = juris.componentManager.create('CachingComponent', {
        data: cachedDataPromise,
        id: 1
    });
    
    // Create second component with same promise (should use cache)
    const element2 = juris.componentManager.create('CachingComponent', {
        data: cachedDataPromise,
        id: 2
    });
    
    document.body.appendChild(element1);
    document.body.appendChild(element2);
    
    // Wait for async props resolution
    await new Promise(resolve => setTimeout(resolve, 100));
    
    const testElements = document.querySelectorAll('.caching-test');
    testFramework.expect(testElements.length).toBe(2);
    
    // Both should show the same fetch count (cached)
    testFramework.expect(testElements[0].textContent).toBe('Fetch count: 1');
    testFramework.expect(testElements[1].textContent).toBe('Fetch count: 1');
    
    // Verify cache stats
    const stats = juris.componentManager.getAsyncStats();
    testFramework.expect(stats.cachedAsyncProps).toBeGreaterThan(0);
    
    // Cleanup
    testElements.forEach(el => {
        if (el.parentNode) {
            el.parentNode.removeChild(el);
        }
    });
    
}, `// Same promise used multiple times should be cached
const cachedDataPromise = Promise.resolve({ data: 'shared' });

// Both components use same promise
create('Component1', { data: cachedDataPromise });
create('Component2', { data: cachedDataPromise });

// Promise resolved only once, result cached for 5 seconds`);

// Test 6: Mixed Sync and Async Components with Async Props
testFramework.addTest('Mixed Sync and Async Components with Async Props', 'Async Props', async function() {
    const juris = new Juris();
    
    // Sync component with async props
    const SyncComponent = (props, context) => ({
        div: {
            text: `Sync: ${props.data.message}`,
            className: 'sync-with-async-props'
        }
    });
    
    // Async component with async props
    const AsyncComponent = async (props, context) => {
        await new Promise(resolve => setTimeout(resolve, 20));
        return {
            div: {
                text: `Async: ${props.data.message}`,
                className: 'async-with-async-props'
            }
        };
    };
    
    juris.registerComponent('SyncComponent', SyncComponent);
    juris.registerComponent('AsyncComponent', AsyncComponent);
    
    const asyncData = Promise.resolve({ message: 'Hello World' });
    
    const element1 = juris.componentManager.create('SyncComponent', {
        data: asyncData
    });
    
    const element2 = juris.componentManager.create('AsyncComponent', {
        data: asyncData
    });
    
    document.body.appendChild(element1);
    document.body.appendChild(element2);
    
    // Wait for both async props and async component resolution
    await new Promise(resolve => setTimeout(resolve, 150));
    
    const syncElement = document.querySelector('.sync-with-async-props');
    const asyncElement = document.querySelector('.async-with-async-props');
    
    testFramework.expect(syncElement).toBeTruthy();
    testFramework.expect(asyncElement).toBeTruthy();
    testFramework.expect(syncElement.textContent).toBe('Sync: Hello World');
    testFramework.expect(asyncElement.textContent).toBe('Async: Hello World');
    
    // Cleanup
    [syncElement, asyncElement].forEach(el => {
        if (el && el.parentNode) {
            el.parentNode.removeChild(el);
        }
    });
    
}, `// Sync component with async props
const SyncComponent = (props, context) => ({
    div: { text: \`Sync: \${props.data.message}\` }
});

// Async component with async props  
const AsyncComponent = async (props, context) => {
    await new Promise(resolve => setTimeout(resolve, 20));
    return {
        div: { text: \`Async: \${props.data.message}\` }
    };
};

// Both handle async props automatically`);

// Test 7: Async Props Performance (no double-rendering)
testFramework.addTest('Async Props Performance', 'Async Props', async function() {
    const juris = new Juris();
    
    let renderCount = 0;
    
    const PerformanceTest = (props, context) => {
        return {
            render: () => {
                renderCount++;
                return {
                    div: {
                        text: `Render count: ${renderCount}, Data: ${props.data.value}`,
                        className: 'async-props-performance-test'
                    }
                };
            }
        };
    };
    
    juris.registerComponent('PerformanceTest', PerformanceTest);
    
    const element = juris.componentManager.create('PerformanceTest', {
        data: new Promise(resolve => 
            setTimeout(() => resolve({ value: 'loaded' }), 30)
        )
    });
    
    // Add to DOM for replacement
    document.body.appendChild(element);
    
    // Wait for async props resolution
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // Should only render once after async props resolution
    testFramework.expect(renderCount).toBe(1);
    
    const testElement = document.querySelector('.async-props-performance-test');
    testFramework.expect(testElement.textContent).toBe('Render count: 1, Data: loaded');
    
    // Cleanup
    if (testElement && testElement.parentNode) {
        testElement.parentNode.removeChild(testElement);
    }
    
}, `const PerformanceTest = (props, context) => {
    return {
        render: () => {
            renderCount++;
            return {
                div: { 
                    text: \`Render count: \${renderCount}, Data: \${props.data.value}\`
                }
            };
        }
    };
};

// Should only render once after async props resolve
// No double-rendering during async props resolution`);

// Test 8: Cache Management
testFramework.addTest('Cache Management', 'Async Props', async function() {
    const juris = new Juris();
    
    const CacheTestComponent = (props, context) => ({
        div: {
            text: `Value: ${props.data}`,
            className: 'cache-mgmt-test'
        }
    });
    
    juris.registerComponent('CacheTestComponent', CacheTestComponent);
    
    // Check initial cache stats
    let stats = juris.componentManager.getAsyncStats();
    const initialCacheSize = stats.cachedAsyncProps;
    
    // Create component with async props
    const element = juris.componentManager.create('CacheTestComponent', {
        data: Promise.resolve('cached-value')
    });
    
    document.body.appendChild(element);
    await new Promise(resolve => setTimeout(resolve, 50));
    
    // Cache should have increased
    stats = juris.componentManager.getAsyncStats();
    testFramework.expect(stats.cachedAsyncProps).toBeGreaterThan(initialCacheSize);
    
    // Clear cache
    juris.componentManager.clearAsyncPropsCache();
    
    // Cache should be empty
    stats = juris.componentManager.getAsyncStats();
    testFramework.expect(stats.cachedAsyncProps).toBe(0);
    
    // Cleanup
    const testElement = document.querySelector('.cache-mgmt-test');
    if (testElement && testElement.parentNode) {
        testElement.parentNode.removeChild(testElement);
    }
    
}, `// Cache management utilities
juris.componentManager.getAsyncStats();  // Check cache size
juris.componentManager.clearAsyncPropsCache();  // Clear cache

// Cache automatically expires after 5 seconds
// Cache key based on prop structure`);





}

        // Initialize tests
        defineTests();

        // Component Definitions
        const Header = (props, context) => ({
            header: {
                style: {
                    background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                    color: 'white',
                    padding: '20px',
                    textAlign: 'center'
                },
                children: [
                    {
                        h1: {
                            style: { margin: '0 0 8px 0', fontSize: '24px' },
                            text: '🧪 Juris Test Interface'
                        }
                    },
                    {
                        p: {
                            style: { margin: '0', opacity: '0.9' },
                            text: 'Pure Juris Implementation - Testing the Framework with Itself'
                        }
                    }
                ]
            }
        });

        const TestSummary = (props, context) => ({
            div: {
                style: { 
                    marginLeft: 'auto', 
                    fontSize: '14px', 
                    display: 'flex', 
                    gap: '16px',
                    alignItems: 'center'
                },
                children: () => {
                    const results = context.getState('testResults') || {};
                    const total = Object.keys(results).length;
                    const passed = Object.values(results).filter(r => r.status === 'pass').length;
                    const failed = Object.values(results).filter(r => r.status === 'fail').length;
                    const running = Object.values(results).filter(r => r.status === 'running').length;
                    
                    if (total === 0) {
                        return [{
                            span: {
                                style: { color: '#888' },
                                text: `${testFramework.tests.size} tests available`
                            }
                        }];
                    }
                    
                    return [
                        {
                            span: {
                                style: { color: '#4CAF50', fontWeight: 'bold' },
                                text: `✓ ${passed}`
                            }
                        },
                        {
                            span: {
                                style: { color: '#f44336', fontWeight: 'bold' },
                                text: `✗ ${failed}`
                            }
                        },
                        running > 0 ? {
                            span: {
                                style: { color: '#2196F3', fontWeight: 'bold' },
                                text: `⏳ ${running}`
                            }
                        } : null,
                        {
                            span: {
                                style: { color: '#888' },
                                text: `(${total}/${testFramework.tests.size})`
                            }
                        }
                    ];
                }
            }
        });

        const Controls = (props, context) => ({
            div: {
                style: {
                    padding: '16px 20px',
                    background: '#2d2d2d',
                    borderBottom: '1px solid #444',
                    display: 'flex',
                    gap: '12px',
                    alignItems: 'center'
                },
                children: [
                    {
                        button: {
                            style: {
                                background: '#4CAF50',
                                color: 'white',
                                border: 'none',
                                padding: '8px 16px',
                                borderRadius: '4px',
                                cursor: 'pointer',
                                fontSize: '14px'
                            },
                            text: () => context.getState('isRunning') ? '⏸️ Running...' : '▶️ Run All Tests',
                            onclick: async () => {
                                if (context.getState('isRunning')) return;
                                
                                context.setState('isRunning', true);
                                
                                for (const [testName] of testFramework.tests) {
                                    context.setState(`testResults.${testName}`, { status: 'running' });
                                    const result = await testFramework.runTest(testName);
                                    context.setState(`testResults.${testName}`, result);
                                    await new Promise(resolve => setTimeout(resolve, 100));
                                }
                                
                                context.setState('isRunning', false);
                            }
                        }
                    },
                    {
                        button: {
                            style: {
                                background: '#2196F3',
                                color: 'white',
                                border: 'none',
                                padding: '8px 16px',
                                borderRadius: '4px',
                                cursor: 'pointer',
                                fontSize: '14px'
                            },
                            text: 'Run Selected Test',
                            onclick: async () => {
                                const selectedTest = context.getState('selectedTest');
                                if (!selectedTest) return;
                                
                                context.setState(`testResults.${selectedTest}`, { status: 'running' });
                                const result = await testFramework.runTest(selectedTest);
                                context.setState(`testResults.${selectedTest}`, result);
                            }
                        }
                    },
                    {
                        button: {
                            style: {
                                background: '#FF9800',
                                color: 'white',
                                border: 'none',
                                padding: '8px 16px',
                                borderRadius: '4px',
                                cursor: 'pointer',
                                fontSize: '14px'
                            },
                            text: 'Clear Results',
                            onclick: () => {
                                context.setState('testResults', {});
                                context.setState('selectedTest', null);
                            }
                        }
                    },
                    { 'TestSummary': {} }
                ]
            }
        });

        const CategoryHeader = (props, context) => ({
            div: {
                style: {
                    padding: '12px 16px',
                    background: '#333',
                    fontWeight: 'bold',
                    borderBottom: '1px solid #444',
                    fontSize: '14px'
                },
                text: props.category
            }
        });

        const TestListItem = (props, context) => {
            const test = props.test;
            
            return {
                div: {
                    style: () => {
                        const isSelected = context.getState('selectedTest') === test.name;
                        const result = context.getState(`testResults.${test.name}`);
                        
                        return {
                            padding: '12px 16px',
                            cursor: 'pointer',
                            borderBottom: '1px solid #333',
                            backgroundColor: isSelected ? '#2d2d2d' : 'transparent',
                            borderLeft: (() => {
                                if (isSelected) return '4px solid #667eea';
                                const status = result?.status;
                                if (status === 'pass') return '4px solid #4CAF50';
                                if (status === 'fail') return '4px solid #f44336';
                                if (status === 'running') return '4px solid #2196F3';
                                return '4px solid #666';
                            })(),
                            transition: 'all 0.2s ease'
                        };
                    },
                    onclick: () => {
                        console.log('Clicking test:', test.name);
                        context.setState('selectedTest', test.name);
                    },
                    children: () => {
                        const isSelected = context.getState('selectedTest') === test.name;
                        const result = context.getState(`testResults.${test.name}`);
                        
                        return [
                            {
                                div: {
                                    style: {
                                        fontWeight: isSelected ? 'bold' : 'normal',
                                        marginBottom: '4px',
                                        color: isSelected ? '#ffffff' : '#ccc',
                                        display: 'flex',
                                        alignItems: 'center',
                                        gap: '8px'
                                    },
                                    children: [
                                        {
                                            span: {
                                                style: { fontSize: '12px' },
                                                text: (() => {
                                                    if (!result) return '⚪';
                                                    if (result.status === 'pass') return '✅';
                                                    if (result.status === 'fail') return '❌';
                                                    if (result.status === 'running') return '⏳';
                                                    return '⚪';
                                                })()
                                            }
                                        },
                                        {
                                            span: { text: test.name }
                                        }
                                    ]
                                }
                            },
                            {
                                div: {
                                    style: {
                                        fontSize: '12px',
                                        color: isSelected ? '#aaa' : '#888'
                                    },
                                    text: test.category
                                }
                            },
                            {
                                div: {
                                    style: {
                                        fontSize: '12px',
                                        marginTop: '4px',
                                        color: isSelected ? '#999' : '#777'
                                    },
                                    text: (() => {
                                        if (!result) return '';
                                        if (result.status === 'running') return 'Running...';
                                        if (result.duration) return `${Math.round(result.duration)}ms`;
                                        if (result.status === 'fail' && result.error) {
                                            return `Error: ${result.error.message.substring(0, 30)}...`;
                                        }
                                        return '';
                                    })()
                                }
                            }
                        ];
                    }
                }
            };
        };

        const TestList = (props, context) => ({
            div: {
                style: {
                    width: '400px',
                    background: '#252525',
                    borderRight: '1px solid #444',
                    overflow: 'auto'
                },
                children: () => {
                    const categories = testFramework.getTestsByCategory();
                    const result = [];
                    
                    Object.entries(categories).forEach(([category, tests]) => {
                        result.push({ 'CategoryHeader': { category } });
                        
                        tests.forEach(test => {
                            result.push({ 'TestListItem': { test } });
                        });
                    });
                    
                    return result;
                }
            }
        });

        const TestCodeViewer = (props, context) => {
            return {
                div: {
                    style: { padding: '20px', height: '100%', overflow: 'auto' },
                    children: () => {
                        const selectedTest = context.getState('selectedTest');
                        const result = context.getState(`testResults.${selectedTest}`);
                        const test = selectedTest ? testFramework.tests.get(selectedTest) : null;
                        
                        if (!test) {
                            return [{
                                div: {
                                    style: { 
                                        padding: '20px', 
                                        textAlign: 'center', 
                                        color: '#666',
                                        fontSize: '16px'
                                    },
                                    text: 'Select a test to view its code and results'
                                }
                            }];
                        }
                        
                        const children = [
                            {
                                h2: {
                                    style: { marginBottom: '16px', color: '#e0e0e0' },
                                    text: test.name
                                }
                            },
                            {
                                div: {
                                    style: { 
                                        marginBottom: '20px',
                                        padding: '12px',
                                        background: '#2d2d2d',
                                        borderRadius: '4px'
                                    },
                                    children: [
                                        {
                                            strong: { text: 'Category: ' }
                                        },
                                        {
                                            span: {
                                                style: { color: '#9cdcfe' },
                                                text: test.category
                                            }
                                        }
                                    ]
                                }
                            },
                            {
                                h3: {
                                    style: { marginBottom: '12px', color: '#dcdcaa' },
                                    text: 'Test Code:'
                                }
                            },
                            {
                                pre: {
                                    style: {
                                        background: '#1a1a1a',
                                        padding: '16px',
                                        borderRadius: '4px',
                                        overflow: 'auto',
                                        fontSize: '14px',
                                        lineHeight: '1.5',
                                        border: '1px solid #333',
                                        whiteSpace: 'pre-wrap'
                                    },
                                    innerHTML: highlightCode(test.code)
                                }
                            }
                        ];

                        if (result) {
                            children.splice(2, 0, {
                                div: {
                                    style: { 
                                        marginBottom: '16px',
                                        padding: '12px',
                                        borderRadius: '4px',
                                        backgroundColor: (() => {
                                            if (result.status === 'pass') return 'rgba(76, 175, 80, 0.1)';
                                            if (result.status === 'fail') return 'rgba(244, 67, 54, 0.1)';
                                            if (result.status === 'running') return 'rgba(33, 150, 243, 0.1)';
                                            return '#2d2d2d';
                                        })(),
                                        border: (() => {
                                            if (result.status === 'pass') return '1px solid #4CAF50';
                                            if (result.status === 'fail') return '1px solid #f44336';
                                            if (result.status === 'running') return '1px solid #2196F3';
                                            return '1px solid #666';
                                        })()
                                    },
                                    children: [
                                        {
                                            div: {
                                                style: { 
                                                    display: 'flex', 
                                                    alignItems: 'center', 
                                                    gap: '8px', 
                                                    marginBottom: '8px' 
                                                },
                                                children: [
                                                    {
                                                        span: {
                                                            style: { fontSize: '16px' },
                                                            text: (() => {
                                                                if (result.status === 'pass') return '✅';
                                                                if (result.status === 'fail') return '❌';
                                                                if (result.status === 'running') return '⏳';
                                                                return '⚪';
                                                            })()
                                                        }
                                                    },
                                                    {
                                                        strong: { 
                                                            text: result.status.toUpperCase(),
                                                            style: {
                                                                color: (() => {
                                                                    if (result.status === 'pass') return '#4CAF50';
                                                                    if (result.status === 'fail') return '#f44336';
                                                                    if (result.status === 'running') return '#2196F3';
                                                                    return '#888';
                                                                })()
                                                            }
                                                        }
                                                    },
                                                    result.duration ? {
                                                        span: {
                                                            style: { marginLeft: '10px', color: '#888', fontSize: '12px' },
                                                            text: `(${Math.round(result.duration)}ms)`
                                                        }
                                                    } : null
                                                ]
                                            }
                                        },
                                        result.assertions && result.assertions.length > 0 ? {
                                            div: {
                                                style: { fontSize: '12px', color: '#ccc' },
                                                text: `${result.assertions.filter(a => a.passed).length}/${result.assertions.length} assertions passed`
                                            }
                                        } : null
                                    ]
                                }
                            });

                            // Add assertions if available
                            if (result.assertions && result.assertions.length > 0) {
                                children.push({
                                    div: {
                                        style: { marginTop: '20px' },
                                        children: [
                                            {
                                                h3: {
                                                    style: { marginBottom: '12px', color: '#dcdcaa' },
                                                    text: `Assertions (${result.assertions.filter(a => a.passed).length}/${result.assertions.length}):`
                                                }
                                            },
                                            ...result.assertions.map(assertion => ({
                                                div: {
                                                    className: `assertion ${assertion.passed ? 'pass' : 'fail'}`,
                                                    style: {
                                                        margin: '4px 0',
                                                        padding: '6px 10px',
                                                        borderRadius: '3px',
                                                        fontSize: '13px',
                                                        backgroundColor: assertion.passed ? 'rgba(76, 175, 80, 0.1)' : 'rgba(244, 67, 54, 0.1)',
                                                        color: assertion.passed ? '#4CAF50' : '#f44336',
                                                        border: assertion.passed ? '1px solid rgba(76, 175, 80, 0.3)' : '1px solid rgba(244, 67, 54, 0.3)'
                                                    },
                                                    text: `${assertion.passed ? '✓' : '✗'} ${assertion.message}`
                                                }
                                            }))
                                        ]
                                    }
                                });
                            }

                            // Add error if available
                            if (result.error) {
                                children.push({
                                    div: {
                                        style: { marginTop: '20px' },
                                        children: [
                                            {
                                                h3: {
                                                    style: { marginBottom: '12px', color: '#f44336' },
                                                    text: 'Error Details:'
                                                }
                                            },
                                            {
                                                div: {
                                                    className: 'error-stack',
                                                    style: {
                                                        backgroundColor: '#2a1a1a',
                                                        padding: '12px',
                                                        margin: '5px 0',
                                                        borderRadius: '4px',
                                                        fontSize: '12px',
                                                        whiteSpace: 'pre-wrap',
                                                        overflowX: 'auto',
                                                        border: '1px solid #f44336'
                                                    },
                                                    text: result.error.stack || result.error.message
                                                }
                                            }
                                        ]
                                    }
                                });
                            }
                        }
                        
                        return children;
                    }
                }
            };
        };

        const MainContent = (props, context) => ({
            div: {
                style: {
                    flex: '1',
                    display: 'flex',
                    overflow: 'hidden'
                },
                children: [
                    { 'TestList': {} },
                    {
                        div: {
                            style: {
                                flex: '1',
                                background: '#1e1e1e',
                                overflow: 'hidden'
                            },
                            children: [
                                { 'TestCodeViewer': {} }
                            ]
                        }
                    }
                ]
            }
        });

        const App = (props, context) => ({
            div: {
                style: {
                    height: '100vh',
                    display: 'flex',
                    flexDirection: 'column',
                    background: '#1a1a1a'
                },
                children: [
                    { 'Header': {} },
                    { 'Controls': {} },
                    { 'MainContent': {} }
                ]
            }
        });

        // Juris Application Configuration
        const jurisApp = new Juris({
            renderMode: 'fine-grained',
            logLevel: 1,
            states: {
                selectedTest: null,
                testResults: {},
                isRunning: false,
                filter: ''
            },
            components: {
                Header,
                Controls,
                TestSummary,
                CategoryHeader,
                TestListItem,
                TestList,
                TestCodeViewer,
                MainContent,
                App
            },
            layout: { 'App': {} }
        });

        // Render the application
        jurisApp.render('#app');
    </script>
</body>
</html>